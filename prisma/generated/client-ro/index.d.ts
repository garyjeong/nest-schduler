
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model api_key
 * 
 */
export type api_key = {
  client_id: string
  key: string
}

/**
 * Model cities
 * 
 */
export type cities = {
  code: string
  name: string
  un_locode: string | null
  latitude: number | null
  longitude: number | null
  alt: number | null
  timezone: string | null
  country_code: string | null
}

/**
 * Model cities_translation
 * 
 */
export type cities_translation = {
  city_code: string
  locale: string
  city_name: string
}

/**
 * Model locales
 * 
 */
export type locales = {
  id: number
  name: string
  code: string
  default: boolean
}

/**
 * Model location
 * 
 */
export type location = {
  id: string
  city_code: string | null
  vendor_id: string
  oag_code: string | null
  country_code: string | null
  state: string | null
  zip_code: string | null
  phone: string | null
  alt_phone: string | null
  fax: string | null
  telex: string | null
  web_url: string | null
  email: string | null
  latitude: string | null
  longitude: string | null
  open_1_mon: string | null
  close_1_mon: string | null
  open_2_mon: string | null
  close_2_mon: string | null
  open_3_mon: string | null
  close_3_mon: string | null
  open_1_tue: string | null
  close_1_tue: string | null
  open_2_tue: string | null
  close_2_tue: string | null
  open_3_tue: string | null
  close_3_tue: string | null
  open_1_wed: string | null
  close_1_wed: string | null
  open_2_wed: string | null
  close_2_wed: string | null
  open_3_wed: string | null
  close_3_wed: string | null
  open_1_thu: string | null
  close_1_thu: string | null
  open_2_thu: string | null
  close_2_thu: string | null
  open_3_thu: string | null
  close_3_thu: string | null
  open_1_fri: string | null
  close_1_fri: string | null
  open_2_fri: string | null
  close_2_fri: string | null
  open_3_fri: string | null
  close_3_fri: string | null
  open_1_sat: string | null
  close_1_sat: string | null
  open_2_sat: string | null
  close_2_sat: string | null
  open_3_sat: string | null
  close_3_sat: string | null
  open_1_sun: string | null
  close_1_sun: string | null
  open_2_sun: string | null
  close_2_sun: string | null
  open_3_sun: string | null
  close_3_sun: string | null
  loc_type_1: string | null
  loc_type_2: string | null
  city_name: string | null
  category_id: string | null
}

/**
 * Model location_description
 * 
 */
export type location_description = {
  location_id: string
  locale: string
  description: string | null
  address_1: string | null
  address_2: string | null
  address_3: string | null
}

/**
 * Model translation
 * 
 */
export type translation = {
  locale_id: number
  message: string
  tag: string
}

/**
 * Model countries
 * 
 */
export type countries = {
  code: string
  code_3: string
  name: string
  continent: string | null
  currency: string | null
}

/**
 * Model countries_translation
 * 
 */
export type countries_translation = {
  country_code: string
  locale: string
  country_name: string
}

/**
 * Model location_type_1
 * 
 */
export type location_type_1 = {
  type: string
  description: string
}

/**
 * Model location_type_2
 * 
 */
export type location_type_2 = {
  type: string
  description: string
}

/**
 * Model vendors
 * 
 */
export type vendors = {
  id: string
  name: string
  logo: string | null
  isActive: boolean | null
}

/**
 * Model airports
 * 
 */
export type airports = {
  iata_code: string
  country_code: string | null
  icao_code: string
  name: string
  latitude: number
  longitude: number
  id: number
}

/**
 * Model categories
 * 
 */
export type categories = {
  id: string
  name: string
  icon: string | null
}

/**
 * Model payment
 * 
 */
export type payment = {
  order_id: string
  user_id: number | null
  IMS_commission: Prisma.Decimal | null
  agency_id: string | null
  agency_name: string | null
  pay_type: string | null
  exchange_rate: Prisma.Decimal | null
  first_name: string | null
  korean_name: string | null
  last_name: string | null
  paid_agency: Prisma.Decimal | null
  paid_supplier_date: Date | null
  paid_supplier: Prisma.Decimal | null
  basic_rate: Prisma.Decimal | null
  net: Prisma.Decimal | null
  commission: Prisma.Decimal | null
  currency: string | null
  service_total_amount: Prisma.Decimal | null
  service_rate: Prisma.Decimal | null
  reservation_id: string | null
  supplier: string | null
  imp_uid: string | null
  merchant_uid: string | null
  etc_rate: Prisma.Decimal | null
  total_amount: Prisma.Decimal | null
  pg_amount: Prisma.Decimal | null
  paid_agency_date: Date | null
}

/**
 * Model exchange_rates
 * 
 */
export type exchange_rates = {
  id: number
  from_code: string
  to_code: string
  rate: number
}

/**
 * Model admin_permissions
 * 
 */
export type admin_permissions = {
  id: number
  action: string
  description: string | null
}

/**
 * Model admin_roles
 * 
 */
export type admin_roles = {
  id: number
  name: string
  description: string | null
  created_date: Date | null
  modified_date: Date | null
  created_by: number | null
  modified_by: number | null
  deleted: number | null
}

/**
 * Model admin_roles_permissions
 * 
 */
export type admin_roles_permissions = {
  permission_id: number
  role_id: number
}

/**
 * Model admin_users
 * 
 */
export type admin_users = {
  id: number
  username: string | null
  email: string | null
  hash_pass: string | null
  first_name: string | null
  last_name: string
  phone_mobile: string | null
  address: string | null
  created_date: Date | null
  modified_date: Date | null
  created_by: number | null
  deleted: number | null
  hash_rt: string | null
  modified_by: number | null
  status: string | null
  agency_id: string | null
}

/**
 * Model admin_users_roles
 * 
 */
export type admin_users_roles = {
  user_id: number
  role_id: number
}

/**
 * Model files
 * 
 */
export type files = {
  id: number
  file_key: string | null
  file_url: string | null
}

/**
 * Model settings
 * 
 */
export type settings = {
  category: string
  name: string
  value: string | null
  type: string | null
}

/**
 * Model users
 * 
 */
export type users = {
  id: number
  email: string
  hash_pass: string | null
  created_date: Date | null
  modified_date: Date | null
  deleted: number | null
  hash_rt: string | null
  phone: string | null
  login_type: string | null
  external_id: string | null
  korean_name: string | null
  first_name: string | null
  last_name: string | null
  phone_prefix: string | null
  refund_bank: string | null
  refund_account_number: string | null
  refund_account_holder: string | null
  address: string | null
  hertz_membership: string | null
  airline: string | null
  mileage_number: string | null
  mailing_email: number | null
  mailing_text_msg: number | null
  birthdate: string | null
}

/**
 * Model packages
 * 
 */
export type packages = {
  price_id: string
  service_id: string
}

/**
 * Model price_codes
 * 
 */
export type price_codes = {
  id: string
  price_code: string
  country_code: string
  name: string | null
  price_type: string | null
  vendor_id: string | null
  ITCode: string | null
  cdpNumber: string | null
  show: boolean | null
  insurance: boolean | null
  ko_name: string | null
}

/**
 * Model reservation
 * 
 */
export type reservation = {
  supplier: string | null
  agent_name: string | null
  agent: string | null
  date_request: Date | null
  res_status: string | null
  invoice: string | null
  res_id: string
  korean_name: string | null
  first_name: string | null
  last_name: string | null
  pickup_loc: string | null
  return_loc: string | null
  pickup_datetime: string | null
  return_datetime: string | null
  pay_type: string | null
  currency: string | null
  exchange_rate: Prisma.Decimal | null
  user_id: number | null
  car_model: string | null
  extra_equipmens: string | null
  insurance_info: string | null
  office_address: string | null
  office_name: string | null
  office_time: string | null
  phone_code: string | null
  phone_number: string | null
  services: string | null
  size_car: string | null
  type_car: string | null
  date_cancel: Date | null
  email: string | null
  flight_brand: string | null
  flight_number: string | null
  frequent_flyer: string | null
  hertz_membership: string | null
  office_second_address: string | null
  office_second_name: string | null
  office_second_time: string | null
  dropFee: Prisma.Decimal | null
  rate_amount: Prisma.Decimal | null
  rate_foreigner_amount: Prisma.Decimal | null
  tax: string | null
  total_amount: Prisma.Decimal | null
  total_foreigner_amount: Prisma.Decimal | null
}

/**
 * Model services
 * 
 */
export type services = {
  id: string
  description: string | null
  ko_description: string | null
  details: string | null
  order: number | null
}

/**
 * Model agencies
 * 
 */
export type agencies = {
  id: string
  name: string
  logo: string | null
  created_date: Date | null
}

/**
 * Model commission_setting
 * 
 */
export type commission_setting = {
  id: number
  vendor: string
  agency: string
  payment_type: string
  tag: string
  calculation_type: string
  amount: Prisma.Decimal
}

/**
 * Model coupons
 * 
 */
export type coupons = {
  id: number
  type: string
  coupon_name: string
  brand: string
  destination: string
  offer_description: string | null
  corporate_discount_number: string
  promotion_code: string
  min_days: number
  car_group: string
  pickup_start_time: Date
  pickup_end_time: Date
  order_start_time: Date
  order_end_time: Date
  issued_count: number
  used_count: number | null
  status: string
  remark: string
}

/**
 * Model promotion_code
 * 
 */
export type promotion_code = {
  cdp: string
  pc: string
  vendor_id: string
  country: string
  name: string | null
}

/**
 * Model faq
 * 
 */
export type faq = {
  id: number
  question_kr: string
  question_us: string | null
  answer_kr: string
  answer_us: string | null
  status: string | null
  sort_order: number
  subject_id: number | null
}

/**
 * Model error_messages
 * 
 */
export type error_messages = {
  error_code: string
  english_message: string
  korean_message: string
}

/**
 * Model exchange_rate_history
 * 
 */
export type exchange_rate_history = {
  id: number
  exchange_rate_id: number
  rate: number
  date: Date
}

/**
 * Model subject_faq
 * 
 */
export type subject_faq = {
  id: number
  name: string
}

/**
 * Model keyword_faq
 * 
 */
export type keyword_faq = {
  id: number
  name: string
  faq_id: number
}

/**
 * Model cities_locations
 * 
 */
export type cities_locations = {
  city_code: string
  location_id: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Api_keys
 * const api_keys = await prisma.api_key.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Api_keys
   * const api_keys = await prisma.api_key.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.api_key`: Exposes CRUD operations for the **api_key** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_keys
    * const api_keys = await prisma.api_key.findMany()
    * ```
    */
  get api_key(): Prisma.api_keyDelegate<GlobalReject>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.citiesDelegate<GlobalReject>;

  /**
   * `prisma.cities_translation`: Exposes CRUD operations for the **cities_translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities_translations
    * const cities_translations = await prisma.cities_translation.findMany()
    * ```
    */
  get cities_translation(): Prisma.cities_translationDelegate<GlobalReject>;

  /**
   * `prisma.locales`: Exposes CRUD operations for the **locales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locales
    * const locales = await prisma.locales.findMany()
    * ```
    */
  get locales(): Prisma.localesDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<GlobalReject>;

  /**
   * `prisma.location_description`: Exposes CRUD operations for the **location_description** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_descriptions
    * const location_descriptions = await prisma.location_description.findMany()
    * ```
    */
  get location_description(): Prisma.location_descriptionDelegate<GlobalReject>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.translationDelegate<GlobalReject>;

  /**
   * `prisma.countries`: Exposes CRUD operations for the **countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.countriesDelegate<GlobalReject>;

  /**
   * `prisma.countries_translation`: Exposes CRUD operations for the **countries_translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries_translations
    * const countries_translations = await prisma.countries_translation.findMany()
    * ```
    */
  get countries_translation(): Prisma.countries_translationDelegate<GlobalReject>;

  /**
   * `prisma.location_type_1`: Exposes CRUD operations for the **location_type_1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_type_1s
    * const location_type_1s = await prisma.location_type_1.findMany()
    * ```
    */
  get location_type_1(): Prisma.location_type_1Delegate<GlobalReject>;

  /**
   * `prisma.location_type_2`: Exposes CRUD operations for the **location_type_2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Location_type_2s
    * const location_type_2s = await prisma.location_type_2.findMany()
    * ```
    */
  get location_type_2(): Prisma.location_type_2Delegate<GlobalReject>;

  /**
   * `prisma.vendors`: Exposes CRUD operations for the **vendors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendors.findMany()
    * ```
    */
  get vendors(): Prisma.vendorsDelegate<GlobalReject>;

  /**
   * `prisma.airports`: Exposes CRUD operations for the **airports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Airports
    * const airports = await prisma.airports.findMany()
    * ```
    */
  get airports(): Prisma.airportsDelegate<GlobalReject>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<GlobalReject>;

  /**
   * `prisma.exchange_rates`: Exposes CRUD operations for the **exchange_rates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchange_rates
    * const exchange_rates = await prisma.exchange_rates.findMany()
    * ```
    */
  get exchange_rates(): Prisma.exchange_ratesDelegate<GlobalReject>;

  /**
   * `prisma.admin_permissions`: Exposes CRUD operations for the **admin_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_permissions
    * const admin_permissions = await prisma.admin_permissions.findMany()
    * ```
    */
  get admin_permissions(): Prisma.admin_permissionsDelegate<GlobalReject>;

  /**
   * `prisma.admin_roles`: Exposes CRUD operations for the **admin_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_roles
    * const admin_roles = await prisma.admin_roles.findMany()
    * ```
    */
  get admin_roles(): Prisma.admin_rolesDelegate<GlobalReject>;

  /**
   * `prisma.admin_roles_permissions`: Exposes CRUD operations for the **admin_roles_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_roles_permissions
    * const admin_roles_permissions = await prisma.admin_roles_permissions.findMany()
    * ```
    */
  get admin_roles_permissions(): Prisma.admin_roles_permissionsDelegate<GlobalReject>;

  /**
   * `prisma.admin_users`: Exposes CRUD operations for the **admin_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_users
    * const admin_users = await prisma.admin_users.findMany()
    * ```
    */
  get admin_users(): Prisma.admin_usersDelegate<GlobalReject>;

  /**
   * `prisma.admin_users_roles`: Exposes CRUD operations for the **admin_users_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_users_roles
    * const admin_users_roles = await prisma.admin_users_roles.findMany()
    * ```
    */
  get admin_users_roles(): Prisma.admin_users_rolesDelegate<GlobalReject>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.filesDelegate<GlobalReject>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.packages`: Exposes CRUD operations for the **packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.packages.findMany()
    * ```
    */
  get packages(): Prisma.packagesDelegate<GlobalReject>;

  /**
   * `prisma.price_codes`: Exposes CRUD operations for the **price_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Price_codes
    * const price_codes = await prisma.price_codes.findMany()
    * ```
    */
  get price_codes(): Prisma.price_codesDelegate<GlobalReject>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.reservationDelegate<GlobalReject>;

  /**
   * `prisma.services`: Exposes CRUD operations for the **services** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.services.findMany()
    * ```
    */
  get services(): Prisma.servicesDelegate<GlobalReject>;

  /**
   * `prisma.agencies`: Exposes CRUD operations for the **agencies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agencies.findMany()
    * ```
    */
  get agencies(): Prisma.agenciesDelegate<GlobalReject>;

  /**
   * `prisma.commission_setting`: Exposes CRUD operations for the **commission_setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commission_settings
    * const commission_settings = await prisma.commission_setting.findMany()
    * ```
    */
  get commission_setting(): Prisma.commission_settingDelegate<GlobalReject>;

  /**
   * `prisma.coupons`: Exposes CRUD operations for the **coupons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupons.findMany()
    * ```
    */
  get coupons(): Prisma.couponsDelegate<GlobalReject>;

  /**
   * `prisma.promotion_code`: Exposes CRUD operations for the **promotion_code** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotion_codes
    * const promotion_codes = await prisma.promotion_code.findMany()
    * ```
    */
  get promotion_code(): Prisma.promotion_codeDelegate<GlobalReject>;

  /**
   * `prisma.faq`: Exposes CRUD operations for the **faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faq.findMany()
    * ```
    */
  get faq(): Prisma.faqDelegate<GlobalReject>;

  /**
   * `prisma.error_messages`: Exposes CRUD operations for the **error_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Error_messages
    * const error_messages = await prisma.error_messages.findMany()
    * ```
    */
  get error_messages(): Prisma.error_messagesDelegate<GlobalReject>;

  /**
   * `prisma.exchange_rate_history`: Exposes CRUD operations for the **exchange_rate_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchange_rate_histories
    * const exchange_rate_histories = await prisma.exchange_rate_history.findMany()
    * ```
    */
  get exchange_rate_history(): Prisma.exchange_rate_historyDelegate<GlobalReject>;

  /**
   * `prisma.subject_faq`: Exposes CRUD operations for the **subject_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subject_faqs
    * const subject_faqs = await prisma.subject_faq.findMany()
    * ```
    */
  get subject_faq(): Prisma.subject_faqDelegate<GlobalReject>;

  /**
   * `prisma.keyword_faq`: Exposes CRUD operations for the **keyword_faq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keyword_faqs
    * const keyword_faqs = await prisma.keyword_faq.findMany()
    * ```
    */
  get keyword_faq(): Prisma.keyword_faqDelegate<GlobalReject>;

  /**
   * `prisma.cities_locations`: Exposes CRUD operations for the **cities_locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities_locations
    * const cities_locations = await prisma.cities_locations.findMany()
    * ```
    */
  get cities_locations(): Prisma.cities_locationsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Extensions
   */
  export type Extension = runtime.Extension 

  /**
   * Prisma Client JS version: 4.5.0
   * Query Engine version: 0362da9eebca54d94c8ef5edd3b2e90af99ba452
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export import FieldRef = runtime.FieldRef

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    api_key: 'api_key',
    cities: 'cities',
    cities_translation: 'cities_translation',
    locales: 'locales',
    location: 'location',
    location_description: 'location_description',
    translation: 'translation',
    countries: 'countries',
    countries_translation: 'countries_translation',
    location_type_1: 'location_type_1',
    location_type_2: 'location_type_2',
    vendors: 'vendors',
    airports: 'airports',
    categories: 'categories',
    payment: 'payment',
    exchange_rates: 'exchange_rates',
    admin_permissions: 'admin_permissions',
    admin_roles: 'admin_roles',
    admin_roles_permissions: 'admin_roles_permissions',
    admin_users: 'admin_users',
    admin_users_roles: 'admin_users_roles',
    files: 'files',
    settings: 'settings',
    users: 'users',
    packages: 'packages',
    price_codes: 'price_codes',
    reservation: 'reservation',
    services: 'services',
    agencies: 'agencies',
    commission_setting: 'commission_setting',
    coupons: 'coupons',
    promotion_code: 'promotion_code',
    faq: 'faq',
    error_messages: 'error_messages',
    exchange_rate_history: 'exchange_rate_history',
    subject_faq: 'subject_faq',
    keyword_faq: 'keyword_faq',
    cities_locations: 'cities_locations'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;


  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CitiesCountOutputType
   */


  export type CitiesCountOutputType = {
    cities_translation: number
  }

  export type CitiesCountOutputTypeSelect = {
    cities_translation?: boolean
  }

  export type CitiesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CitiesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CitiesCountOutputType
    : S extends undefined
    ? never
    : S extends CitiesCountOutputTypeArgs
    ?'include' extends U
    ? CitiesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CitiesCountOutputType ? CitiesCountOutputType[P] : never
  } 
    : CitiesCountOutputType
  : CitiesCountOutputType




  // Custom InputTypes

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CitiesCountOutputType
     * 
    **/
    select?: CitiesCountOutputTypeSelect | null
  }



  /**
   * Count Type LocalesCountOutputType
   */


  export type LocalesCountOutputType = {
    translation: number
  }

  export type LocalesCountOutputTypeSelect = {
    translation?: boolean
  }

  export type LocalesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LocalesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LocalesCountOutputType
    : S extends undefined
    ? never
    : S extends LocalesCountOutputTypeArgs
    ?'include' extends U
    ? LocalesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LocalesCountOutputType ? LocalesCountOutputType[P] : never
  } 
    : LocalesCountOutputType
  : LocalesCountOutputType




  // Custom InputTypes

  /**
   * LocalesCountOutputType without action
   */
  export type LocalesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocalesCountOutputType
     * 
    **/
    select?: LocalesCountOutputTypeSelect | null
  }



  /**
   * Count Type LocationCountOutputType
   */


  export type LocationCountOutputType = {
    location_description: number
  }

  export type LocationCountOutputTypeSelect = {
    location_description?: boolean
  }

  export type LocationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LocationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LocationCountOutputType
    : S extends undefined
    ? never
    : S extends LocationCountOutputTypeArgs
    ?'include' extends U
    ? LocationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LocationCountOutputType ? LocationCountOutputType[P] : never
  } 
    : LocationCountOutputType
  : LocationCountOutputType




  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     * 
    **/
    select?: LocationCountOutputTypeSelect | null
  }



  /**
   * Count Type CountriesCountOutputType
   */


  export type CountriesCountOutputType = {
    airports: number
    cities: number
    countries_translation: number
  }

  export type CountriesCountOutputTypeSelect = {
    airports?: boolean
    cities?: boolean
    countries_translation?: boolean
  }

  export type CountriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CountriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CountriesCountOutputType
    : S extends undefined
    ? never
    : S extends CountriesCountOutputTypeArgs
    ?'include' extends U
    ? CountriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CountriesCountOutputType ? CountriesCountOutputType[P] : never
  } 
    : CountriesCountOutputType
  : CountriesCountOutputType




  // Custom InputTypes

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CountriesCountOutputType
     * 
    **/
    select?: CountriesCountOutputTypeSelect | null
  }



  /**
   * Count Type Location_type_1CountOutputType
   */


  export type Location_type_1CountOutputType = {
    location: number
  }

  export type Location_type_1CountOutputTypeSelect = {
    location?: boolean
  }

  export type Location_type_1CountOutputTypeGetPayload<
    S extends boolean | null | undefined | Location_type_1CountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Location_type_1CountOutputType
    : S extends undefined
    ? never
    : S extends Location_type_1CountOutputTypeArgs
    ?'include' extends U
    ? Location_type_1CountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Location_type_1CountOutputType ? Location_type_1CountOutputType[P] : never
  } 
    : Location_type_1CountOutputType
  : Location_type_1CountOutputType




  // Custom InputTypes

  /**
   * Location_type_1CountOutputType without action
   */
  export type Location_type_1CountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Location_type_1CountOutputType
     * 
    **/
    select?: Location_type_1CountOutputTypeSelect | null
  }



  /**
   * Count Type Location_type_2CountOutputType
   */


  export type Location_type_2CountOutputType = {
    location: number
  }

  export type Location_type_2CountOutputTypeSelect = {
    location?: boolean
  }

  export type Location_type_2CountOutputTypeGetPayload<
    S extends boolean | null | undefined | Location_type_2CountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Location_type_2CountOutputType
    : S extends undefined
    ? never
    : S extends Location_type_2CountOutputTypeArgs
    ?'include' extends U
    ? Location_type_2CountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Location_type_2CountOutputType ? Location_type_2CountOutputType[P] : never
  } 
    : Location_type_2CountOutputType
  : Location_type_2CountOutputType




  // Custom InputTypes

  /**
   * Location_type_2CountOutputType without action
   */
  export type Location_type_2CountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Location_type_2CountOutputType
     * 
    **/
    select?: Location_type_2CountOutputTypeSelect | null
  }



  /**
   * Count Type VendorsCountOutputType
   */


  export type VendorsCountOutputType = {
    commission_setting: number
    location: number
    reservation: number
  }

  export type VendorsCountOutputTypeSelect = {
    commission_setting?: boolean
    location?: boolean
    reservation?: boolean
  }

  export type VendorsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VendorsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VendorsCountOutputType
    : S extends undefined
    ? never
    : S extends VendorsCountOutputTypeArgs
    ?'include' extends U
    ? VendorsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VendorsCountOutputType ? VendorsCountOutputType[P] : never
  } 
    : VendorsCountOutputType
  : VendorsCountOutputType




  // Custom InputTypes

  /**
   * VendorsCountOutputType without action
   */
  export type VendorsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorsCountOutputType
     * 
    **/
    select?: VendorsCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoriesCountOutputType
   */


  export type CategoriesCountOutputType = {
    location: number
  }

  export type CategoriesCountOutputTypeSelect = {
    location?: boolean
  }

  export type CategoriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CategoriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CategoriesCountOutputType
    : S extends undefined
    ? never
    : S extends CategoriesCountOutputTypeArgs
    ?'include' extends U
    ? CategoriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CategoriesCountOutputType ? CategoriesCountOutputType[P] : never
  } 
    : CategoriesCountOutputType
  : CategoriesCountOutputType




  // Custom InputTypes

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     * 
    **/
    select?: CategoriesCountOutputTypeSelect | null
  }



  /**
   * Count Type Exchange_ratesCountOutputType
   */


  export type Exchange_ratesCountOutputType = {
    exchange_rate_history: number
  }

  export type Exchange_ratesCountOutputTypeSelect = {
    exchange_rate_history?: boolean
  }

  export type Exchange_ratesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Exchange_ratesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Exchange_ratesCountOutputType
    : S extends undefined
    ? never
    : S extends Exchange_ratesCountOutputTypeArgs
    ?'include' extends U
    ? Exchange_ratesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Exchange_ratesCountOutputType ? Exchange_ratesCountOutputType[P] : never
  } 
    : Exchange_ratesCountOutputType
  : Exchange_ratesCountOutputType




  // Custom InputTypes

  /**
   * Exchange_ratesCountOutputType without action
   */
  export type Exchange_ratesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Exchange_ratesCountOutputType
     * 
    **/
    select?: Exchange_ratesCountOutputTypeSelect | null
  }



  /**
   * Count Type Admin_permissionsCountOutputType
   */


  export type Admin_permissionsCountOutputType = {
    admin_roles_permissions: number
  }

  export type Admin_permissionsCountOutputTypeSelect = {
    admin_roles_permissions?: boolean
  }

  export type Admin_permissionsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Admin_permissionsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Admin_permissionsCountOutputType
    : S extends undefined
    ? never
    : S extends Admin_permissionsCountOutputTypeArgs
    ?'include' extends U
    ? Admin_permissionsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin_permissionsCountOutputType ? Admin_permissionsCountOutputType[P] : never
  } 
    : Admin_permissionsCountOutputType
  : Admin_permissionsCountOutputType




  // Custom InputTypes

  /**
   * Admin_permissionsCountOutputType without action
   */
  export type Admin_permissionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Admin_permissionsCountOutputType
     * 
    **/
    select?: Admin_permissionsCountOutputTypeSelect | null
  }



  /**
   * Count Type Admin_rolesCountOutputType
   */


  export type Admin_rolesCountOutputType = {
    admin_roles_permissions: number
    admin_users_roles: number
  }

  export type Admin_rolesCountOutputTypeSelect = {
    admin_roles_permissions?: boolean
    admin_users_roles?: boolean
  }

  export type Admin_rolesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Admin_rolesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Admin_rolesCountOutputType
    : S extends undefined
    ? never
    : S extends Admin_rolesCountOutputTypeArgs
    ?'include' extends U
    ? Admin_rolesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin_rolesCountOutputType ? Admin_rolesCountOutputType[P] : never
  } 
    : Admin_rolesCountOutputType
  : Admin_rolesCountOutputType




  // Custom InputTypes

  /**
   * Admin_rolesCountOutputType without action
   */
  export type Admin_rolesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Admin_rolesCountOutputType
     * 
    **/
    select?: Admin_rolesCountOutputTypeSelect | null
  }



  /**
   * Count Type Admin_usersCountOutputType
   */


  export type Admin_usersCountOutputType = {
    admin_roles_admin_roles_created_byToadmin_users: number
    admin_roles_admin_roles_modified_byToadmin_users: number
    other_admin_users_admin_usersToadmin_users_created_by: number
    other_admin_users_admin_usersToadmin_users_modified_by: number
    admin_users_roles: number
  }

  export type Admin_usersCountOutputTypeSelect = {
    admin_roles_admin_roles_created_byToadmin_users?: boolean
    admin_roles_admin_roles_modified_byToadmin_users?: boolean
    other_admin_users_admin_usersToadmin_users_created_by?: boolean
    other_admin_users_admin_usersToadmin_users_modified_by?: boolean
    admin_users_roles?: boolean
  }

  export type Admin_usersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Admin_usersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Admin_usersCountOutputType
    : S extends undefined
    ? never
    : S extends Admin_usersCountOutputTypeArgs
    ?'include' extends U
    ? Admin_usersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Admin_usersCountOutputType ? Admin_usersCountOutputType[P] : never
  } 
    : Admin_usersCountOutputType
  : Admin_usersCountOutputType




  // Custom InputTypes

  /**
   * Admin_usersCountOutputType without action
   */
  export type Admin_usersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Admin_usersCountOutputType
     * 
    **/
    select?: Admin_usersCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    payment: number
    reservation: number
  }

  export type UsersCountOutputTypeSelect = {
    payment?: boolean
    reservation?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type Price_codesCountOutputType
   */


  export type Price_codesCountOutputType = {
    packages: number
  }

  export type Price_codesCountOutputTypeSelect = {
    packages?: boolean
  }

  export type Price_codesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Price_codesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Price_codesCountOutputType
    : S extends undefined
    ? never
    : S extends Price_codesCountOutputTypeArgs
    ?'include' extends U
    ? Price_codesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Price_codesCountOutputType ? Price_codesCountOutputType[P] : never
  } 
    : Price_codesCountOutputType
  : Price_codesCountOutputType




  // Custom InputTypes

  /**
   * Price_codesCountOutputType without action
   */
  export type Price_codesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Price_codesCountOutputType
     * 
    **/
    select?: Price_codesCountOutputTypeSelect | null
  }



  /**
   * Count Type ReservationCountOutputType
   */


  export type ReservationCountOutputType = {
    payment: number
  }

  export type ReservationCountOutputTypeSelect = {
    payment?: boolean
  }

  export type ReservationCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReservationCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReservationCountOutputType
    : S extends undefined
    ? never
    : S extends ReservationCountOutputTypeArgs
    ?'include' extends U
    ? ReservationCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReservationCountOutputType ? ReservationCountOutputType[P] : never
  } 
    : ReservationCountOutputType
  : ReservationCountOutputType




  // Custom InputTypes

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     * 
    **/
    select?: ReservationCountOutputTypeSelect | null
  }



  /**
   * Count Type ServicesCountOutputType
   */


  export type ServicesCountOutputType = {
    packages: number
  }

  export type ServicesCountOutputTypeSelect = {
    packages?: boolean
  }

  export type ServicesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ServicesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ServicesCountOutputType
    : S extends undefined
    ? never
    : S extends ServicesCountOutputTypeArgs
    ?'include' extends U
    ? ServicesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ServicesCountOutputType ? ServicesCountOutputType[P] : never
  } 
    : ServicesCountOutputType
  : ServicesCountOutputType




  // Custom InputTypes

  /**
   * ServicesCountOutputType without action
   */
  export type ServicesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServicesCountOutputType
     * 
    **/
    select?: ServicesCountOutputTypeSelect | null
  }



  /**
   * Count Type AgenciesCountOutputType
   */


  export type AgenciesCountOutputType = {
    admin_users: number
    commission_setting: number
    reservation: number
  }

  export type AgenciesCountOutputTypeSelect = {
    admin_users?: boolean
    commission_setting?: boolean
    reservation?: boolean
  }

  export type AgenciesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | AgenciesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? AgenciesCountOutputType
    : S extends undefined
    ? never
    : S extends AgenciesCountOutputTypeArgs
    ?'include' extends U
    ? AgenciesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof AgenciesCountOutputType ? AgenciesCountOutputType[P] : never
  } 
    : AgenciesCountOutputType
  : AgenciesCountOutputType




  // Custom InputTypes

  /**
   * AgenciesCountOutputType without action
   */
  export type AgenciesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AgenciesCountOutputType
     * 
    **/
    select?: AgenciesCountOutputTypeSelect | null
  }



  /**
   * Count Type FaqCountOutputType
   */


  export type FaqCountOutputType = {
    keyword_faq: number
  }

  export type FaqCountOutputTypeSelect = {
    keyword_faq?: boolean
  }

  export type FaqCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FaqCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FaqCountOutputType
    : S extends undefined
    ? never
    : S extends FaqCountOutputTypeArgs
    ?'include' extends U
    ? FaqCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FaqCountOutputType ? FaqCountOutputType[P] : never
  } 
    : FaqCountOutputType
  : FaqCountOutputType




  // Custom InputTypes

  /**
   * FaqCountOutputType without action
   */
  export type FaqCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FaqCountOutputType
     * 
    **/
    select?: FaqCountOutputTypeSelect | null
  }



  /**
   * Count Type Subject_faqCountOutputType
   */


  export type Subject_faqCountOutputType = {
    faq: number
  }

  export type Subject_faqCountOutputTypeSelect = {
    faq?: boolean
  }

  export type Subject_faqCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Subject_faqCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Subject_faqCountOutputType
    : S extends undefined
    ? never
    : S extends Subject_faqCountOutputTypeArgs
    ?'include' extends U
    ? Subject_faqCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Subject_faqCountOutputType ? Subject_faqCountOutputType[P] : never
  } 
    : Subject_faqCountOutputType
  : Subject_faqCountOutputType




  // Custom InputTypes

  /**
   * Subject_faqCountOutputType without action
   */
  export type Subject_faqCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Subject_faqCountOutputType
     * 
    **/
    select?: Subject_faqCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model api_key
   */


  export type AggregateApi_key = {
    _count: Api_keyCountAggregateOutputType | null
    _min: Api_keyMinAggregateOutputType | null
    _max: Api_keyMaxAggregateOutputType | null
  }

  export type Api_keyMinAggregateOutputType = {
    client_id: string | null
    key: string | null
  }

  export type Api_keyMaxAggregateOutputType = {
    client_id: string | null
    key: string | null
  }

  export type Api_keyCountAggregateOutputType = {
    client_id: number
    key: number
    _all: number
  }


  export type Api_keyMinAggregateInputType = {
    client_id?: true
    key?: true
  }

  export type Api_keyMaxAggregateInputType = {
    client_id?: true
    key?: true
  }

  export type Api_keyCountAggregateInputType = {
    client_id?: true
    key?: true
    _all?: true
  }

  export type Api_keyAggregateArgs = {
    /**
     * Filter which api_key to aggregate.
     * 
    **/
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     * 
    **/
    orderBy?: Enumerable<api_keyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_keys
    **/
    _count?: true | Api_keyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_keyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_keyMaxAggregateInputType
  }

  export type GetApi_keyAggregateType<T extends Api_keyAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_key]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_key[P]>
      : GetScalarType<T[P], AggregateApi_key[P]>
  }




  export type Api_keyGroupByArgs = {
    where?: api_keyWhereInput
    orderBy?: Enumerable<api_keyOrderByWithAggregationInput>
    by: Array<Api_keyScalarFieldEnum>
    having?: api_keyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_keyCountAggregateInputType | true
    _min?: Api_keyMinAggregateInputType
    _max?: Api_keyMaxAggregateInputType
  }


  export type Api_keyGroupByOutputType = {
    client_id: string
    key: string
    _count: Api_keyCountAggregateOutputType | null
    _min: Api_keyMinAggregateOutputType | null
    _max: Api_keyMaxAggregateOutputType | null
  }

  type GetApi_keyGroupByPayload<T extends Api_keyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Api_keyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_keyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_keyGroupByOutputType[P]>
            : GetScalarType<T[P], Api_keyGroupByOutputType[P]>
        }
      >
    >


  export type api_keySelect = {
    client_id?: boolean
    key?: boolean
  }

  export type api_keyGetPayload<
    S extends boolean | null | undefined | api_keyArgs,
    U = keyof S
      > = S extends true
        ? api_key
    : S extends undefined
    ? never
    : S extends api_keyArgs | api_keyFindManyArgs
    ?'include' extends U
    ? api_key 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof api_key ? api_key[P] : never
  } 
    : api_key
  : api_key


  type api_keyCountArgs = Merge<
    Omit<api_keyFindManyArgs, 'select' | 'include'> & {
      select?: Api_keyCountAggregateInputType | true
    }
  >

  export interface api_keyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Api_key that matches the filter.
     * @param {api_keyFindUniqueArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends api_keyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, api_keyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'api_key'> extends True ? CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>> : CheckSelect<T, Prisma__api_keyClient<api_key | null, null>, Prisma__api_keyClient<api_keyGetPayload<T> | null, null>>

    /**
     * Find the first Api_key that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindFirstArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends api_keyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, api_keyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'api_key'> extends True ? CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>> : CheckSelect<T, Prisma__api_keyClient<api_key | null, null>, Prisma__api_keyClient<api_keyGetPayload<T> | null, null>>

    /**
     * Find zero or more Api_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_keys
     * const api_keys = await prisma.api_key.findMany()
     * 
     * // Get first 10 Api_keys
     * const api_keys = await prisma.api_key.findMany({ take: 10 })
     * 
     * // Only select the `client_id`
     * const api_keyWithClient_idOnly = await prisma.api_key.findMany({ select: { client_id: true } })
     * 
    **/
    findMany<T extends api_keyFindManyArgs>(
      args?: SelectSubset<T, api_keyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<api_key>>, PrismaPromise<Array<api_keyGetPayload<T>>>>

    /**
     * Create a Api_key.
     * @param {api_keyCreateArgs} args - Arguments to create a Api_key.
     * @example
     * // Create one Api_key
     * const Api_key = await prisma.api_key.create({
     *   data: {
     *     // ... data to create a Api_key
     *   }
     * })
     * 
    **/
    create<T extends api_keyCreateArgs>(
      args: SelectSubset<T, api_keyCreateArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Create many Api_keys.
     *     @param {api_keyCreateManyArgs} args - Arguments to create many Api_keys.
     *     @example
     *     // Create many Api_keys
     *     const api_key = await prisma.api_key.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends api_keyCreateManyArgs>(
      args?: SelectSubset<T, api_keyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Api_key.
     * @param {api_keyDeleteArgs} args - Arguments to delete one Api_key.
     * @example
     * // Delete one Api_key
     * const Api_key = await prisma.api_key.delete({
     *   where: {
     *     // ... filter to delete one Api_key
     *   }
     * })
     * 
    **/
    delete<T extends api_keyDeleteArgs>(
      args: SelectSubset<T, api_keyDeleteArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Update one Api_key.
     * @param {api_keyUpdateArgs} args - Arguments to update one Api_key.
     * @example
     * // Update one Api_key
     * const api_key = await prisma.api_key.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends api_keyUpdateArgs>(
      args: SelectSubset<T, api_keyUpdateArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Delete zero or more Api_keys.
     * @param {api_keyDeleteManyArgs} args - Arguments to filter Api_keys to delete.
     * @example
     * // Delete a few Api_keys
     * const { count } = await prisma.api_key.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends api_keyDeleteManyArgs>(
      args?: SelectSubset<T, api_keyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_keys
     * const api_key = await prisma.api_key.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends api_keyUpdateManyArgs>(
      args: SelectSubset<T, api_keyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Api_key.
     * @param {api_keyUpsertArgs} args - Arguments to update or create a Api_key.
     * @example
     * // Update or create a Api_key
     * const api_key = await prisma.api_key.upsert({
     *   create: {
     *     // ... data to create a Api_key
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_key we want to update
     *   }
     * })
    **/
    upsert<T extends api_keyUpsertArgs>(
      args: SelectSubset<T, api_keyUpsertArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Find one Api_key that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {api_keyFindUniqueOrThrowArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends api_keyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, api_keyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Find the first Api_key that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyFindFirstOrThrowArgs} args - Arguments to find a Api_key
     * @example
     * // Get one Api_key
     * const api_key = await prisma.api_key.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends api_keyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, api_keyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__api_keyClient<api_key>, Prisma__api_keyClient<api_keyGetPayload<T>>>

    /**
     * Count the number of Api_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_keyCountArgs} args - Arguments to filter Api_keys to count.
     * @example
     * // Count the number of Api_keys
     * const count = await prisma.api_key.count({
     *   where: {
     *     // ... the filter for the Api_keys we want to count
     *   }
     * })
    **/
    count<T extends api_keyCountArgs>(
      args?: Subset<T, api_keyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_keyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_key.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_keyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_keyAggregateArgs>(args: Subset<T, Api_keyAggregateArgs>): PrismaPromise<GetApi_keyAggregateType<T>>

    /**
     * Group by Api_key.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_keyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Api_keyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Api_keyGroupByArgs['orderBy'] }
        : { orderBy?: Api_keyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Api_keyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_keyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for api_key.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__api_keyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * api_key base type for findUnique actions
   */
  export type api_keyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * Filter, which api_key to fetch.
     * 
    **/
    where: api_keyWhereUniqueInput
  }

  /**
   * api_key: findUnique
   */
  export interface api_keyFindUniqueArgs extends api_keyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * api_key base type for findFirst actions
   */
  export type api_keyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * Filter, which api_key to fetch.
     * 
    **/
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     * 
    **/
    orderBy?: Enumerable<api_keyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_keys.
     * 
    **/
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_keys.
     * 
    **/
    distinct?: Enumerable<Api_keyScalarFieldEnum>
  }

  /**
   * api_key: findFirst
   */
  export interface api_keyFindFirstArgs extends api_keyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * api_key findMany
   */
  export type api_keyFindManyArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * Filter, which api_keys to fetch.
     * 
    **/
    where?: api_keyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_keys to fetch.
     * 
    **/
    orderBy?: Enumerable<api_keyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_keys.
     * 
    **/
    cursor?: api_keyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_keys from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_keys.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Api_keyScalarFieldEnum>
  }


  /**
   * api_key create
   */
  export type api_keyCreateArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * The data needed to create a api_key.
     * 
    **/
    data: XOR<api_keyCreateInput, api_keyUncheckedCreateInput>
  }


  /**
   * api_key createMany
   */
  export type api_keyCreateManyArgs = {
    /**
     * The data used to create many api_keys.
     * 
    **/
    data: Enumerable<api_keyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * api_key update
   */
  export type api_keyUpdateArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * The data needed to update a api_key.
     * 
    **/
    data: XOR<api_keyUpdateInput, api_keyUncheckedUpdateInput>
    /**
     * Choose, which api_key to update.
     * 
    **/
    where: api_keyWhereUniqueInput
  }


  /**
   * api_key updateMany
   */
  export type api_keyUpdateManyArgs = {
    /**
     * The data used to update api_keys.
     * 
    **/
    data: XOR<api_keyUpdateManyMutationInput, api_keyUncheckedUpdateManyInput>
    /**
     * Filter which api_keys to update
     * 
    **/
    where?: api_keyWhereInput
  }


  /**
   * api_key upsert
   */
  export type api_keyUpsertArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * The filter to search for the api_key to update in case it exists.
     * 
    **/
    where: api_keyWhereUniqueInput
    /**
     * In case the api_key found by the `where` argument doesn't exist, create a new api_key with this data.
     * 
    **/
    create: XOR<api_keyCreateInput, api_keyUncheckedCreateInput>
    /**
     * In case the api_key was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<api_keyUpdateInput, api_keyUncheckedUpdateInput>
  }


  /**
   * api_key delete
   */
  export type api_keyDeleteArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
    /**
     * Filter which api_key to delete.
     * 
    **/
    where: api_keyWhereUniqueInput
  }


  /**
   * api_key deleteMany
   */
  export type api_keyDeleteManyArgs = {
    /**
     * Filter which api_keys to delete
     * 
    **/
    where?: api_keyWhereInput
  }


  /**
   * api_key: findUniqueOrThrow
   */
  export type api_keyFindUniqueOrThrowArgs = api_keyFindUniqueArgsBase
      

  /**
   * api_key: findFirstOrThrow
   */
  export type api_keyFindFirstOrThrowArgs = api_keyFindFirstArgsBase
      

  /**
   * api_key without action
   */
  export type api_keyArgs = {
    /**
     * Select specific fields to fetch from the api_key
     * 
    **/
    select?: api_keySelect | null
  }



  /**
   * Model cities
   */


  export type AggregateCities = {
    _count: CitiesCountAggregateOutputType | null
    _avg: CitiesAvgAggregateOutputType | null
    _sum: CitiesSumAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    alt: number | null
  }

  export type CitiesSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    alt: number | null
  }

  export type CitiesMinAggregateOutputType = {
    code: string | null
    name: string | null
    un_locode: string | null
    latitude: number | null
    longitude: number | null
    alt: number | null
    timezone: string | null
    country_code: string | null
  }

  export type CitiesMaxAggregateOutputType = {
    code: string | null
    name: string | null
    un_locode: string | null
    latitude: number | null
    longitude: number | null
    alt: number | null
    timezone: string | null
    country_code: string | null
  }

  export type CitiesCountAggregateOutputType = {
    code: number
    name: number
    un_locode: number
    latitude: number
    longitude: number
    alt: number
    timezone: number
    country_code: number
    _all: number
  }


  export type CitiesAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    alt?: true
  }

  export type CitiesSumAggregateInputType = {
    latitude?: true
    longitude?: true
    alt?: true
  }

  export type CitiesMinAggregateInputType = {
    code?: true
    name?: true
    un_locode?: true
    latitude?: true
    longitude?: true
    alt?: true
    timezone?: true
    country_code?: true
  }

  export type CitiesMaxAggregateInputType = {
    code?: true
    name?: true
    un_locode?: true
    latitude?: true
    longitude?: true
    alt?: true
    timezone?: true
    country_code?: true
  }

  export type CitiesCountAggregateInputType = {
    code?: true
    name?: true
    un_locode?: true
    latitude?: true
    longitude?: true
    alt?: true
    timezone?: true
    country_code?: true
    _all?: true
  }

  export type CitiesAggregateArgs = {
    /**
     * Filter which cities to aggregate.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }




  export type CitiesGroupByArgs = {
    where?: citiesWhereInput
    orderBy?: Enumerable<citiesOrderByWithAggregationInput>
    by: Array<CitiesScalarFieldEnum>
    having?: citiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitiesCountAggregateInputType | true
    _avg?: CitiesAvgAggregateInputType
    _sum?: CitiesSumAggregateInputType
    _min?: CitiesMinAggregateInputType
    _max?: CitiesMaxAggregateInputType
  }


  export type CitiesGroupByOutputType = {
    code: string
    name: string
    un_locode: string | null
    latitude: number | null
    longitude: number | null
    alt: number | null
    timezone: string | null
    country_code: string | null
    _count: CitiesCountAggregateOutputType | null
    _avg: CitiesAvgAggregateOutputType | null
    _sum: CitiesSumAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  type GetCitiesGroupByPayload<T extends CitiesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CitiesGroupByOutputType[P]>
        }
      >
    >


  export type citiesSelect = {
    code?: boolean
    name?: boolean
    un_locode?: boolean
    latitude?: boolean
    longitude?: boolean
    alt?: boolean
    timezone?: boolean
    country_code?: boolean
    countries?: boolean | countriesArgs
    cities_translation?: boolean | cities_translationFindManyArgs
    _count?: boolean | CitiesCountOutputTypeArgs
  }

  export type citiesInclude = {
    countries?: boolean | countriesArgs
    cities_translation?: boolean | cities_translationFindManyArgs
    _count?: boolean | CitiesCountOutputTypeArgs
  }

  export type citiesGetPayload<
    S extends boolean | null | undefined | citiesArgs,
    U = keyof S
      > = S extends true
        ? cities
    : S extends undefined
    ? never
    : S extends citiesArgs | citiesFindManyArgs
    ?'include' extends U
    ? cities  & {
    [P in TrueKeys<S['include']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'cities_translation' ? Array < cities_translationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CitiesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'cities_translation' ? Array < cities_translationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CitiesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof cities ? cities[P] : never
  } 
    : cities
  : cities


  type citiesCountArgs = Merge<
    Omit<citiesFindManyArgs, 'select' | 'include'> & {
      select?: CitiesCountAggregateInputType | true
    }
  >

  export interface citiesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cities that matches the filter.
     * @param {citiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends citiesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, citiesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cities'> extends True ? CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>> : CheckSelect<T, Prisma__citiesClient<cities | null, null>, Prisma__citiesClient<citiesGetPayload<T> | null, null>>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends citiesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, citiesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cities'> extends True ? CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>> : CheckSelect<T, Prisma__citiesClient<cities | null, null>, Prisma__citiesClient<citiesGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const citiesWithCodeOnly = await prisma.cities.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends citiesFindManyArgs>(
      args?: SelectSubset<T, citiesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cities>>, PrismaPromise<Array<citiesGetPayload<T>>>>

    /**
     * Create a Cities.
     * @param {citiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
    **/
    create<T extends citiesCreateArgs>(
      args: SelectSubset<T, citiesCreateArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Create many Cities.
     *     @param {citiesCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const cities = await prisma.cities.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends citiesCreateManyArgs>(
      args?: SelectSubset<T, citiesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cities.
     * @param {citiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
    **/
    delete<T extends citiesDeleteArgs>(
      args: SelectSubset<T, citiesDeleteArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Update one Cities.
     * @param {citiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends citiesUpdateArgs>(
      args: SelectSubset<T, citiesUpdateArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Delete zero or more Cities.
     * @param {citiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends citiesDeleteManyArgs>(
      args?: SelectSubset<T, citiesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends citiesUpdateManyArgs>(
      args: SelectSubset<T, citiesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities.
     * @param {citiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
    **/
    upsert<T extends citiesUpsertArgs>(
      args: SelectSubset<T, citiesUpsertArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Find one Cities that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {citiesFindUniqueOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends citiesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, citiesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Find the first Cities that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends citiesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, citiesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__citiesClient<cities>, Prisma__citiesClient<citiesGetPayload<T>>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends citiesCountArgs>(
      args?: Subset<T, citiesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): PrismaPromise<GetCitiesAggregateType<T>>

    /**
     * Group by Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CitiesGroupByArgs['orderBy'] }
        : { orderBy?: CitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitiesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__citiesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countries<T extends countriesArgs = {}>(args?: Subset<T, countriesArgs>): CheckSelect<T, Prisma__countriesClient<countries | Null>, Prisma__countriesClient<countriesGetPayload<T> | Null>>;

    cities_translation<T extends cities_translationFindManyArgs = {}>(args?: Subset<T, cities_translationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<cities_translation>| Null>, PrismaPromise<Array<cities_translationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cities base type for findUnique actions
   */
  export type citiesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where: citiesWhereUniqueInput
  }

  /**
   * cities: findUnique
   */
  export interface citiesFindUniqueArgs extends citiesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities base type for findFirst actions
   */
  export type citiesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     * 
    **/
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }

  /**
   * cities: findFirst
   */
  export interface citiesFindFirstArgs extends citiesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities findMany
   */
  export type citiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter, which cities to fetch.
     * 
    **/
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     * 
    **/
    orderBy?: Enumerable<citiesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     * 
    **/
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CitiesScalarFieldEnum>
  }


  /**
   * cities create
   */
  export type citiesCreateArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The data needed to create a cities.
     * 
    **/
    data: XOR<citiesCreateInput, citiesUncheckedCreateInput>
  }


  /**
   * cities createMany
   */
  export type citiesCreateManyArgs = {
    /**
     * The data used to create many cities.
     * 
    **/
    data: Enumerable<citiesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cities update
   */
  export type citiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The data needed to update a cities.
     * 
    **/
    data: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
    /**
     * Choose, which cities to update.
     * 
    **/
    where: citiesWhereUniqueInput
  }


  /**
   * cities updateMany
   */
  export type citiesUpdateManyArgs = {
    /**
     * The data used to update cities.
     * 
    **/
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     * 
    **/
    where?: citiesWhereInput
  }


  /**
   * cities upsert
   */
  export type citiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * The filter to search for the cities to update in case it exists.
     * 
    **/
    where: citiesWhereUniqueInput
    /**
     * In case the cities found by the `where` argument doesn't exist, create a new cities with this data.
     * 
    **/
    create: XOR<citiesCreateInput, citiesUncheckedCreateInput>
    /**
     * In case the cities was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
  }


  /**
   * cities delete
   */
  export type citiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
    /**
     * Filter which cities to delete.
     * 
    **/
    where: citiesWhereUniqueInput
  }


  /**
   * cities deleteMany
   */
  export type citiesDeleteManyArgs = {
    /**
     * Filter which cities to delete
     * 
    **/
    where?: citiesWhereInput
  }


  /**
   * cities: findUniqueOrThrow
   */
  export type citiesFindUniqueOrThrowArgs = citiesFindUniqueArgsBase
      

  /**
   * cities: findFirstOrThrow
   */
  export type citiesFindFirstOrThrowArgs = citiesFindFirstArgsBase
      

  /**
   * cities without action
   */
  export type citiesArgs = {
    /**
     * Select specific fields to fetch from the cities
     * 
    **/
    select?: citiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: citiesInclude | null
  }



  /**
   * Model cities_translation
   */


  export type AggregateCities_translation = {
    _count: Cities_translationCountAggregateOutputType | null
    _min: Cities_translationMinAggregateOutputType | null
    _max: Cities_translationMaxAggregateOutputType | null
  }

  export type Cities_translationMinAggregateOutputType = {
    city_code: string | null
    locale: string | null
    city_name: string | null
  }

  export type Cities_translationMaxAggregateOutputType = {
    city_code: string | null
    locale: string | null
    city_name: string | null
  }

  export type Cities_translationCountAggregateOutputType = {
    city_code: number
    locale: number
    city_name: number
    _all: number
  }


  export type Cities_translationMinAggregateInputType = {
    city_code?: true
    locale?: true
    city_name?: true
  }

  export type Cities_translationMaxAggregateInputType = {
    city_code?: true
    locale?: true
    city_name?: true
  }

  export type Cities_translationCountAggregateInputType = {
    city_code?: true
    locale?: true
    city_name?: true
    _all?: true
  }

  export type Cities_translationAggregateArgs = {
    /**
     * Filter which cities_translation to aggregate.
     * 
    **/
    where?: cities_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cities_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities_translations
    **/
    _count?: true | Cities_translationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cities_translationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cities_translationMaxAggregateInputType
  }

  export type GetCities_translationAggregateType<T extends Cities_translationAggregateArgs> = {
        [P in keyof T & keyof AggregateCities_translation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities_translation[P]>
      : GetScalarType<T[P], AggregateCities_translation[P]>
  }




  export type Cities_translationGroupByArgs = {
    where?: cities_translationWhereInput
    orderBy?: Enumerable<cities_translationOrderByWithAggregationInput>
    by: Array<Cities_translationScalarFieldEnum>
    having?: cities_translationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cities_translationCountAggregateInputType | true
    _min?: Cities_translationMinAggregateInputType
    _max?: Cities_translationMaxAggregateInputType
  }


  export type Cities_translationGroupByOutputType = {
    city_code: string
    locale: string
    city_name: string
    _count: Cities_translationCountAggregateOutputType | null
    _min: Cities_translationMinAggregateOutputType | null
    _max: Cities_translationMaxAggregateOutputType | null
  }

  type GetCities_translationGroupByPayload<T extends Cities_translationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cities_translationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cities_translationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cities_translationGroupByOutputType[P]>
            : GetScalarType<T[P], Cities_translationGroupByOutputType[P]>
        }
      >
    >


  export type cities_translationSelect = {
    city_code?: boolean
    locale?: boolean
    city_name?: boolean
    cities?: boolean | citiesArgs
  }

  export type cities_translationInclude = {
    cities?: boolean | citiesArgs
  }

  export type cities_translationGetPayload<
    S extends boolean | null | undefined | cities_translationArgs,
    U = keyof S
      > = S extends true
        ? cities_translation
    : S extends undefined
    ? never
    : S extends cities_translationArgs | cities_translationFindManyArgs
    ?'include' extends U
    ? cities_translation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cities' ? citiesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cities' ? citiesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof cities_translation ? cities_translation[P] : never
  } 
    : cities_translation
  : cities_translation


  type cities_translationCountArgs = Merge<
    Omit<cities_translationFindManyArgs, 'select' | 'include'> & {
      select?: Cities_translationCountAggregateInputType | true
    }
  >

  export interface cities_translationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cities_translation that matches the filter.
     * @param {cities_translationFindUniqueArgs} args - Arguments to find a Cities_translation
     * @example
     * // Get one Cities_translation
     * const cities_translation = await prisma.cities_translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cities_translationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cities_translationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cities_translation'> extends True ? CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>> : CheckSelect<T, Prisma__cities_translationClient<cities_translation | null, null>, Prisma__cities_translationClient<cities_translationGetPayload<T> | null, null>>

    /**
     * Find the first Cities_translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_translationFindFirstArgs} args - Arguments to find a Cities_translation
     * @example
     * // Get one Cities_translation
     * const cities_translation = await prisma.cities_translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cities_translationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cities_translationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cities_translation'> extends True ? CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>> : CheckSelect<T, Prisma__cities_translationClient<cities_translation | null, null>, Prisma__cities_translationClient<cities_translationGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_translationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities_translations
     * const cities_translations = await prisma.cities_translation.findMany()
     * 
     * // Get first 10 Cities_translations
     * const cities_translations = await prisma.cities_translation.findMany({ take: 10 })
     * 
     * // Only select the `city_code`
     * const cities_translationWithCity_codeOnly = await prisma.cities_translation.findMany({ select: { city_code: true } })
     * 
    **/
    findMany<T extends cities_translationFindManyArgs>(
      args?: SelectSubset<T, cities_translationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cities_translation>>, PrismaPromise<Array<cities_translationGetPayload<T>>>>

    /**
     * Create a Cities_translation.
     * @param {cities_translationCreateArgs} args - Arguments to create a Cities_translation.
     * @example
     * // Create one Cities_translation
     * const Cities_translation = await prisma.cities_translation.create({
     *   data: {
     *     // ... data to create a Cities_translation
     *   }
     * })
     * 
    **/
    create<T extends cities_translationCreateArgs>(
      args: SelectSubset<T, cities_translationCreateArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Create many Cities_translations.
     *     @param {cities_translationCreateManyArgs} args - Arguments to create many Cities_translations.
     *     @example
     *     // Create many Cities_translations
     *     const cities_translation = await prisma.cities_translation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cities_translationCreateManyArgs>(
      args?: SelectSubset<T, cities_translationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cities_translation.
     * @param {cities_translationDeleteArgs} args - Arguments to delete one Cities_translation.
     * @example
     * // Delete one Cities_translation
     * const Cities_translation = await prisma.cities_translation.delete({
     *   where: {
     *     // ... filter to delete one Cities_translation
     *   }
     * })
     * 
    **/
    delete<T extends cities_translationDeleteArgs>(
      args: SelectSubset<T, cities_translationDeleteArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Update one Cities_translation.
     * @param {cities_translationUpdateArgs} args - Arguments to update one Cities_translation.
     * @example
     * // Update one Cities_translation
     * const cities_translation = await prisma.cities_translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cities_translationUpdateArgs>(
      args: SelectSubset<T, cities_translationUpdateArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Delete zero or more Cities_translations.
     * @param {cities_translationDeleteManyArgs} args - Arguments to filter Cities_translations to delete.
     * @example
     * // Delete a few Cities_translations
     * const { count } = await prisma.cities_translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cities_translationDeleteManyArgs>(
      args?: SelectSubset<T, cities_translationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_translationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities_translations
     * const cities_translation = await prisma.cities_translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cities_translationUpdateManyArgs>(
      args: SelectSubset<T, cities_translationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities_translation.
     * @param {cities_translationUpsertArgs} args - Arguments to update or create a Cities_translation.
     * @example
     * // Update or create a Cities_translation
     * const cities_translation = await prisma.cities_translation.upsert({
     *   create: {
     *     // ... data to create a Cities_translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities_translation we want to update
     *   }
     * })
    **/
    upsert<T extends cities_translationUpsertArgs>(
      args: SelectSubset<T, cities_translationUpsertArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Find one Cities_translation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cities_translationFindUniqueOrThrowArgs} args - Arguments to find a Cities_translation
     * @example
     * // Get one Cities_translation
     * const cities_translation = await prisma.cities_translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cities_translationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cities_translationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Find the first Cities_translation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_translationFindFirstOrThrowArgs} args - Arguments to find a Cities_translation
     * @example
     * // Get one Cities_translation
     * const cities_translation = await prisma.cities_translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cities_translationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cities_translationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__cities_translationClient<cities_translation>, Prisma__cities_translationClient<cities_translationGetPayload<T>>>

    /**
     * Count the number of Cities_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_translationCountArgs} args - Arguments to filter Cities_translations to count.
     * @example
     * // Count the number of Cities_translations
     * const count = await prisma.cities_translation.count({
     *   where: {
     *     // ... the filter for the Cities_translations we want to count
     *   }
     * })
    **/
    count<T extends cities_translationCountArgs>(
      args?: Subset<T, cities_translationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cities_translationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cities_translationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cities_translationAggregateArgs>(args: Subset<T, Cities_translationAggregateArgs>): PrismaPromise<GetCities_translationAggregateType<T>>

    /**
     * Group by Cities_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cities_translationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cities_translationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cities_translationGroupByArgs['orderBy'] }
        : { orderBy?: Cities_translationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cities_translationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCities_translationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cities_translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cities_translationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cities<T extends citiesArgs = {}>(args?: Subset<T, citiesArgs>): CheckSelect<T, Prisma__citiesClient<cities | Null>, Prisma__citiesClient<citiesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cities_translation base type for findUnique actions
   */
  export type cities_translationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * Filter, which cities_translation to fetch.
     * 
    **/
    where: cities_translationWhereUniqueInput
  }

  /**
   * cities_translation: findUnique
   */
  export interface cities_translationFindUniqueArgs extends cities_translationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities_translation base type for findFirst actions
   */
  export type cities_translationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * Filter, which cities_translation to fetch.
     * 
    **/
    where?: cities_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities_translations.
     * 
    **/
    cursor?: cities_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities_translations.
     * 
    **/
    distinct?: Enumerable<Cities_translationScalarFieldEnum>
  }

  /**
   * cities_translation: findFirst
   */
  export interface cities_translationFindFirstArgs extends cities_translationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities_translation findMany
   */
  export type cities_translationFindManyArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * Filter, which cities_translations to fetch.
     * 
    **/
    where?: cities_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities_translations.
     * 
    **/
    cursor?: cities_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_translations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cities_translationScalarFieldEnum>
  }


  /**
   * cities_translation create
   */
  export type cities_translationCreateArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * The data needed to create a cities_translation.
     * 
    **/
    data: XOR<cities_translationCreateInput, cities_translationUncheckedCreateInput>
  }


  /**
   * cities_translation createMany
   */
  export type cities_translationCreateManyArgs = {
    /**
     * The data used to create many cities_translations.
     * 
    **/
    data: Enumerable<cities_translationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cities_translation update
   */
  export type cities_translationUpdateArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * The data needed to update a cities_translation.
     * 
    **/
    data: XOR<cities_translationUpdateInput, cities_translationUncheckedUpdateInput>
    /**
     * Choose, which cities_translation to update.
     * 
    **/
    where: cities_translationWhereUniqueInput
  }


  /**
   * cities_translation updateMany
   */
  export type cities_translationUpdateManyArgs = {
    /**
     * The data used to update cities_translations.
     * 
    **/
    data: XOR<cities_translationUpdateManyMutationInput, cities_translationUncheckedUpdateManyInput>
    /**
     * Filter which cities_translations to update
     * 
    **/
    where?: cities_translationWhereInput
  }


  /**
   * cities_translation upsert
   */
  export type cities_translationUpsertArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * The filter to search for the cities_translation to update in case it exists.
     * 
    **/
    where: cities_translationWhereUniqueInput
    /**
     * In case the cities_translation found by the `where` argument doesn't exist, create a new cities_translation with this data.
     * 
    **/
    create: XOR<cities_translationCreateInput, cities_translationUncheckedCreateInput>
    /**
     * In case the cities_translation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cities_translationUpdateInput, cities_translationUncheckedUpdateInput>
  }


  /**
   * cities_translation delete
   */
  export type cities_translationDeleteArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
    /**
     * Filter which cities_translation to delete.
     * 
    **/
    where: cities_translationWhereUniqueInput
  }


  /**
   * cities_translation deleteMany
   */
  export type cities_translationDeleteManyArgs = {
    /**
     * Filter which cities_translations to delete
     * 
    **/
    where?: cities_translationWhereInput
  }


  /**
   * cities_translation: findUniqueOrThrow
   */
  export type cities_translationFindUniqueOrThrowArgs = cities_translationFindUniqueArgsBase
      

  /**
   * cities_translation: findFirstOrThrow
   */
  export type cities_translationFindFirstOrThrowArgs = cities_translationFindFirstArgsBase
      

  /**
   * cities_translation without action
   */
  export type cities_translationArgs = {
    /**
     * Select specific fields to fetch from the cities_translation
     * 
    **/
    select?: cities_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cities_translationInclude | null
  }



  /**
   * Model locales
   */


  export type AggregateLocales = {
    _count: LocalesCountAggregateOutputType | null
    _avg: LocalesAvgAggregateOutputType | null
    _sum: LocalesSumAggregateOutputType | null
    _min: LocalesMinAggregateOutputType | null
    _max: LocalesMaxAggregateOutputType | null
  }

  export type LocalesAvgAggregateOutputType = {
    id: number | null
  }

  export type LocalesSumAggregateOutputType = {
    id: number | null
  }

  export type LocalesMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    default: boolean | null
  }

  export type LocalesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    default: boolean | null
  }

  export type LocalesCountAggregateOutputType = {
    id: number
    name: number
    code: number
    default: number
    _all: number
  }


  export type LocalesAvgAggregateInputType = {
    id?: true
  }

  export type LocalesSumAggregateInputType = {
    id?: true
  }

  export type LocalesMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    default?: true
  }

  export type LocalesMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    default?: true
  }

  export type LocalesCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    default?: true
    _all?: true
  }

  export type LocalesAggregateArgs = {
    /**
     * Filter which locales to aggregate.
     * 
    **/
    where?: localesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locales to fetch.
     * 
    **/
    orderBy?: Enumerable<localesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: localesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locales.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locales
    **/
    _count?: true | LocalesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalesMaxAggregateInputType
  }

  export type GetLocalesAggregateType<T extends LocalesAggregateArgs> = {
        [P in keyof T & keyof AggregateLocales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocales[P]>
      : GetScalarType<T[P], AggregateLocales[P]>
  }




  export type LocalesGroupByArgs = {
    where?: localesWhereInput
    orderBy?: Enumerable<localesOrderByWithAggregationInput>
    by: Array<LocalesScalarFieldEnum>
    having?: localesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalesCountAggregateInputType | true
    _avg?: LocalesAvgAggregateInputType
    _sum?: LocalesSumAggregateInputType
    _min?: LocalesMinAggregateInputType
    _max?: LocalesMaxAggregateInputType
  }


  export type LocalesGroupByOutputType = {
    id: number
    name: string
    code: string
    default: boolean
    _count: LocalesCountAggregateOutputType | null
    _avg: LocalesAvgAggregateOutputType | null
    _sum: LocalesSumAggregateOutputType | null
    _min: LocalesMinAggregateOutputType | null
    _max: LocalesMaxAggregateOutputType | null
  }

  type GetLocalesGroupByPayload<T extends LocalesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LocalesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalesGroupByOutputType[P]>
            : GetScalarType<T[P], LocalesGroupByOutputType[P]>
        }
      >
    >


  export type localesSelect = {
    id?: boolean
    name?: boolean
    code?: boolean
    default?: boolean
    translation?: boolean | translationFindManyArgs
    _count?: boolean | LocalesCountOutputTypeArgs
  }

  export type localesInclude = {
    translation?: boolean | translationFindManyArgs
    _count?: boolean | LocalesCountOutputTypeArgs
  }

  export type localesGetPayload<
    S extends boolean | null | undefined | localesArgs,
    U = keyof S
      > = S extends true
        ? locales
    : S extends undefined
    ? never
    : S extends localesArgs | localesFindManyArgs
    ?'include' extends U
    ? locales  & {
    [P in TrueKeys<S['include']>]:
        P extends 'translation' ? Array < translationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? LocalesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'translation' ? Array < translationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? LocalesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof locales ? locales[P] : never
  } 
    : locales
  : locales


  type localesCountArgs = Merge<
    Omit<localesFindManyArgs, 'select' | 'include'> & {
      select?: LocalesCountAggregateInputType | true
    }
  >

  export interface localesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Locales that matches the filter.
     * @param {localesFindUniqueArgs} args - Arguments to find a Locales
     * @example
     * // Get one Locales
     * const locales = await prisma.locales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends localesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, localesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'locales'> extends True ? CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>> : CheckSelect<T, Prisma__localesClient<locales | null, null>, Prisma__localesClient<localesGetPayload<T> | null, null>>

    /**
     * Find the first Locales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localesFindFirstArgs} args - Arguments to find a Locales
     * @example
     * // Get one Locales
     * const locales = await prisma.locales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends localesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, localesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'locales'> extends True ? CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>> : CheckSelect<T, Prisma__localesClient<locales | null, null>, Prisma__localesClient<localesGetPayload<T> | null, null>>

    /**
     * Find zero or more Locales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locales
     * const locales = await prisma.locales.findMany()
     * 
     * // Get first 10 Locales
     * const locales = await prisma.locales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localesWithIdOnly = await prisma.locales.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends localesFindManyArgs>(
      args?: SelectSubset<T, localesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<locales>>, PrismaPromise<Array<localesGetPayload<T>>>>

    /**
     * Create a Locales.
     * @param {localesCreateArgs} args - Arguments to create a Locales.
     * @example
     * // Create one Locales
     * const Locales = await prisma.locales.create({
     *   data: {
     *     // ... data to create a Locales
     *   }
     * })
     * 
    **/
    create<T extends localesCreateArgs>(
      args: SelectSubset<T, localesCreateArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Create many Locales.
     *     @param {localesCreateManyArgs} args - Arguments to create many Locales.
     *     @example
     *     // Create many Locales
     *     const locales = await prisma.locales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends localesCreateManyArgs>(
      args?: SelectSubset<T, localesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Locales.
     * @param {localesDeleteArgs} args - Arguments to delete one Locales.
     * @example
     * // Delete one Locales
     * const Locales = await prisma.locales.delete({
     *   where: {
     *     // ... filter to delete one Locales
     *   }
     * })
     * 
    **/
    delete<T extends localesDeleteArgs>(
      args: SelectSubset<T, localesDeleteArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Update one Locales.
     * @param {localesUpdateArgs} args - Arguments to update one Locales.
     * @example
     * // Update one Locales
     * const locales = await prisma.locales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends localesUpdateArgs>(
      args: SelectSubset<T, localesUpdateArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Delete zero or more Locales.
     * @param {localesDeleteManyArgs} args - Arguments to filter Locales to delete.
     * @example
     * // Delete a few Locales
     * const { count } = await prisma.locales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends localesDeleteManyArgs>(
      args?: SelectSubset<T, localesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locales
     * const locales = await prisma.locales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends localesUpdateManyArgs>(
      args: SelectSubset<T, localesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Locales.
     * @param {localesUpsertArgs} args - Arguments to update or create a Locales.
     * @example
     * // Update or create a Locales
     * const locales = await prisma.locales.upsert({
     *   create: {
     *     // ... data to create a Locales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locales we want to update
     *   }
     * })
    **/
    upsert<T extends localesUpsertArgs>(
      args: SelectSubset<T, localesUpsertArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Find one Locales that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {localesFindUniqueOrThrowArgs} args - Arguments to find a Locales
     * @example
     * // Get one Locales
     * const locales = await prisma.locales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends localesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, localesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Find the first Locales that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localesFindFirstOrThrowArgs} args - Arguments to find a Locales
     * @example
     * // Get one Locales
     * const locales = await prisma.locales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends localesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, localesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__localesClient<locales>, Prisma__localesClient<localesGetPayload<T>>>

    /**
     * Count the number of Locales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localesCountArgs} args - Arguments to filter Locales to count.
     * @example
     * // Count the number of Locales
     * const count = await prisma.locales.count({
     *   where: {
     *     // ... the filter for the Locales we want to count
     *   }
     * })
    **/
    count<T extends localesCountArgs>(
      args?: Subset<T, localesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalesAggregateArgs>(args: Subset<T, LocalesAggregateArgs>): PrismaPromise<GetLocalesAggregateType<T>>

    /**
     * Group by Locales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalesGroupByArgs['orderBy'] }
        : { orderBy?: LocalesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for locales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__localesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    translation<T extends translationFindManyArgs = {}>(args?: Subset<T, translationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<translation>| Null>, PrismaPromise<Array<translationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * locales base type for findUnique actions
   */
  export type localesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * Filter, which locales to fetch.
     * 
    **/
    where: localesWhereUniqueInput
  }

  /**
   * locales: findUnique
   */
  export interface localesFindUniqueArgs extends localesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locales base type for findFirst actions
   */
  export type localesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * Filter, which locales to fetch.
     * 
    **/
    where?: localesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locales to fetch.
     * 
    **/
    orderBy?: Enumerable<localesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locales.
     * 
    **/
    cursor?: localesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locales.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locales.
     * 
    **/
    distinct?: Enumerable<LocalesScalarFieldEnum>
  }

  /**
   * locales: findFirst
   */
  export interface localesFindFirstArgs extends localesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * locales findMany
   */
  export type localesFindManyArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * Filter, which locales to fetch.
     * 
    **/
    where?: localesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locales to fetch.
     * 
    **/
    orderBy?: Enumerable<localesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locales.
     * 
    **/
    cursor?: localesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locales from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locales.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocalesScalarFieldEnum>
  }


  /**
   * locales create
   */
  export type localesCreateArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * The data needed to create a locales.
     * 
    **/
    data: XOR<localesCreateInput, localesUncheckedCreateInput>
  }


  /**
   * locales createMany
   */
  export type localesCreateManyArgs = {
    /**
     * The data used to create many locales.
     * 
    **/
    data: Enumerable<localesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * locales update
   */
  export type localesUpdateArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * The data needed to update a locales.
     * 
    **/
    data: XOR<localesUpdateInput, localesUncheckedUpdateInput>
    /**
     * Choose, which locales to update.
     * 
    **/
    where: localesWhereUniqueInput
  }


  /**
   * locales updateMany
   */
  export type localesUpdateManyArgs = {
    /**
     * The data used to update locales.
     * 
    **/
    data: XOR<localesUpdateManyMutationInput, localesUncheckedUpdateManyInput>
    /**
     * Filter which locales to update
     * 
    **/
    where?: localesWhereInput
  }


  /**
   * locales upsert
   */
  export type localesUpsertArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * The filter to search for the locales to update in case it exists.
     * 
    **/
    where: localesWhereUniqueInput
    /**
     * In case the locales found by the `where` argument doesn't exist, create a new locales with this data.
     * 
    **/
    create: XOR<localesCreateInput, localesUncheckedCreateInput>
    /**
     * In case the locales was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<localesUpdateInput, localesUncheckedUpdateInput>
  }


  /**
   * locales delete
   */
  export type localesDeleteArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
    /**
     * Filter which locales to delete.
     * 
    **/
    where: localesWhereUniqueInput
  }


  /**
   * locales deleteMany
   */
  export type localesDeleteManyArgs = {
    /**
     * Filter which locales to delete
     * 
    **/
    where?: localesWhereInput
  }


  /**
   * locales: findUniqueOrThrow
   */
  export type localesFindUniqueOrThrowArgs = localesFindUniqueArgsBase
      

  /**
   * locales: findFirstOrThrow
   */
  export type localesFindFirstOrThrowArgs = localesFindFirstArgsBase
      

  /**
   * locales without action
   */
  export type localesArgs = {
    /**
     * Select specific fields to fetch from the locales
     * 
    **/
    select?: localesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: localesInclude | null
  }



  /**
   * Model location
   */


  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    city_code: string | null
    vendor_id: string | null
    oag_code: string | null
    country_code: string | null
    state: string | null
    zip_code: string | null
    phone: string | null
    alt_phone: string | null
    fax: string | null
    telex: string | null
    web_url: string | null
    email: string | null
    latitude: string | null
    longitude: string | null
    open_1_mon: string | null
    close_1_mon: string | null
    open_2_mon: string | null
    close_2_mon: string | null
    open_3_mon: string | null
    close_3_mon: string | null
    open_1_tue: string | null
    close_1_tue: string | null
    open_2_tue: string | null
    close_2_tue: string | null
    open_3_tue: string | null
    close_3_tue: string | null
    open_1_wed: string | null
    close_1_wed: string | null
    open_2_wed: string | null
    close_2_wed: string | null
    open_3_wed: string | null
    close_3_wed: string | null
    open_1_thu: string | null
    close_1_thu: string | null
    open_2_thu: string | null
    close_2_thu: string | null
    open_3_thu: string | null
    close_3_thu: string | null
    open_1_fri: string | null
    close_1_fri: string | null
    open_2_fri: string | null
    close_2_fri: string | null
    open_3_fri: string | null
    close_3_fri: string | null
    open_1_sat: string | null
    close_1_sat: string | null
    open_2_sat: string | null
    close_2_sat: string | null
    open_3_sat: string | null
    close_3_sat: string | null
    open_1_sun: string | null
    close_1_sun: string | null
    open_2_sun: string | null
    close_2_sun: string | null
    open_3_sun: string | null
    close_3_sun: string | null
    loc_type_1: string | null
    loc_type_2: string | null
    city_name: string | null
    category_id: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    city_code: string | null
    vendor_id: string | null
    oag_code: string | null
    country_code: string | null
    state: string | null
    zip_code: string | null
    phone: string | null
    alt_phone: string | null
    fax: string | null
    telex: string | null
    web_url: string | null
    email: string | null
    latitude: string | null
    longitude: string | null
    open_1_mon: string | null
    close_1_mon: string | null
    open_2_mon: string | null
    close_2_mon: string | null
    open_3_mon: string | null
    close_3_mon: string | null
    open_1_tue: string | null
    close_1_tue: string | null
    open_2_tue: string | null
    close_2_tue: string | null
    open_3_tue: string | null
    close_3_tue: string | null
    open_1_wed: string | null
    close_1_wed: string | null
    open_2_wed: string | null
    close_2_wed: string | null
    open_3_wed: string | null
    close_3_wed: string | null
    open_1_thu: string | null
    close_1_thu: string | null
    open_2_thu: string | null
    close_2_thu: string | null
    open_3_thu: string | null
    close_3_thu: string | null
    open_1_fri: string | null
    close_1_fri: string | null
    open_2_fri: string | null
    close_2_fri: string | null
    open_3_fri: string | null
    close_3_fri: string | null
    open_1_sat: string | null
    close_1_sat: string | null
    open_2_sat: string | null
    close_2_sat: string | null
    open_3_sat: string | null
    close_3_sat: string | null
    open_1_sun: string | null
    close_1_sun: string | null
    open_2_sun: string | null
    close_2_sun: string | null
    open_3_sun: string | null
    close_3_sun: string | null
    loc_type_1: string | null
    loc_type_2: string | null
    city_name: string | null
    category_id: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    city_code: number
    vendor_id: number
    oag_code: number
    country_code: number
    state: number
    zip_code: number
    phone: number
    alt_phone: number
    fax: number
    telex: number
    web_url: number
    email: number
    latitude: number
    longitude: number
    open_1_mon: number
    close_1_mon: number
    open_2_mon: number
    close_2_mon: number
    open_3_mon: number
    close_3_mon: number
    open_1_tue: number
    close_1_tue: number
    open_2_tue: number
    close_2_tue: number
    open_3_tue: number
    close_3_tue: number
    open_1_wed: number
    close_1_wed: number
    open_2_wed: number
    close_2_wed: number
    open_3_wed: number
    close_3_wed: number
    open_1_thu: number
    close_1_thu: number
    open_2_thu: number
    close_2_thu: number
    open_3_thu: number
    close_3_thu: number
    open_1_fri: number
    close_1_fri: number
    open_2_fri: number
    close_2_fri: number
    open_3_fri: number
    close_3_fri: number
    open_1_sat: number
    close_1_sat: number
    open_2_sat: number
    close_2_sat: number
    open_3_sat: number
    close_3_sat: number
    open_1_sun: number
    close_1_sun: number
    open_2_sun: number
    close_2_sun: number
    open_3_sun: number
    close_3_sun: number
    loc_type_1: number
    loc_type_2: number
    city_name: number
    category_id: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    city_code?: true
    vendor_id?: true
    oag_code?: true
    country_code?: true
    state?: true
    zip_code?: true
    phone?: true
    alt_phone?: true
    fax?: true
    telex?: true
    web_url?: true
    email?: true
    latitude?: true
    longitude?: true
    open_1_mon?: true
    close_1_mon?: true
    open_2_mon?: true
    close_2_mon?: true
    open_3_mon?: true
    close_3_mon?: true
    open_1_tue?: true
    close_1_tue?: true
    open_2_tue?: true
    close_2_tue?: true
    open_3_tue?: true
    close_3_tue?: true
    open_1_wed?: true
    close_1_wed?: true
    open_2_wed?: true
    close_2_wed?: true
    open_3_wed?: true
    close_3_wed?: true
    open_1_thu?: true
    close_1_thu?: true
    open_2_thu?: true
    close_2_thu?: true
    open_3_thu?: true
    close_3_thu?: true
    open_1_fri?: true
    close_1_fri?: true
    open_2_fri?: true
    close_2_fri?: true
    open_3_fri?: true
    close_3_fri?: true
    open_1_sat?: true
    close_1_sat?: true
    open_2_sat?: true
    close_2_sat?: true
    open_3_sat?: true
    close_3_sat?: true
    open_1_sun?: true
    close_1_sun?: true
    open_2_sun?: true
    close_2_sun?: true
    open_3_sun?: true
    close_3_sun?: true
    loc_type_1?: true
    loc_type_2?: true
    city_name?: true
    category_id?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    city_code?: true
    vendor_id?: true
    oag_code?: true
    country_code?: true
    state?: true
    zip_code?: true
    phone?: true
    alt_phone?: true
    fax?: true
    telex?: true
    web_url?: true
    email?: true
    latitude?: true
    longitude?: true
    open_1_mon?: true
    close_1_mon?: true
    open_2_mon?: true
    close_2_mon?: true
    open_3_mon?: true
    close_3_mon?: true
    open_1_tue?: true
    close_1_tue?: true
    open_2_tue?: true
    close_2_tue?: true
    open_3_tue?: true
    close_3_tue?: true
    open_1_wed?: true
    close_1_wed?: true
    open_2_wed?: true
    close_2_wed?: true
    open_3_wed?: true
    close_3_wed?: true
    open_1_thu?: true
    close_1_thu?: true
    open_2_thu?: true
    close_2_thu?: true
    open_3_thu?: true
    close_3_thu?: true
    open_1_fri?: true
    close_1_fri?: true
    open_2_fri?: true
    close_2_fri?: true
    open_3_fri?: true
    close_3_fri?: true
    open_1_sat?: true
    close_1_sat?: true
    open_2_sat?: true
    close_2_sat?: true
    open_3_sat?: true
    close_3_sat?: true
    open_1_sun?: true
    close_1_sun?: true
    open_2_sun?: true
    close_2_sun?: true
    open_3_sun?: true
    close_3_sun?: true
    loc_type_1?: true
    loc_type_2?: true
    city_name?: true
    category_id?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    city_code?: true
    vendor_id?: true
    oag_code?: true
    country_code?: true
    state?: true
    zip_code?: true
    phone?: true
    alt_phone?: true
    fax?: true
    telex?: true
    web_url?: true
    email?: true
    latitude?: true
    longitude?: true
    open_1_mon?: true
    close_1_mon?: true
    open_2_mon?: true
    close_2_mon?: true
    open_3_mon?: true
    close_3_mon?: true
    open_1_tue?: true
    close_1_tue?: true
    open_2_tue?: true
    close_2_tue?: true
    open_3_tue?: true
    close_3_tue?: true
    open_1_wed?: true
    close_1_wed?: true
    open_2_wed?: true
    close_2_wed?: true
    open_3_wed?: true
    close_3_wed?: true
    open_1_thu?: true
    close_1_thu?: true
    open_2_thu?: true
    close_2_thu?: true
    open_3_thu?: true
    close_3_thu?: true
    open_1_fri?: true
    close_1_fri?: true
    open_2_fri?: true
    close_2_fri?: true
    open_3_fri?: true
    close_3_fri?: true
    open_1_sat?: true
    close_1_sat?: true
    open_2_sat?: true
    close_2_sat?: true
    open_3_sat?: true
    close_3_sat?: true
    open_1_sun?: true
    close_1_sun?: true
    open_2_sun?: true
    close_2_sun?: true
    open_3_sun?: true
    close_3_sun?: true
    loc_type_1?: true
    loc_type_2?: true
    city_name?: true
    category_id?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which location to aggregate.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs = {
    where?: locationWhereInput
    orderBy?: Enumerable<locationOrderByWithAggregationInput>
    by: Array<LocationScalarFieldEnum>
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    id: string
    city_code: string | null
    vendor_id: string
    oag_code: string | null
    country_code: string | null
    state: string | null
    zip_code: string | null
    phone: string | null
    alt_phone: string | null
    fax: string | null
    telex: string | null
    web_url: string | null
    email: string | null
    latitude: string | null
    longitude: string | null
    open_1_mon: string | null
    close_1_mon: string | null
    open_2_mon: string | null
    close_2_mon: string | null
    open_3_mon: string | null
    close_3_mon: string | null
    open_1_tue: string | null
    close_1_tue: string | null
    open_2_tue: string | null
    close_2_tue: string | null
    open_3_tue: string | null
    close_3_tue: string | null
    open_1_wed: string | null
    close_1_wed: string | null
    open_2_wed: string | null
    close_2_wed: string | null
    open_3_wed: string | null
    close_3_wed: string | null
    open_1_thu: string | null
    close_1_thu: string | null
    open_2_thu: string | null
    close_2_thu: string | null
    open_3_thu: string | null
    close_3_thu: string | null
    open_1_fri: string | null
    close_1_fri: string | null
    open_2_fri: string | null
    close_2_fri: string | null
    open_3_fri: string | null
    close_3_fri: string | null
    open_1_sat: string | null
    close_1_sat: string | null
    open_2_sat: string | null
    close_2_sat: string | null
    open_3_sat: string | null
    close_3_sat: string | null
    open_1_sun: string | null
    close_1_sun: string | null
    open_2_sun: string | null
    close_2_sun: string | null
    open_3_sun: string | null
    close_3_sun: string | null
    loc_type_1: string | null
    loc_type_2: string | null
    city_name: string | null
    category_id: string | null
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect = {
    id?: boolean
    city_code?: boolean
    vendor_id?: boolean
    oag_code?: boolean
    country_code?: boolean
    state?: boolean
    zip_code?: boolean
    phone?: boolean
    alt_phone?: boolean
    fax?: boolean
    telex?: boolean
    web_url?: boolean
    email?: boolean
    latitude?: boolean
    longitude?: boolean
    open_1_mon?: boolean
    close_1_mon?: boolean
    open_2_mon?: boolean
    close_2_mon?: boolean
    open_3_mon?: boolean
    close_3_mon?: boolean
    open_1_tue?: boolean
    close_1_tue?: boolean
    open_2_tue?: boolean
    close_2_tue?: boolean
    open_3_tue?: boolean
    close_3_tue?: boolean
    open_1_wed?: boolean
    close_1_wed?: boolean
    open_2_wed?: boolean
    close_2_wed?: boolean
    open_3_wed?: boolean
    close_3_wed?: boolean
    open_1_thu?: boolean
    close_1_thu?: boolean
    open_2_thu?: boolean
    close_2_thu?: boolean
    open_3_thu?: boolean
    close_3_thu?: boolean
    open_1_fri?: boolean
    close_1_fri?: boolean
    open_2_fri?: boolean
    close_2_fri?: boolean
    open_3_fri?: boolean
    close_3_fri?: boolean
    open_1_sat?: boolean
    close_1_sat?: boolean
    open_2_sat?: boolean
    close_2_sat?: boolean
    open_3_sat?: boolean
    close_3_sat?: boolean
    open_1_sun?: boolean
    close_1_sun?: boolean
    open_2_sun?: boolean
    close_2_sun?: boolean
    open_3_sun?: boolean
    close_3_sun?: boolean
    loc_type_1?: boolean
    loc_type_2?: boolean
    city_name?: boolean
    category_id?: boolean
    categories?: boolean | categoriesArgs
    location_type_1?: boolean | location_type_1Args
    location_type_2?: boolean | location_type_2Args
    vendors?: boolean | vendorsArgs
    location_description?: boolean | location_descriptionFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationInclude = {
    categories?: boolean | categoriesArgs
    location_type_1?: boolean | location_type_1Args
    location_type_2?: boolean | location_type_2Args
    vendors?: boolean | vendorsArgs
    location_description?: boolean | location_descriptionFindManyArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationGetPayload<
    S extends boolean | null | undefined | locationArgs,
    U = keyof S
      > = S extends true
        ? location
    : S extends undefined
    ? never
    : S extends locationArgs | locationFindManyArgs
    ?'include' extends U
    ? location  & {
    [P in TrueKeys<S['include']>]:
        P extends 'categories' ? categoriesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'location_type_1' ? location_type_1GetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'location_type_2' ? location_type_2GetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'location_description' ? Array < location_descriptionGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'categories' ? categoriesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'location_type_1' ? location_type_1GetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'location_type_2' ? location_type_2GetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'location_description' ? Array < location_descriptionGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? LocationCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof location ? location[P] : never
  } 
    : location
  : location


  type locationCountArgs = Merge<
    Omit<locationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface locationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null, null>, Prisma__locationClient<locationGetPayload<T> | null, null>>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null, null>, Prisma__locationClient<locationGetPayload<T> | null, null>>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationFindManyArgs>(
      args?: SelectSubset<T, locationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location>>, PrismaPromise<Array<locationGetPayload<T>>>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends locationCreateArgs>(
      args: SelectSubset<T, locationCreateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Create many Locations.
     *     @param {locationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationCreateManyArgs>(
      args?: SelectSubset<T, locationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends locationDeleteArgs>(
      args: SelectSubset<T, locationDeleteArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationUpdateArgs>(
      args: SelectSubset<T, locationUpdateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationDeleteManyArgs>(
      args?: SelectSubset<T, locationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationUpdateManyArgs>(
      args: SelectSubset<T, locationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends locationUpsertArgs>(
      args: SelectSubset<T, locationUpsertArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Find one Location that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, locationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Find the first Location that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, locationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    categories<T extends categoriesArgs = {}>(args?: Subset<T, categoriesArgs>): CheckSelect<T, Prisma__categoriesClient<categories | Null>, Prisma__categoriesClient<categoriesGetPayload<T> | Null>>;

    location_type_1<T extends location_type_1Args = {}>(args?: Subset<T, location_type_1Args>): CheckSelect<T, Prisma__location_type_1Client<location_type_1 | Null>, Prisma__location_type_1Client<location_type_1GetPayload<T> | Null>>;

    location_type_2<T extends location_type_2Args = {}>(args?: Subset<T, location_type_2Args>): CheckSelect<T, Prisma__location_type_2Client<location_type_2 | Null>, Prisma__location_type_2Client<location_type_2GetPayload<T> | Null>>;

    vendors<T extends vendorsArgs = {}>(args?: Subset<T, vendorsArgs>): CheckSelect<T, Prisma__vendorsClient<vendors | Null>, Prisma__vendorsClient<vendorsGetPayload<T> | Null>>;

    location_description<T extends location_descriptionFindManyArgs = {}>(args?: Subset<T, location_descriptionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location_description>| Null>, PrismaPromise<Array<location_descriptionGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location base type for findUnique actions
   */
  export type locationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     * 
    **/
    where: locationWhereUniqueInput
  }

  /**
   * location: findUnique
   */
  export interface locationFindUniqueArgs extends locationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location base type for findFirst actions
   */
  export type locationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     * 
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }

  /**
   * location: findFirst
   */
  export interface locationFindFirstArgs extends locationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location findMany
   */
  export type locationFindManyArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter, which locations to fetch.
     * 
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     * 
    **/
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     * 
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location create
   */
  export type locationCreateArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The data needed to create a location.
     * 
    **/
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }


  /**
   * location createMany
   */
  export type locationCreateManyArgs = {
    /**
     * The data used to create many locations.
     * 
    **/
    data: Enumerable<locationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location update
   */
  export type locationUpdateArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The data needed to update a location.
     * 
    **/
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location updateMany
   */
  export type locationUpdateManyArgs = {
    /**
     * The data used to update locations.
     * 
    **/
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location upsert
   */
  export type locationUpsertArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * The filter to search for the location to update in case it exists.
     * 
    **/
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     * 
    **/
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }


  /**
   * location delete
   */
  export type locationDeleteArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
    /**
     * Filter which location to delete.
     * 
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs = {
    /**
     * Filter which locations to delete
     * 
    **/
    where?: locationWhereInput
  }


  /**
   * location: findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs = locationFindUniqueArgsBase
      

  /**
   * location: findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs = locationFindFirstArgsBase
      

  /**
   * location without action
   */
  export type locationArgs = {
    /**
     * Select specific fields to fetch from the location
     * 
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: locationInclude | null
  }



  /**
   * Model location_description
   */


  export type AggregateLocation_description = {
    _count: Location_descriptionCountAggregateOutputType | null
    _min: Location_descriptionMinAggregateOutputType | null
    _max: Location_descriptionMaxAggregateOutputType | null
  }

  export type Location_descriptionMinAggregateOutputType = {
    location_id: string | null
    locale: string | null
    description: string | null
    address_1: string | null
    address_2: string | null
    address_3: string | null
  }

  export type Location_descriptionMaxAggregateOutputType = {
    location_id: string | null
    locale: string | null
    description: string | null
    address_1: string | null
    address_2: string | null
    address_3: string | null
  }

  export type Location_descriptionCountAggregateOutputType = {
    location_id: number
    locale: number
    description: number
    address_1: number
    address_2: number
    address_3: number
    _all: number
  }


  export type Location_descriptionMinAggregateInputType = {
    location_id?: true
    locale?: true
    description?: true
    address_1?: true
    address_2?: true
    address_3?: true
  }

  export type Location_descriptionMaxAggregateInputType = {
    location_id?: true
    locale?: true
    description?: true
    address_1?: true
    address_2?: true
    address_3?: true
  }

  export type Location_descriptionCountAggregateInputType = {
    location_id?: true
    locale?: true
    description?: true
    address_1?: true
    address_2?: true
    address_3?: true
    _all?: true
  }

  export type Location_descriptionAggregateArgs = {
    /**
     * Filter which location_description to aggregate.
     * 
    **/
    where?: location_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<location_descriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: location_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_descriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_descriptions
    **/
    _count?: true | Location_descriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_descriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_descriptionMaxAggregateInputType
  }

  export type GetLocation_descriptionAggregateType<T extends Location_descriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_description]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_description[P]>
      : GetScalarType<T[P], AggregateLocation_description[P]>
  }




  export type Location_descriptionGroupByArgs = {
    where?: location_descriptionWhereInput
    orderBy?: Enumerable<location_descriptionOrderByWithAggregationInput>
    by: Array<Location_descriptionScalarFieldEnum>
    having?: location_descriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_descriptionCountAggregateInputType | true
    _min?: Location_descriptionMinAggregateInputType
    _max?: Location_descriptionMaxAggregateInputType
  }


  export type Location_descriptionGroupByOutputType = {
    location_id: string
    locale: string
    description: string | null
    address_1: string | null
    address_2: string | null
    address_3: string | null
    _count: Location_descriptionCountAggregateOutputType | null
    _min: Location_descriptionMinAggregateOutputType | null
    _max: Location_descriptionMaxAggregateOutputType | null
  }

  type GetLocation_descriptionGroupByPayload<T extends Location_descriptionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Location_descriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_descriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_descriptionGroupByOutputType[P]>
            : GetScalarType<T[P], Location_descriptionGroupByOutputType[P]>
        }
      >
    >


  export type location_descriptionSelect = {
    location_id?: boolean
    locale?: boolean
    description?: boolean
    address_1?: boolean
    address_2?: boolean
    address_3?: boolean
    location?: boolean | locationArgs
  }

  export type location_descriptionInclude = {
    location?: boolean | locationArgs
  }

  export type location_descriptionGetPayload<
    S extends boolean | null | undefined | location_descriptionArgs,
    U = keyof S
      > = S extends true
        ? location_description
    : S extends undefined
    ? never
    : S extends location_descriptionArgs | location_descriptionFindManyArgs
    ?'include' extends U
    ? location_description  & {
    [P in TrueKeys<S['include']>]:
        P extends 'location' ? locationGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'location' ? locationGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof location_description ? location_description[P] : never
  } 
    : location_description
  : location_description


  type location_descriptionCountArgs = Merge<
    Omit<location_descriptionFindManyArgs, 'select' | 'include'> & {
      select?: Location_descriptionCountAggregateInputType | true
    }
  >

  export interface location_descriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Location_description that matches the filter.
     * @param {location_descriptionFindUniqueArgs} args - Arguments to find a Location_description
     * @example
     * // Get one Location_description
     * const location_description = await prisma.location_description.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends location_descriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, location_descriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location_description'> extends True ? CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>> : CheckSelect<T, Prisma__location_descriptionClient<location_description | null, null>, Prisma__location_descriptionClient<location_descriptionGetPayload<T> | null, null>>

    /**
     * Find the first Location_description that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_descriptionFindFirstArgs} args - Arguments to find a Location_description
     * @example
     * // Get one Location_description
     * const location_description = await prisma.location_description.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends location_descriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, location_descriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location_description'> extends True ? CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>> : CheckSelect<T, Prisma__location_descriptionClient<location_description | null, null>, Prisma__location_descriptionClient<location_descriptionGetPayload<T> | null, null>>

    /**
     * Find zero or more Location_descriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_descriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_descriptions
     * const location_descriptions = await prisma.location_description.findMany()
     * 
     * // Get first 10 Location_descriptions
     * const location_descriptions = await prisma.location_description.findMany({ take: 10 })
     * 
     * // Only select the `location_id`
     * const location_descriptionWithLocation_idOnly = await prisma.location_description.findMany({ select: { location_id: true } })
     * 
    **/
    findMany<T extends location_descriptionFindManyArgs>(
      args?: SelectSubset<T, location_descriptionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location_description>>, PrismaPromise<Array<location_descriptionGetPayload<T>>>>

    /**
     * Create a Location_description.
     * @param {location_descriptionCreateArgs} args - Arguments to create a Location_description.
     * @example
     * // Create one Location_description
     * const Location_description = await prisma.location_description.create({
     *   data: {
     *     // ... data to create a Location_description
     *   }
     * })
     * 
    **/
    create<T extends location_descriptionCreateArgs>(
      args: SelectSubset<T, location_descriptionCreateArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Create many Location_descriptions.
     *     @param {location_descriptionCreateManyArgs} args - Arguments to create many Location_descriptions.
     *     @example
     *     // Create many Location_descriptions
     *     const location_description = await prisma.location_description.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends location_descriptionCreateManyArgs>(
      args?: SelectSubset<T, location_descriptionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location_description.
     * @param {location_descriptionDeleteArgs} args - Arguments to delete one Location_description.
     * @example
     * // Delete one Location_description
     * const Location_description = await prisma.location_description.delete({
     *   where: {
     *     // ... filter to delete one Location_description
     *   }
     * })
     * 
    **/
    delete<T extends location_descriptionDeleteArgs>(
      args: SelectSubset<T, location_descriptionDeleteArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Update one Location_description.
     * @param {location_descriptionUpdateArgs} args - Arguments to update one Location_description.
     * @example
     * // Update one Location_description
     * const location_description = await prisma.location_description.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends location_descriptionUpdateArgs>(
      args: SelectSubset<T, location_descriptionUpdateArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Delete zero or more Location_descriptions.
     * @param {location_descriptionDeleteManyArgs} args - Arguments to filter Location_descriptions to delete.
     * @example
     * // Delete a few Location_descriptions
     * const { count } = await prisma.location_description.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends location_descriptionDeleteManyArgs>(
      args?: SelectSubset<T, location_descriptionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_descriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_descriptions
     * const location_description = await prisma.location_description.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends location_descriptionUpdateManyArgs>(
      args: SelectSubset<T, location_descriptionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_description.
     * @param {location_descriptionUpsertArgs} args - Arguments to update or create a Location_description.
     * @example
     * // Update or create a Location_description
     * const location_description = await prisma.location_description.upsert({
     *   create: {
     *     // ... data to create a Location_description
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_description we want to update
     *   }
     * })
    **/
    upsert<T extends location_descriptionUpsertArgs>(
      args: SelectSubset<T, location_descriptionUpsertArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Find one Location_description that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {location_descriptionFindUniqueOrThrowArgs} args - Arguments to find a Location_description
     * @example
     * // Get one Location_description
     * const location_description = await prisma.location_description.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends location_descriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, location_descriptionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Find the first Location_description that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_descriptionFindFirstOrThrowArgs} args - Arguments to find a Location_description
     * @example
     * // Get one Location_description
     * const location_description = await prisma.location_description.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends location_descriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, location_descriptionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__location_descriptionClient<location_description>, Prisma__location_descriptionClient<location_descriptionGetPayload<T>>>

    /**
     * Count the number of Location_descriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_descriptionCountArgs} args - Arguments to filter Location_descriptions to count.
     * @example
     * // Count the number of Location_descriptions
     * const count = await prisma.location_description.count({
     *   where: {
     *     // ... the filter for the Location_descriptions we want to count
     *   }
     * })
    **/
    count<T extends location_descriptionCountArgs>(
      args?: Subset<T, location_descriptionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_descriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_descriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_descriptionAggregateArgs>(args: Subset<T, Location_descriptionAggregateArgs>): PrismaPromise<GetLocation_descriptionAggregateType<T>>

    /**
     * Group by Location_description.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_descriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Location_descriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Location_descriptionGroupByArgs['orderBy'] }
        : { orderBy?: Location_descriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Location_descriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_descriptionGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location_description.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__location_descriptionClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    location<T extends locationArgs = {}>(args?: Subset<T, locationArgs>): CheckSelect<T, Prisma__locationClient<location | Null>, Prisma__locationClient<locationGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location_description base type for findUnique actions
   */
  export type location_descriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * Filter, which location_description to fetch.
     * 
    **/
    where: location_descriptionWhereUniqueInput
  }

  /**
   * location_description: findUnique
   */
  export interface location_descriptionFindUniqueArgs extends location_descriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_description base type for findFirst actions
   */
  export type location_descriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * Filter, which location_description to fetch.
     * 
    **/
    where?: location_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<location_descriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_descriptions.
     * 
    **/
    cursor?: location_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_descriptions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_descriptions.
     * 
    **/
    distinct?: Enumerable<Location_descriptionScalarFieldEnum>
  }

  /**
   * location_description: findFirst
   */
  export interface location_descriptionFindFirstArgs extends location_descriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_description findMany
   */
  export type location_descriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * Filter, which location_descriptions to fetch.
     * 
    **/
    where?: location_descriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_descriptions to fetch.
     * 
    **/
    orderBy?: Enumerable<location_descriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_descriptions.
     * 
    **/
    cursor?: location_descriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_descriptions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_descriptions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Location_descriptionScalarFieldEnum>
  }


  /**
   * location_description create
   */
  export type location_descriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * The data needed to create a location_description.
     * 
    **/
    data: XOR<location_descriptionCreateInput, location_descriptionUncheckedCreateInput>
  }


  /**
   * location_description createMany
   */
  export type location_descriptionCreateManyArgs = {
    /**
     * The data used to create many location_descriptions.
     * 
    **/
    data: Enumerable<location_descriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location_description update
   */
  export type location_descriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * The data needed to update a location_description.
     * 
    **/
    data: XOR<location_descriptionUpdateInput, location_descriptionUncheckedUpdateInput>
    /**
     * Choose, which location_description to update.
     * 
    **/
    where: location_descriptionWhereUniqueInput
  }


  /**
   * location_description updateMany
   */
  export type location_descriptionUpdateManyArgs = {
    /**
     * The data used to update location_descriptions.
     * 
    **/
    data: XOR<location_descriptionUpdateManyMutationInput, location_descriptionUncheckedUpdateManyInput>
    /**
     * Filter which location_descriptions to update
     * 
    **/
    where?: location_descriptionWhereInput
  }


  /**
   * location_description upsert
   */
  export type location_descriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * The filter to search for the location_description to update in case it exists.
     * 
    **/
    where: location_descriptionWhereUniqueInput
    /**
     * In case the location_description found by the `where` argument doesn't exist, create a new location_description with this data.
     * 
    **/
    create: XOR<location_descriptionCreateInput, location_descriptionUncheckedCreateInput>
    /**
     * In case the location_description was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<location_descriptionUpdateInput, location_descriptionUncheckedUpdateInput>
  }


  /**
   * location_description delete
   */
  export type location_descriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
    /**
     * Filter which location_description to delete.
     * 
    **/
    where: location_descriptionWhereUniqueInput
  }


  /**
   * location_description deleteMany
   */
  export type location_descriptionDeleteManyArgs = {
    /**
     * Filter which location_descriptions to delete
     * 
    **/
    where?: location_descriptionWhereInput
  }


  /**
   * location_description: findUniqueOrThrow
   */
  export type location_descriptionFindUniqueOrThrowArgs = location_descriptionFindUniqueArgsBase
      

  /**
   * location_description: findFirstOrThrow
   */
  export type location_descriptionFindFirstOrThrowArgs = location_descriptionFindFirstArgsBase
      

  /**
   * location_description without action
   */
  export type location_descriptionArgs = {
    /**
     * Select specific fields to fetch from the location_description
     * 
    **/
    select?: location_descriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_descriptionInclude | null
  }



  /**
   * Model translation
   */


  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationAvgAggregateOutputType = {
    locale_id: number | null
  }

  export type TranslationSumAggregateOutputType = {
    locale_id: number | null
  }

  export type TranslationMinAggregateOutputType = {
    locale_id: number | null
    message: string | null
    tag: string | null
  }

  export type TranslationMaxAggregateOutputType = {
    locale_id: number | null
    message: string | null
    tag: string | null
  }

  export type TranslationCountAggregateOutputType = {
    locale_id: number
    message: number
    tag: number
    _all: number
  }


  export type TranslationAvgAggregateInputType = {
    locale_id?: true
  }

  export type TranslationSumAggregateInputType = {
    locale_id?: true
  }

  export type TranslationMinAggregateInputType = {
    locale_id?: true
    message?: true
    tag?: true
  }

  export type TranslationMaxAggregateInputType = {
    locale_id?: true
    message?: true
    tag?: true
  }

  export type TranslationCountAggregateInputType = {
    locale_id?: true
    message?: true
    tag?: true
    _all?: true
  }

  export type TranslationAggregateArgs = {
    /**
     * Filter which translation to aggregate.
     * 
    **/
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     * 
    **/
    orderBy?: Enumerable<translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs = {
    where?: translationWhereInput
    orderBy?: Enumerable<translationOrderByWithAggregationInput>
    by: Array<TranslationScalarFieldEnum>
    having?: translationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _avg?: TranslationAvgAggregateInputType
    _sum?: TranslationSumAggregateInputType
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }


  export type TranslationGroupByOutputType = {
    locale_id: number
    message: string
    tag: string
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type translationSelect = {
    locale_id?: boolean
    message?: boolean
    tag?: boolean
    locales?: boolean | localesArgs
  }

  export type translationInclude = {
    locales?: boolean | localesArgs
  }

  export type translationGetPayload<
    S extends boolean | null | undefined | translationArgs,
    U = keyof S
      > = S extends true
        ? translation
    : S extends undefined
    ? never
    : S extends translationArgs | translationFindManyArgs
    ?'include' extends U
    ? translation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'locales' ? localesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'locales' ? localesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof translation ? translation[P] : never
  } 
    : translation
  : translation


  type translationCountArgs = Merge<
    Omit<translationFindManyArgs, 'select' | 'include'> & {
      select?: TranslationCountAggregateInputType | true
    }
  >

  export interface translationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Translation that matches the filter.
     * @param {translationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends translationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, translationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'translation'> extends True ? CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>> : CheckSelect<T, Prisma__translationClient<translation | null, null>, Prisma__translationClient<translationGetPayload<T> | null, null>>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends translationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, translationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'translation'> extends True ? CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>> : CheckSelect<T, Prisma__translationClient<translation | null, null>, Prisma__translationClient<translationGetPayload<T> | null, null>>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `locale_id`
     * const translationWithLocale_idOnly = await prisma.translation.findMany({ select: { locale_id: true } })
     * 
    **/
    findMany<T extends translationFindManyArgs>(
      args?: SelectSubset<T, translationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<translation>>, PrismaPromise<Array<translationGetPayload<T>>>>

    /**
     * Create a Translation.
     * @param {translationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
    **/
    create<T extends translationCreateArgs>(
      args: SelectSubset<T, translationCreateArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Create many Translations.
     *     @param {translationCreateManyArgs} args - Arguments to create many Translations.
     *     @example
     *     // Create many Translations
     *     const translation = await prisma.translation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends translationCreateManyArgs>(
      args?: SelectSubset<T, translationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Translation.
     * @param {translationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
    **/
    delete<T extends translationDeleteArgs>(
      args: SelectSubset<T, translationDeleteArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Update one Translation.
     * @param {translationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends translationUpdateArgs>(
      args: SelectSubset<T, translationUpdateArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Delete zero or more Translations.
     * @param {translationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends translationDeleteManyArgs>(
      args?: SelectSubset<T, translationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends translationUpdateManyArgs>(
      args: SelectSubset<T, translationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {translationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
    **/
    upsert<T extends translationUpsertArgs>(
      args: SelectSubset<T, translationUpsertArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Find one Translation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {translationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends translationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, translationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Find the first Translation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends translationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, translationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__translationClient<translation>, Prisma__translationClient<translationGetPayload<T>>>

    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {translationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends translationCountArgs>(
      args?: Subset<T, translationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__translationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    locales<T extends localesArgs = {}>(args?: Subset<T, localesArgs>): CheckSelect<T, Prisma__localesClient<locales | Null>, Prisma__localesClient<localesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * translation base type for findUnique actions
   */
  export type translationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * Filter, which translation to fetch.
     * 
    **/
    where: translationWhereUniqueInput
  }

  /**
   * translation: findUnique
   */
  export interface translationFindUniqueArgs extends translationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * translation base type for findFirst actions
   */
  export type translationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * Filter, which translation to fetch.
     * 
    **/
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     * 
    **/
    orderBy?: Enumerable<translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for translations.
     * 
    **/
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of translations.
     * 
    **/
    distinct?: Enumerable<TranslationScalarFieldEnum>
  }

  /**
   * translation: findFirst
   */
  export interface translationFindFirstArgs extends translationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * translation findMany
   */
  export type translationFindManyArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * Filter, which translations to fetch.
     * 
    **/
    where?: translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of translations to fetch.
     * 
    **/
    orderBy?: Enumerable<translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing translations.
     * 
    **/
    cursor?: translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` translations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TranslationScalarFieldEnum>
  }


  /**
   * translation create
   */
  export type translationCreateArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * The data needed to create a translation.
     * 
    **/
    data: XOR<translationCreateInput, translationUncheckedCreateInput>
  }


  /**
   * translation createMany
   */
  export type translationCreateManyArgs = {
    /**
     * The data used to create many translations.
     * 
    **/
    data: Enumerable<translationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * translation update
   */
  export type translationUpdateArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * The data needed to update a translation.
     * 
    **/
    data: XOR<translationUpdateInput, translationUncheckedUpdateInput>
    /**
     * Choose, which translation to update.
     * 
    **/
    where: translationWhereUniqueInput
  }


  /**
   * translation updateMany
   */
  export type translationUpdateManyArgs = {
    /**
     * The data used to update translations.
     * 
    **/
    data: XOR<translationUpdateManyMutationInput, translationUncheckedUpdateManyInput>
    /**
     * Filter which translations to update
     * 
    **/
    where?: translationWhereInput
  }


  /**
   * translation upsert
   */
  export type translationUpsertArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * The filter to search for the translation to update in case it exists.
     * 
    **/
    where: translationWhereUniqueInput
    /**
     * In case the translation found by the `where` argument doesn't exist, create a new translation with this data.
     * 
    **/
    create: XOR<translationCreateInput, translationUncheckedCreateInput>
    /**
     * In case the translation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<translationUpdateInput, translationUncheckedUpdateInput>
  }


  /**
   * translation delete
   */
  export type translationDeleteArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
    /**
     * Filter which translation to delete.
     * 
    **/
    where: translationWhereUniqueInput
  }


  /**
   * translation deleteMany
   */
  export type translationDeleteManyArgs = {
    /**
     * Filter which translations to delete
     * 
    **/
    where?: translationWhereInput
  }


  /**
   * translation: findUniqueOrThrow
   */
  export type translationFindUniqueOrThrowArgs = translationFindUniqueArgsBase
      

  /**
   * translation: findFirstOrThrow
   */
  export type translationFindFirstOrThrowArgs = translationFindFirstArgsBase
      

  /**
   * translation without action
   */
  export type translationArgs = {
    /**
     * Select specific fields to fetch from the translation
     * 
    **/
    select?: translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: translationInclude | null
  }



  /**
   * Model countries
   */


  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesMinAggregateOutputType = {
    code: string | null
    code_3: string | null
    name: string | null
    continent: string | null
    currency: string | null
  }

  export type CountriesMaxAggregateOutputType = {
    code: string | null
    code_3: string | null
    name: string | null
    continent: string | null
    currency: string | null
  }

  export type CountriesCountAggregateOutputType = {
    code: number
    code_3: number
    name: number
    continent: number
    currency: number
    _all: number
  }


  export type CountriesMinAggregateInputType = {
    code?: true
    code_3?: true
    name?: true
    continent?: true
    currency?: true
  }

  export type CountriesMaxAggregateInputType = {
    code?: true
    code_3?: true
    name?: true
    continent?: true
    currency?: true
  }

  export type CountriesCountAggregateInputType = {
    code?: true
    code_3?: true
    name?: true
    continent?: true
    currency?: true
    _all?: true
  }

  export type CountriesAggregateArgs = {
    /**
     * Filter which countries to aggregate.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type CountriesGroupByArgs = {
    where?: countriesWhereInput
    orderBy?: Enumerable<countriesOrderByWithAggregationInput>
    by: Array<CountriesScalarFieldEnum>
    having?: countriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }


  export type CountriesGroupByOutputType = {
    code: string
    code_3: string
    name: string
    continent: string | null
    currency: string | null
    _count: CountriesCountAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends CountriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type countriesSelect = {
    code?: boolean
    code_3?: boolean
    name?: boolean
    continent?: boolean
    currency?: boolean
    airports?: boolean | airportsFindManyArgs
    cities?: boolean | citiesFindManyArgs
    countries_translation?: boolean | countries_translationFindManyArgs
    _count?: boolean | CountriesCountOutputTypeArgs
  }

  export type countriesInclude = {
    airports?: boolean | airportsFindManyArgs
    cities?: boolean | citiesFindManyArgs
    countries_translation?: boolean | countries_translationFindManyArgs
    _count?: boolean | CountriesCountOutputTypeArgs
  }

  export type countriesGetPayload<
    S extends boolean | null | undefined | countriesArgs,
    U = keyof S
      > = S extends true
        ? countries
    : S extends undefined
    ? never
    : S extends countriesArgs | countriesFindManyArgs
    ?'include' extends U
    ? countries  & {
    [P in TrueKeys<S['include']>]:
        P extends 'airports' ? Array < airportsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < citiesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'countries_translation' ? Array < countries_translationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CountriesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'airports' ? Array < airportsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cities' ? Array < citiesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'countries_translation' ? Array < countries_translationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CountriesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof countries ? countries[P] : never
  } 
    : countries
  : countries


  type countriesCountArgs = Merge<
    Omit<countriesFindManyArgs, 'select' | 'include'> & {
      select?: CountriesCountAggregateInputType | true
    }
  >

  export interface countriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Countries that matches the filter.
     * @param {countriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, countriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'countries'> extends True ? CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>> : CheckSelect<T, Prisma__countriesClient<countries | null, null>, Prisma__countriesClient<countriesGetPayload<T> | null, null>>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, countriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'countries'> extends True ? CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>> : CheckSelect<T, Prisma__countriesClient<countries | null, null>, Prisma__countriesClient<countriesGetPayload<T> | null, null>>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const countriesWithCodeOnly = await prisma.countries.findMany({ select: { code: true } })
     * 
    **/
    findMany<T extends countriesFindManyArgs>(
      args?: SelectSubset<T, countriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<countries>>, PrismaPromise<Array<countriesGetPayload<T>>>>

    /**
     * Create a Countries.
     * @param {countriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
    **/
    create<T extends countriesCreateArgs>(
      args: SelectSubset<T, countriesCreateArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Create many Countries.
     *     @param {countriesCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const countries = await prisma.countries.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countriesCreateManyArgs>(
      args?: SelectSubset<T, countriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {countriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
    **/
    delete<T extends countriesDeleteArgs>(
      args: SelectSubset<T, countriesDeleteArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Update one Countries.
     * @param {countriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countriesUpdateArgs>(
      args: SelectSubset<T, countriesUpdateArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Delete zero or more Countries.
     * @param {countriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countriesDeleteManyArgs>(
      args?: SelectSubset<T, countriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countriesUpdateManyArgs>(
      args: SelectSubset<T, countriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {countriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
    **/
    upsert<T extends countriesUpsertArgs>(
      args: SelectSubset<T, countriesUpsertArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Find one Countries that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {countriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends countriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, countriesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Find the first Countries that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends countriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, countriesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__countriesClient<countries>, Prisma__countriesClient<countriesGetPayload<T>>>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends countriesCountArgs>(
      args?: Subset<T, countriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountriesGroupByArgs['orderBy'] }
        : { orderBy?: CountriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__countriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    airports<T extends airportsFindManyArgs = {}>(args?: Subset<T, airportsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<airports>| Null>, PrismaPromise<Array<airportsGetPayload<T>>| Null>>;

    cities<T extends citiesFindManyArgs = {}>(args?: Subset<T, citiesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<cities>| Null>, PrismaPromise<Array<citiesGetPayload<T>>| Null>>;

    countries_translation<T extends countries_translationFindManyArgs = {}>(args?: Subset<T, countries_translationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<countries_translation>| Null>, PrismaPromise<Array<countries_translationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * countries base type for findUnique actions
   */
  export type countriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where: countriesWhereUniqueInput
  }

  /**
   * countries: findUnique
   */
  export interface countriesFindUniqueArgs extends countriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries base type for findFirst actions
   */
  export type countriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries.
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries.
     * 
    **/
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }

  /**
   * countries: findFirst
   */
  export interface countriesFindFirstArgs extends countriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries findMany
   */
  export type countriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter, which countries to fetch.
     * 
    **/
    where?: countriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries to fetch.
     * 
    **/
    orderBy?: Enumerable<countriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries.
     * 
    **/
    cursor?: countriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CountriesScalarFieldEnum>
  }


  /**
   * countries create
   */
  export type countriesCreateArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The data needed to create a countries.
     * 
    **/
    data: XOR<countriesCreateInput, countriesUncheckedCreateInput>
  }


  /**
   * countries createMany
   */
  export type countriesCreateManyArgs = {
    /**
     * The data used to create many countries.
     * 
    **/
    data: Enumerable<countriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * countries update
   */
  export type countriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The data needed to update a countries.
     * 
    **/
    data: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
    /**
     * Choose, which countries to update.
     * 
    **/
    where: countriesWhereUniqueInput
  }


  /**
   * countries updateMany
   */
  export type countriesUpdateManyArgs = {
    /**
     * The data used to update countries.
     * 
    **/
    data: XOR<countriesUpdateManyMutationInput, countriesUncheckedUpdateManyInput>
    /**
     * Filter which countries to update
     * 
    **/
    where?: countriesWhereInput
  }


  /**
   * countries upsert
   */
  export type countriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * The filter to search for the countries to update in case it exists.
     * 
    **/
    where: countriesWhereUniqueInput
    /**
     * In case the countries found by the `where` argument doesn't exist, create a new countries with this data.
     * 
    **/
    create: XOR<countriesCreateInput, countriesUncheckedCreateInput>
    /**
     * In case the countries was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<countriesUpdateInput, countriesUncheckedUpdateInput>
  }


  /**
   * countries delete
   */
  export type countriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
    /**
     * Filter which countries to delete.
     * 
    **/
    where: countriesWhereUniqueInput
  }


  /**
   * countries deleteMany
   */
  export type countriesDeleteManyArgs = {
    /**
     * Filter which countries to delete
     * 
    **/
    where?: countriesWhereInput
  }


  /**
   * countries: findUniqueOrThrow
   */
  export type countriesFindUniqueOrThrowArgs = countriesFindUniqueArgsBase
      

  /**
   * countries: findFirstOrThrow
   */
  export type countriesFindFirstOrThrowArgs = countriesFindFirstArgsBase
      

  /**
   * countries without action
   */
  export type countriesArgs = {
    /**
     * Select specific fields to fetch from the countries
     * 
    **/
    select?: countriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countriesInclude | null
  }



  /**
   * Model countries_translation
   */


  export type AggregateCountries_translation = {
    _count: Countries_translationCountAggregateOutputType | null
    _min: Countries_translationMinAggregateOutputType | null
    _max: Countries_translationMaxAggregateOutputType | null
  }

  export type Countries_translationMinAggregateOutputType = {
    country_code: string | null
    locale: string | null
    country_name: string | null
  }

  export type Countries_translationMaxAggregateOutputType = {
    country_code: string | null
    locale: string | null
    country_name: string | null
  }

  export type Countries_translationCountAggregateOutputType = {
    country_code: number
    locale: number
    country_name: number
    _all: number
  }


  export type Countries_translationMinAggregateInputType = {
    country_code?: true
    locale?: true
    country_name?: true
  }

  export type Countries_translationMaxAggregateInputType = {
    country_code?: true
    locale?: true
    country_name?: true
  }

  export type Countries_translationCountAggregateInputType = {
    country_code?: true
    locale?: true
    country_name?: true
    _all?: true
  }

  export type Countries_translationAggregateArgs = {
    /**
     * Filter which countries_translation to aggregate.
     * 
    **/
    where?: countries_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<countries_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: countries_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries_translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned countries_translations
    **/
    _count?: true | Countries_translationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Countries_translationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Countries_translationMaxAggregateInputType
  }

  export type GetCountries_translationAggregateType<T extends Countries_translationAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries_translation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries_translation[P]>
      : GetScalarType<T[P], AggregateCountries_translation[P]>
  }




  export type Countries_translationGroupByArgs = {
    where?: countries_translationWhereInput
    orderBy?: Enumerable<countries_translationOrderByWithAggregationInput>
    by: Array<Countries_translationScalarFieldEnum>
    having?: countries_translationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Countries_translationCountAggregateInputType | true
    _min?: Countries_translationMinAggregateInputType
    _max?: Countries_translationMaxAggregateInputType
  }


  export type Countries_translationGroupByOutputType = {
    country_code: string
    locale: string
    country_name: string
    _count: Countries_translationCountAggregateOutputType | null
    _min: Countries_translationMinAggregateOutputType | null
    _max: Countries_translationMaxAggregateOutputType | null
  }

  type GetCountries_translationGroupByPayload<T extends Countries_translationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Countries_translationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Countries_translationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Countries_translationGroupByOutputType[P]>
            : GetScalarType<T[P], Countries_translationGroupByOutputType[P]>
        }
      >
    >


  export type countries_translationSelect = {
    country_code?: boolean
    locale?: boolean
    country_name?: boolean
    countries?: boolean | countriesArgs
  }

  export type countries_translationInclude = {
    countries?: boolean | countriesArgs
  }

  export type countries_translationGetPayload<
    S extends boolean | null | undefined | countries_translationArgs,
    U = keyof S
      > = S extends true
        ? countries_translation
    : S extends undefined
    ? never
    : S extends countries_translationArgs | countries_translationFindManyArgs
    ?'include' extends U
    ? countries_translation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof countries_translation ? countries_translation[P] : never
  } 
    : countries_translation
  : countries_translation


  type countries_translationCountArgs = Merge<
    Omit<countries_translationFindManyArgs, 'select' | 'include'> & {
      select?: Countries_translationCountAggregateInputType | true
    }
  >

  export interface countries_translationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Countries_translation that matches the filter.
     * @param {countries_translationFindUniqueArgs} args - Arguments to find a Countries_translation
     * @example
     * // Get one Countries_translation
     * const countries_translation = await prisma.countries_translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends countries_translationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, countries_translationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'countries_translation'> extends True ? CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>> : CheckSelect<T, Prisma__countries_translationClient<countries_translation | null, null>, Prisma__countries_translationClient<countries_translationGetPayload<T> | null, null>>

    /**
     * Find the first Countries_translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countries_translationFindFirstArgs} args - Arguments to find a Countries_translation
     * @example
     * // Get one Countries_translation
     * const countries_translation = await prisma.countries_translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends countries_translationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, countries_translationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'countries_translation'> extends True ? CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>> : CheckSelect<T, Prisma__countries_translationClient<countries_translation | null, null>, Prisma__countries_translationClient<countries_translationGetPayload<T> | null, null>>

    /**
     * Find zero or more Countries_translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countries_translationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries_translations
     * const countries_translations = await prisma.countries_translation.findMany()
     * 
     * // Get first 10 Countries_translations
     * const countries_translations = await prisma.countries_translation.findMany({ take: 10 })
     * 
     * // Only select the `country_code`
     * const countries_translationWithCountry_codeOnly = await prisma.countries_translation.findMany({ select: { country_code: true } })
     * 
    **/
    findMany<T extends countries_translationFindManyArgs>(
      args?: SelectSubset<T, countries_translationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<countries_translation>>, PrismaPromise<Array<countries_translationGetPayload<T>>>>

    /**
     * Create a Countries_translation.
     * @param {countries_translationCreateArgs} args - Arguments to create a Countries_translation.
     * @example
     * // Create one Countries_translation
     * const Countries_translation = await prisma.countries_translation.create({
     *   data: {
     *     // ... data to create a Countries_translation
     *   }
     * })
     * 
    **/
    create<T extends countries_translationCreateArgs>(
      args: SelectSubset<T, countries_translationCreateArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Create many Countries_translations.
     *     @param {countries_translationCreateManyArgs} args - Arguments to create many Countries_translations.
     *     @example
     *     // Create many Countries_translations
     *     const countries_translation = await prisma.countries_translation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends countries_translationCreateManyArgs>(
      args?: SelectSubset<T, countries_translationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Countries_translation.
     * @param {countries_translationDeleteArgs} args - Arguments to delete one Countries_translation.
     * @example
     * // Delete one Countries_translation
     * const Countries_translation = await prisma.countries_translation.delete({
     *   where: {
     *     // ... filter to delete one Countries_translation
     *   }
     * })
     * 
    **/
    delete<T extends countries_translationDeleteArgs>(
      args: SelectSubset<T, countries_translationDeleteArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Update one Countries_translation.
     * @param {countries_translationUpdateArgs} args - Arguments to update one Countries_translation.
     * @example
     * // Update one Countries_translation
     * const countries_translation = await prisma.countries_translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends countries_translationUpdateArgs>(
      args: SelectSubset<T, countries_translationUpdateArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Delete zero or more Countries_translations.
     * @param {countries_translationDeleteManyArgs} args - Arguments to filter Countries_translations to delete.
     * @example
     * // Delete a few Countries_translations
     * const { count } = await prisma.countries_translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends countries_translationDeleteManyArgs>(
      args?: SelectSubset<T, countries_translationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countries_translationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries_translations
     * const countries_translation = await prisma.countries_translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends countries_translationUpdateManyArgs>(
      args: SelectSubset<T, countries_translationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries_translation.
     * @param {countries_translationUpsertArgs} args - Arguments to update or create a Countries_translation.
     * @example
     * // Update or create a Countries_translation
     * const countries_translation = await prisma.countries_translation.upsert({
     *   create: {
     *     // ... data to create a Countries_translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries_translation we want to update
     *   }
     * })
    **/
    upsert<T extends countries_translationUpsertArgs>(
      args: SelectSubset<T, countries_translationUpsertArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Find one Countries_translation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {countries_translationFindUniqueOrThrowArgs} args - Arguments to find a Countries_translation
     * @example
     * // Get one Countries_translation
     * const countries_translation = await prisma.countries_translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends countries_translationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, countries_translationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Find the first Countries_translation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countries_translationFindFirstOrThrowArgs} args - Arguments to find a Countries_translation
     * @example
     * // Get one Countries_translation
     * const countries_translation = await prisma.countries_translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends countries_translationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, countries_translationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__countries_translationClient<countries_translation>, Prisma__countries_translationClient<countries_translationGetPayload<T>>>

    /**
     * Count the number of Countries_translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {countries_translationCountArgs} args - Arguments to filter Countries_translations to count.
     * @example
     * // Count the number of Countries_translations
     * const count = await prisma.countries_translation.count({
     *   where: {
     *     // ... the filter for the Countries_translations we want to count
     *   }
     * })
    **/
    count<T extends countries_translationCountArgs>(
      args?: Subset<T, countries_translationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Countries_translationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Countries_translationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Countries_translationAggregateArgs>(args: Subset<T, Countries_translationAggregateArgs>): PrismaPromise<GetCountries_translationAggregateType<T>>

    /**
     * Group by Countries_translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Countries_translationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Countries_translationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Countries_translationGroupByArgs['orderBy'] }
        : { orderBy?: Countries_translationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Countries_translationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountries_translationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for countries_translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__countries_translationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countries<T extends countriesArgs = {}>(args?: Subset<T, countriesArgs>): CheckSelect<T, Prisma__countriesClient<countries | Null>, Prisma__countriesClient<countriesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * countries_translation base type for findUnique actions
   */
  export type countries_translationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * Filter, which countries_translation to fetch.
     * 
    **/
    where: countries_translationWhereUniqueInput
  }

  /**
   * countries_translation: findUnique
   */
  export interface countries_translationFindUniqueArgs extends countries_translationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries_translation base type for findFirst actions
   */
  export type countries_translationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * Filter, which countries_translation to fetch.
     * 
    **/
    where?: countries_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<countries_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for countries_translations.
     * 
    **/
    cursor?: countries_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries_translations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of countries_translations.
     * 
    **/
    distinct?: Enumerable<Countries_translationScalarFieldEnum>
  }

  /**
   * countries_translation: findFirst
   */
  export interface countries_translationFindFirstArgs extends countries_translationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * countries_translation findMany
   */
  export type countries_translationFindManyArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * Filter, which countries_translations to fetch.
     * 
    **/
    where?: countries_translationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of countries_translations to fetch.
     * 
    **/
    orderBy?: Enumerable<countries_translationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing countries_translations.
     * 
    **/
    cursor?: countries_translationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` countries_translations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` countries_translations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Countries_translationScalarFieldEnum>
  }


  /**
   * countries_translation create
   */
  export type countries_translationCreateArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * The data needed to create a countries_translation.
     * 
    **/
    data: XOR<countries_translationCreateInput, countries_translationUncheckedCreateInput>
  }


  /**
   * countries_translation createMany
   */
  export type countries_translationCreateManyArgs = {
    /**
     * The data used to create many countries_translations.
     * 
    **/
    data: Enumerable<countries_translationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * countries_translation update
   */
  export type countries_translationUpdateArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * The data needed to update a countries_translation.
     * 
    **/
    data: XOR<countries_translationUpdateInput, countries_translationUncheckedUpdateInput>
    /**
     * Choose, which countries_translation to update.
     * 
    **/
    where: countries_translationWhereUniqueInput
  }


  /**
   * countries_translation updateMany
   */
  export type countries_translationUpdateManyArgs = {
    /**
     * The data used to update countries_translations.
     * 
    **/
    data: XOR<countries_translationUpdateManyMutationInput, countries_translationUncheckedUpdateManyInput>
    /**
     * Filter which countries_translations to update
     * 
    **/
    where?: countries_translationWhereInput
  }


  /**
   * countries_translation upsert
   */
  export type countries_translationUpsertArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * The filter to search for the countries_translation to update in case it exists.
     * 
    **/
    where: countries_translationWhereUniqueInput
    /**
     * In case the countries_translation found by the `where` argument doesn't exist, create a new countries_translation with this data.
     * 
    **/
    create: XOR<countries_translationCreateInput, countries_translationUncheckedCreateInput>
    /**
     * In case the countries_translation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<countries_translationUpdateInput, countries_translationUncheckedUpdateInput>
  }


  /**
   * countries_translation delete
   */
  export type countries_translationDeleteArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
    /**
     * Filter which countries_translation to delete.
     * 
    **/
    where: countries_translationWhereUniqueInput
  }


  /**
   * countries_translation deleteMany
   */
  export type countries_translationDeleteManyArgs = {
    /**
     * Filter which countries_translations to delete
     * 
    **/
    where?: countries_translationWhereInput
  }


  /**
   * countries_translation: findUniqueOrThrow
   */
  export type countries_translationFindUniqueOrThrowArgs = countries_translationFindUniqueArgsBase
      

  /**
   * countries_translation: findFirstOrThrow
   */
  export type countries_translationFindFirstOrThrowArgs = countries_translationFindFirstArgsBase
      

  /**
   * countries_translation without action
   */
  export type countries_translationArgs = {
    /**
     * Select specific fields to fetch from the countries_translation
     * 
    **/
    select?: countries_translationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: countries_translationInclude | null
  }



  /**
   * Model location_type_1
   */


  export type AggregateLocation_type_1 = {
    _count: Location_type_1CountAggregateOutputType | null
    _min: Location_type_1MinAggregateOutputType | null
    _max: Location_type_1MaxAggregateOutputType | null
  }

  export type Location_type_1MinAggregateOutputType = {
    type: string | null
    description: string | null
  }

  export type Location_type_1MaxAggregateOutputType = {
    type: string | null
    description: string | null
  }

  export type Location_type_1CountAggregateOutputType = {
    type: number
    description: number
    _all: number
  }


  export type Location_type_1MinAggregateInputType = {
    type?: true
    description?: true
  }

  export type Location_type_1MaxAggregateInputType = {
    type?: true
    description?: true
  }

  export type Location_type_1CountAggregateInputType = {
    type?: true
    description?: true
    _all?: true
  }

  export type Location_type_1AggregateArgs = {
    /**
     * Filter which location_type_1 to aggregate.
     * 
    **/
    where?: location_type_1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_1s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: location_type_1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_1s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_type_1s
    **/
    _count?: true | Location_type_1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_type_1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_type_1MaxAggregateInputType
  }

  export type GetLocation_type_1AggregateType<T extends Location_type_1AggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_type_1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_type_1[P]>
      : GetScalarType<T[P], AggregateLocation_type_1[P]>
  }




  export type Location_type_1GroupByArgs = {
    where?: location_type_1WhereInput
    orderBy?: Enumerable<location_type_1OrderByWithAggregationInput>
    by: Array<Location_type_1ScalarFieldEnum>
    having?: location_type_1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_type_1CountAggregateInputType | true
    _min?: Location_type_1MinAggregateInputType
    _max?: Location_type_1MaxAggregateInputType
  }


  export type Location_type_1GroupByOutputType = {
    type: string
    description: string
    _count: Location_type_1CountAggregateOutputType | null
    _min: Location_type_1MinAggregateOutputType | null
    _max: Location_type_1MaxAggregateOutputType | null
  }

  type GetLocation_type_1GroupByPayload<T extends Location_type_1GroupByArgs> = PrismaPromise<
    Array<
      PickArray<Location_type_1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_type_1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_type_1GroupByOutputType[P]>
            : GetScalarType<T[P], Location_type_1GroupByOutputType[P]>
        }
      >
    >


  export type location_type_1Select = {
    type?: boolean
    description?: boolean
    location?: boolean | locationFindManyArgs
    _count?: boolean | Location_type_1CountOutputTypeArgs
  }

  export type location_type_1Include = {
    location?: boolean | locationFindManyArgs
    _count?: boolean | Location_type_1CountOutputTypeArgs
  }

  export type location_type_1GetPayload<
    S extends boolean | null | undefined | location_type_1Args,
    U = keyof S
      > = S extends true
        ? location_type_1
    : S extends undefined
    ? never
    : S extends location_type_1Args | location_type_1FindManyArgs
    ?'include' extends U
    ? location_type_1  & {
    [P in TrueKeys<S['include']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Location_type_1CountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Location_type_1CountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof location_type_1 ? location_type_1[P] : never
  } 
    : location_type_1
  : location_type_1


  type location_type_1CountArgs = Merge<
    Omit<location_type_1FindManyArgs, 'select' | 'include'> & {
      select?: Location_type_1CountAggregateInputType | true
    }
  >

  export interface location_type_1Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Location_type_1 that matches the filter.
     * @param {location_type_1FindUniqueArgs} args - Arguments to find a Location_type_1
     * @example
     * // Get one Location_type_1
     * const location_type_1 = await prisma.location_type_1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends location_type_1FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, location_type_1FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location_type_1'> extends True ? CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>> : CheckSelect<T, Prisma__location_type_1Client<location_type_1 | null, null>, Prisma__location_type_1Client<location_type_1GetPayload<T> | null, null>>

    /**
     * Find the first Location_type_1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_1FindFirstArgs} args - Arguments to find a Location_type_1
     * @example
     * // Get one Location_type_1
     * const location_type_1 = await prisma.location_type_1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends location_type_1FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, location_type_1FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location_type_1'> extends True ? CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>> : CheckSelect<T, Prisma__location_type_1Client<location_type_1 | null, null>, Prisma__location_type_1Client<location_type_1GetPayload<T> | null, null>>

    /**
     * Find zero or more Location_type_1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_1FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_type_1s
     * const location_type_1s = await prisma.location_type_1.findMany()
     * 
     * // Get first 10 Location_type_1s
     * const location_type_1s = await prisma.location_type_1.findMany({ take: 10 })
     * 
     * // Only select the `type`
     * const location_type_1WithTypeOnly = await prisma.location_type_1.findMany({ select: { type: true } })
     * 
    **/
    findMany<T extends location_type_1FindManyArgs>(
      args?: SelectSubset<T, location_type_1FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location_type_1>>, PrismaPromise<Array<location_type_1GetPayload<T>>>>

    /**
     * Create a Location_type_1.
     * @param {location_type_1CreateArgs} args - Arguments to create a Location_type_1.
     * @example
     * // Create one Location_type_1
     * const Location_type_1 = await prisma.location_type_1.create({
     *   data: {
     *     // ... data to create a Location_type_1
     *   }
     * })
     * 
    **/
    create<T extends location_type_1CreateArgs>(
      args: SelectSubset<T, location_type_1CreateArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Create many Location_type_1s.
     *     @param {location_type_1CreateManyArgs} args - Arguments to create many Location_type_1s.
     *     @example
     *     // Create many Location_type_1s
     *     const location_type_1 = await prisma.location_type_1.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends location_type_1CreateManyArgs>(
      args?: SelectSubset<T, location_type_1CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location_type_1.
     * @param {location_type_1DeleteArgs} args - Arguments to delete one Location_type_1.
     * @example
     * // Delete one Location_type_1
     * const Location_type_1 = await prisma.location_type_1.delete({
     *   where: {
     *     // ... filter to delete one Location_type_1
     *   }
     * })
     * 
    **/
    delete<T extends location_type_1DeleteArgs>(
      args: SelectSubset<T, location_type_1DeleteArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Update one Location_type_1.
     * @param {location_type_1UpdateArgs} args - Arguments to update one Location_type_1.
     * @example
     * // Update one Location_type_1
     * const location_type_1 = await prisma.location_type_1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends location_type_1UpdateArgs>(
      args: SelectSubset<T, location_type_1UpdateArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Delete zero or more Location_type_1s.
     * @param {location_type_1DeleteManyArgs} args - Arguments to filter Location_type_1s to delete.
     * @example
     * // Delete a few Location_type_1s
     * const { count } = await prisma.location_type_1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends location_type_1DeleteManyArgs>(
      args?: SelectSubset<T, location_type_1DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_type_1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_type_1s
     * const location_type_1 = await prisma.location_type_1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends location_type_1UpdateManyArgs>(
      args: SelectSubset<T, location_type_1UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_type_1.
     * @param {location_type_1UpsertArgs} args - Arguments to update or create a Location_type_1.
     * @example
     * // Update or create a Location_type_1
     * const location_type_1 = await prisma.location_type_1.upsert({
     *   create: {
     *     // ... data to create a Location_type_1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_type_1 we want to update
     *   }
     * })
    **/
    upsert<T extends location_type_1UpsertArgs>(
      args: SelectSubset<T, location_type_1UpsertArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Find one Location_type_1 that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {location_type_1FindUniqueOrThrowArgs} args - Arguments to find a Location_type_1
     * @example
     * // Get one Location_type_1
     * const location_type_1 = await prisma.location_type_1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends location_type_1FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, location_type_1FindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Find the first Location_type_1 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_1FindFirstOrThrowArgs} args - Arguments to find a Location_type_1
     * @example
     * // Get one Location_type_1
     * const location_type_1 = await prisma.location_type_1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends location_type_1FindFirstOrThrowArgs>(
      args?: SelectSubset<T, location_type_1FindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__location_type_1Client<location_type_1>, Prisma__location_type_1Client<location_type_1GetPayload<T>>>

    /**
     * Count the number of Location_type_1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_1CountArgs} args - Arguments to filter Location_type_1s to count.
     * @example
     * // Count the number of Location_type_1s
     * const count = await prisma.location_type_1.count({
     *   where: {
     *     // ... the filter for the Location_type_1s we want to count
     *   }
     * })
    **/
    count<T extends location_type_1CountArgs>(
      args?: Subset<T, location_type_1CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_type_1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_type_1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_type_1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_type_1AggregateArgs>(args: Subset<T, Location_type_1AggregateArgs>): PrismaPromise<GetLocation_type_1AggregateType<T>>

    /**
     * Group by Location_type_1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_type_1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Location_type_1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Location_type_1GroupByArgs['orderBy'] }
        : { orderBy?: Location_type_1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Location_type_1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_type_1GroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location_type_1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__location_type_1Client<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    location<T extends locationFindManyArgs = {}>(args?: Subset<T, locationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location>| Null>, PrismaPromise<Array<locationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location_type_1 base type for findUnique actions
   */
  export type location_type_1FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * Filter, which location_type_1 to fetch.
     * 
    **/
    where: location_type_1WhereUniqueInput
  }

  /**
   * location_type_1: findUnique
   */
  export interface location_type_1FindUniqueArgs extends location_type_1FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_type_1 base type for findFirst actions
   */
  export type location_type_1FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * Filter, which location_type_1 to fetch.
     * 
    **/
    where?: location_type_1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_1s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_type_1s.
     * 
    **/
    cursor?: location_type_1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_1s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_type_1s.
     * 
    **/
    distinct?: Enumerable<Location_type_1ScalarFieldEnum>
  }

  /**
   * location_type_1: findFirst
   */
  export interface location_type_1FindFirstArgs extends location_type_1FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_type_1 findMany
   */
  export type location_type_1FindManyArgs = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * Filter, which location_type_1s to fetch.
     * 
    **/
    where?: location_type_1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_1s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_type_1s.
     * 
    **/
    cursor?: location_type_1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_1s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Location_type_1ScalarFieldEnum>
  }


  /**
   * location_type_1 create
   */
  export type location_type_1CreateArgs = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * The data needed to create a location_type_1.
     * 
    **/
    data: XOR<location_type_1CreateInput, location_type_1UncheckedCreateInput>
  }


  /**
   * location_type_1 createMany
   */
  export type location_type_1CreateManyArgs = {
    /**
     * The data used to create many location_type_1s.
     * 
    **/
    data: Enumerable<location_type_1CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location_type_1 update
   */
  export type location_type_1UpdateArgs = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * The data needed to update a location_type_1.
     * 
    **/
    data: XOR<location_type_1UpdateInput, location_type_1UncheckedUpdateInput>
    /**
     * Choose, which location_type_1 to update.
     * 
    **/
    where: location_type_1WhereUniqueInput
  }


  /**
   * location_type_1 updateMany
   */
  export type location_type_1UpdateManyArgs = {
    /**
     * The data used to update location_type_1s.
     * 
    **/
    data: XOR<location_type_1UpdateManyMutationInput, location_type_1UncheckedUpdateManyInput>
    /**
     * Filter which location_type_1s to update
     * 
    **/
    where?: location_type_1WhereInput
  }


  /**
   * location_type_1 upsert
   */
  export type location_type_1UpsertArgs = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * The filter to search for the location_type_1 to update in case it exists.
     * 
    **/
    where: location_type_1WhereUniqueInput
    /**
     * In case the location_type_1 found by the `where` argument doesn't exist, create a new location_type_1 with this data.
     * 
    **/
    create: XOR<location_type_1CreateInput, location_type_1UncheckedCreateInput>
    /**
     * In case the location_type_1 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<location_type_1UpdateInput, location_type_1UncheckedUpdateInput>
  }


  /**
   * location_type_1 delete
   */
  export type location_type_1DeleteArgs = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
    /**
     * Filter which location_type_1 to delete.
     * 
    **/
    where: location_type_1WhereUniqueInput
  }


  /**
   * location_type_1 deleteMany
   */
  export type location_type_1DeleteManyArgs = {
    /**
     * Filter which location_type_1s to delete
     * 
    **/
    where?: location_type_1WhereInput
  }


  /**
   * location_type_1: findUniqueOrThrow
   */
  export type location_type_1FindUniqueOrThrowArgs = location_type_1FindUniqueArgsBase
      

  /**
   * location_type_1: findFirstOrThrow
   */
  export type location_type_1FindFirstOrThrowArgs = location_type_1FindFirstArgsBase
      

  /**
   * location_type_1 without action
   */
  export type location_type_1Args = {
    /**
     * Select specific fields to fetch from the location_type_1
     * 
    **/
    select?: location_type_1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_1Include | null
  }



  /**
   * Model location_type_2
   */


  export type AggregateLocation_type_2 = {
    _count: Location_type_2CountAggregateOutputType | null
    _min: Location_type_2MinAggregateOutputType | null
    _max: Location_type_2MaxAggregateOutputType | null
  }

  export type Location_type_2MinAggregateOutputType = {
    type: string | null
    description: string | null
  }

  export type Location_type_2MaxAggregateOutputType = {
    type: string | null
    description: string | null
  }

  export type Location_type_2CountAggregateOutputType = {
    type: number
    description: number
    _all: number
  }


  export type Location_type_2MinAggregateInputType = {
    type?: true
    description?: true
  }

  export type Location_type_2MaxAggregateInputType = {
    type?: true
    description?: true
  }

  export type Location_type_2CountAggregateInputType = {
    type?: true
    description?: true
    _all?: true
  }

  export type Location_type_2AggregateArgs = {
    /**
     * Filter which location_type_2 to aggregate.
     * 
    **/
    where?: location_type_2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_2s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: location_type_2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_2s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned location_type_2s
    **/
    _count?: true | Location_type_2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Location_type_2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Location_type_2MaxAggregateInputType
  }

  export type GetLocation_type_2AggregateType<T extends Location_type_2AggregateArgs> = {
        [P in keyof T & keyof AggregateLocation_type_2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation_type_2[P]>
      : GetScalarType<T[P], AggregateLocation_type_2[P]>
  }




  export type Location_type_2GroupByArgs = {
    where?: location_type_2WhereInput
    orderBy?: Enumerable<location_type_2OrderByWithAggregationInput>
    by: Array<Location_type_2ScalarFieldEnum>
    having?: location_type_2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Location_type_2CountAggregateInputType | true
    _min?: Location_type_2MinAggregateInputType
    _max?: Location_type_2MaxAggregateInputType
  }


  export type Location_type_2GroupByOutputType = {
    type: string
    description: string
    _count: Location_type_2CountAggregateOutputType | null
    _min: Location_type_2MinAggregateOutputType | null
    _max: Location_type_2MaxAggregateOutputType | null
  }

  type GetLocation_type_2GroupByPayload<T extends Location_type_2GroupByArgs> = PrismaPromise<
    Array<
      PickArray<Location_type_2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Location_type_2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Location_type_2GroupByOutputType[P]>
            : GetScalarType<T[P], Location_type_2GroupByOutputType[P]>
        }
      >
    >


  export type location_type_2Select = {
    type?: boolean
    description?: boolean
    location?: boolean | locationFindManyArgs
    _count?: boolean | Location_type_2CountOutputTypeArgs
  }

  export type location_type_2Include = {
    location?: boolean | locationFindManyArgs
    _count?: boolean | Location_type_2CountOutputTypeArgs
  }

  export type location_type_2GetPayload<
    S extends boolean | null | undefined | location_type_2Args,
    U = keyof S
      > = S extends true
        ? location_type_2
    : S extends undefined
    ? never
    : S extends location_type_2Args | location_type_2FindManyArgs
    ?'include' extends U
    ? location_type_2  & {
    [P in TrueKeys<S['include']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Location_type_2CountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Location_type_2CountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof location_type_2 ? location_type_2[P] : never
  } 
    : location_type_2
  : location_type_2


  type location_type_2CountArgs = Merge<
    Omit<location_type_2FindManyArgs, 'select' | 'include'> & {
      select?: Location_type_2CountAggregateInputType | true
    }
  >

  export interface location_type_2Delegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Location_type_2 that matches the filter.
     * @param {location_type_2FindUniqueArgs} args - Arguments to find a Location_type_2
     * @example
     * // Get one Location_type_2
     * const location_type_2 = await prisma.location_type_2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends location_type_2FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, location_type_2FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location_type_2'> extends True ? CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>> : CheckSelect<T, Prisma__location_type_2Client<location_type_2 | null, null>, Prisma__location_type_2Client<location_type_2GetPayload<T> | null, null>>

    /**
     * Find the first Location_type_2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_2FindFirstArgs} args - Arguments to find a Location_type_2
     * @example
     * // Get one Location_type_2
     * const location_type_2 = await prisma.location_type_2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends location_type_2FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, location_type_2FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location_type_2'> extends True ? CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>> : CheckSelect<T, Prisma__location_type_2Client<location_type_2 | null, null>, Prisma__location_type_2Client<location_type_2GetPayload<T> | null, null>>

    /**
     * Find zero or more Location_type_2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_2FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Location_type_2s
     * const location_type_2s = await prisma.location_type_2.findMany()
     * 
     * // Get first 10 Location_type_2s
     * const location_type_2s = await prisma.location_type_2.findMany({ take: 10 })
     * 
     * // Only select the `type`
     * const location_type_2WithTypeOnly = await prisma.location_type_2.findMany({ select: { type: true } })
     * 
    **/
    findMany<T extends location_type_2FindManyArgs>(
      args?: SelectSubset<T, location_type_2FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location_type_2>>, PrismaPromise<Array<location_type_2GetPayload<T>>>>

    /**
     * Create a Location_type_2.
     * @param {location_type_2CreateArgs} args - Arguments to create a Location_type_2.
     * @example
     * // Create one Location_type_2
     * const Location_type_2 = await prisma.location_type_2.create({
     *   data: {
     *     // ... data to create a Location_type_2
     *   }
     * })
     * 
    **/
    create<T extends location_type_2CreateArgs>(
      args: SelectSubset<T, location_type_2CreateArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Create many Location_type_2s.
     *     @param {location_type_2CreateManyArgs} args - Arguments to create many Location_type_2s.
     *     @example
     *     // Create many Location_type_2s
     *     const location_type_2 = await prisma.location_type_2.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends location_type_2CreateManyArgs>(
      args?: SelectSubset<T, location_type_2CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Location_type_2.
     * @param {location_type_2DeleteArgs} args - Arguments to delete one Location_type_2.
     * @example
     * // Delete one Location_type_2
     * const Location_type_2 = await prisma.location_type_2.delete({
     *   where: {
     *     // ... filter to delete one Location_type_2
     *   }
     * })
     * 
    **/
    delete<T extends location_type_2DeleteArgs>(
      args: SelectSubset<T, location_type_2DeleteArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Update one Location_type_2.
     * @param {location_type_2UpdateArgs} args - Arguments to update one Location_type_2.
     * @example
     * // Update one Location_type_2
     * const location_type_2 = await prisma.location_type_2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends location_type_2UpdateArgs>(
      args: SelectSubset<T, location_type_2UpdateArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Delete zero or more Location_type_2s.
     * @param {location_type_2DeleteManyArgs} args - Arguments to filter Location_type_2s to delete.
     * @example
     * // Delete a few Location_type_2s
     * const { count } = await prisma.location_type_2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends location_type_2DeleteManyArgs>(
      args?: SelectSubset<T, location_type_2DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Location_type_2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Location_type_2s
     * const location_type_2 = await prisma.location_type_2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends location_type_2UpdateManyArgs>(
      args: SelectSubset<T, location_type_2UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location_type_2.
     * @param {location_type_2UpsertArgs} args - Arguments to update or create a Location_type_2.
     * @example
     * // Update or create a Location_type_2
     * const location_type_2 = await prisma.location_type_2.upsert({
     *   create: {
     *     // ... data to create a Location_type_2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location_type_2 we want to update
     *   }
     * })
    **/
    upsert<T extends location_type_2UpsertArgs>(
      args: SelectSubset<T, location_type_2UpsertArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Find one Location_type_2 that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {location_type_2FindUniqueOrThrowArgs} args - Arguments to find a Location_type_2
     * @example
     * // Get one Location_type_2
     * const location_type_2 = await prisma.location_type_2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends location_type_2FindUniqueOrThrowArgs>(
      args?: SelectSubset<T, location_type_2FindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Find the first Location_type_2 that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_2FindFirstOrThrowArgs} args - Arguments to find a Location_type_2
     * @example
     * // Get one Location_type_2
     * const location_type_2 = await prisma.location_type_2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends location_type_2FindFirstOrThrowArgs>(
      args?: SelectSubset<T, location_type_2FindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__location_type_2Client<location_type_2>, Prisma__location_type_2Client<location_type_2GetPayload<T>>>

    /**
     * Count the number of Location_type_2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {location_type_2CountArgs} args - Arguments to filter Location_type_2s to count.
     * @example
     * // Count the number of Location_type_2s
     * const count = await prisma.location_type_2.count({
     *   where: {
     *     // ... the filter for the Location_type_2s we want to count
     *   }
     * })
    **/
    count<T extends location_type_2CountArgs>(
      args?: Subset<T, location_type_2CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Location_type_2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location_type_2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_type_2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Location_type_2AggregateArgs>(args: Subset<T, Location_type_2AggregateArgs>): PrismaPromise<GetLocation_type_2AggregateType<T>>

    /**
     * Group by Location_type_2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Location_type_2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Location_type_2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Location_type_2GroupByArgs['orderBy'] }
        : { orderBy?: Location_type_2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Location_type_2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocation_type_2GroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location_type_2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__location_type_2Client<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    location<T extends locationFindManyArgs = {}>(args?: Subset<T, locationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location>| Null>, PrismaPromise<Array<locationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location_type_2 base type for findUnique actions
   */
  export type location_type_2FindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * Filter, which location_type_2 to fetch.
     * 
    **/
    where: location_type_2WhereUniqueInput
  }

  /**
   * location_type_2: findUnique
   */
  export interface location_type_2FindUniqueArgs extends location_type_2FindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_type_2 base type for findFirst actions
   */
  export type location_type_2FindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * Filter, which location_type_2 to fetch.
     * 
    **/
    where?: location_type_2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_2s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for location_type_2s.
     * 
    **/
    cursor?: location_type_2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_2s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of location_type_2s.
     * 
    **/
    distinct?: Enumerable<Location_type_2ScalarFieldEnum>
  }

  /**
   * location_type_2: findFirst
   */
  export interface location_type_2FindFirstArgs extends location_type_2FindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location_type_2 findMany
   */
  export type location_type_2FindManyArgs = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * Filter, which location_type_2s to fetch.
     * 
    **/
    where?: location_type_2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of location_type_2s to fetch.
     * 
    **/
    orderBy?: Enumerable<location_type_2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing location_type_2s.
     * 
    **/
    cursor?: location_type_2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` location_type_2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` location_type_2s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Location_type_2ScalarFieldEnum>
  }


  /**
   * location_type_2 create
   */
  export type location_type_2CreateArgs = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * The data needed to create a location_type_2.
     * 
    **/
    data: XOR<location_type_2CreateInput, location_type_2UncheckedCreateInput>
  }


  /**
   * location_type_2 createMany
   */
  export type location_type_2CreateManyArgs = {
    /**
     * The data used to create many location_type_2s.
     * 
    **/
    data: Enumerable<location_type_2CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location_type_2 update
   */
  export type location_type_2UpdateArgs = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * The data needed to update a location_type_2.
     * 
    **/
    data: XOR<location_type_2UpdateInput, location_type_2UncheckedUpdateInput>
    /**
     * Choose, which location_type_2 to update.
     * 
    **/
    where: location_type_2WhereUniqueInput
  }


  /**
   * location_type_2 updateMany
   */
  export type location_type_2UpdateManyArgs = {
    /**
     * The data used to update location_type_2s.
     * 
    **/
    data: XOR<location_type_2UpdateManyMutationInput, location_type_2UncheckedUpdateManyInput>
    /**
     * Filter which location_type_2s to update
     * 
    **/
    where?: location_type_2WhereInput
  }


  /**
   * location_type_2 upsert
   */
  export type location_type_2UpsertArgs = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * The filter to search for the location_type_2 to update in case it exists.
     * 
    **/
    where: location_type_2WhereUniqueInput
    /**
     * In case the location_type_2 found by the `where` argument doesn't exist, create a new location_type_2 with this data.
     * 
    **/
    create: XOR<location_type_2CreateInput, location_type_2UncheckedCreateInput>
    /**
     * In case the location_type_2 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<location_type_2UpdateInput, location_type_2UncheckedUpdateInput>
  }


  /**
   * location_type_2 delete
   */
  export type location_type_2DeleteArgs = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
    /**
     * Filter which location_type_2 to delete.
     * 
    **/
    where: location_type_2WhereUniqueInput
  }


  /**
   * location_type_2 deleteMany
   */
  export type location_type_2DeleteManyArgs = {
    /**
     * Filter which location_type_2s to delete
     * 
    **/
    where?: location_type_2WhereInput
  }


  /**
   * location_type_2: findUniqueOrThrow
   */
  export type location_type_2FindUniqueOrThrowArgs = location_type_2FindUniqueArgsBase
      

  /**
   * location_type_2: findFirstOrThrow
   */
  export type location_type_2FindFirstOrThrowArgs = location_type_2FindFirstArgsBase
      

  /**
   * location_type_2 without action
   */
  export type location_type_2Args = {
    /**
     * Select specific fields to fetch from the location_type_2
     * 
    **/
    select?: location_type_2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: location_type_2Include | null
  }



  /**
   * Model vendors
   */


  export type AggregateVendors = {
    _count: VendorsCountAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
  }

  export type VendorsMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    isActive: boolean | null
  }

  export type VendorsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    isActive: boolean | null
  }

  export type VendorsCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    isActive: number
    _all: number
  }


  export type VendorsMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    isActive?: true
  }

  export type VendorsMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    isActive?: true
  }

  export type VendorsCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    isActive?: true
    _all?: true
  }

  export type VendorsAggregateArgs = {
    /**
     * Filter which vendors to aggregate.
     * 
    **/
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vendors
    **/
    _count?: true | VendorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorsMaxAggregateInputType
  }

  export type GetVendorsAggregateType<T extends VendorsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendors[P]>
      : GetScalarType<T[P], AggregateVendors[P]>
  }




  export type VendorsGroupByArgs = {
    where?: vendorsWhereInput
    orderBy?: Enumerable<vendorsOrderByWithAggregationInput>
    by: Array<VendorsScalarFieldEnum>
    having?: vendorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorsCountAggregateInputType | true
    _min?: VendorsMinAggregateInputType
    _max?: VendorsMaxAggregateInputType
  }


  export type VendorsGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    isActive: boolean | null
    _count: VendorsCountAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
  }

  type GetVendorsGroupByPayload<T extends VendorsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorsGroupByOutputType[P]>
            : GetScalarType<T[P], VendorsGroupByOutputType[P]>
        }
      >
    >


  export type vendorsSelect = {
    id?: boolean
    name?: boolean
    logo?: boolean
    isActive?: boolean
    commission_setting?: boolean | commission_settingFindManyArgs
    location?: boolean | locationFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | VendorsCountOutputTypeArgs
  }

  export type vendorsInclude = {
    commission_setting?: boolean | commission_settingFindManyArgs
    location?: boolean | locationFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | VendorsCountOutputTypeArgs
  }

  export type vendorsGetPayload<
    S extends boolean | null | undefined | vendorsArgs,
    U = keyof S
      > = S extends true
        ? vendors
    : S extends undefined
    ? never
    : S extends vendorsArgs | vendorsFindManyArgs
    ?'include' extends U
    ? vendors  & {
    [P in TrueKeys<S['include']>]:
        P extends 'commission_setting' ? Array < commission_settingGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'location' ? Array < locationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? VendorsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'commission_setting' ? Array < commission_settingGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'location' ? Array < locationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? VendorsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof vendors ? vendors[P] : never
  } 
    : vendors
  : vendors


  type vendorsCountArgs = Merge<
    Omit<vendorsFindManyArgs, 'select' | 'include'> & {
      select?: VendorsCountAggregateInputType | true
    }
  >

  export interface vendorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Vendors that matches the filter.
     * @param {vendorsFindUniqueArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vendorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vendorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vendors'> extends True ? CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>> : CheckSelect<T, Prisma__vendorsClient<vendors | null, null>, Prisma__vendorsClient<vendorsGetPayload<T> | null, null>>

    /**
     * Find the first Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindFirstArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vendorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vendorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vendors'> extends True ? CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>> : CheckSelect<T, Prisma__vendorsClient<vendors | null, null>, Prisma__vendorsClient<vendorsGetPayload<T> | null, null>>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendors.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorsWithIdOnly = await prisma.vendors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vendorsFindManyArgs>(
      args?: SelectSubset<T, vendorsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<vendors>>, PrismaPromise<Array<vendorsGetPayload<T>>>>

    /**
     * Create a Vendors.
     * @param {vendorsCreateArgs} args - Arguments to create a Vendors.
     * @example
     * // Create one Vendors
     * const Vendors = await prisma.vendors.create({
     *   data: {
     *     // ... data to create a Vendors
     *   }
     * })
     * 
    **/
    create<T extends vendorsCreateArgs>(
      args: SelectSubset<T, vendorsCreateArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Create many Vendors.
     *     @param {vendorsCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendors = await prisma.vendors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vendorsCreateManyArgs>(
      args?: SelectSubset<T, vendorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendors.
     * @param {vendorsDeleteArgs} args - Arguments to delete one Vendors.
     * @example
     * // Delete one Vendors
     * const Vendors = await prisma.vendors.delete({
     *   where: {
     *     // ... filter to delete one Vendors
     *   }
     * })
     * 
    **/
    delete<T extends vendorsDeleteArgs>(
      args: SelectSubset<T, vendorsDeleteArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Update one Vendors.
     * @param {vendorsUpdateArgs} args - Arguments to update one Vendors.
     * @example
     * // Update one Vendors
     * const vendors = await prisma.vendors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vendorsUpdateArgs>(
      args: SelectSubset<T, vendorsUpdateArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Delete zero or more Vendors.
     * @param {vendorsDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vendorsDeleteManyArgs>(
      args?: SelectSubset<T, vendorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendors = await prisma.vendors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vendorsUpdateManyArgs>(
      args: SelectSubset<T, vendorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendors.
     * @param {vendorsUpsertArgs} args - Arguments to update or create a Vendors.
     * @example
     * // Update or create a Vendors
     * const vendors = await prisma.vendors.upsert({
     *   create: {
     *     // ... data to create a Vendors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendors we want to update
     *   }
     * })
    **/
    upsert<T extends vendorsUpsertArgs>(
      args: SelectSubset<T, vendorsUpsertArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Find one Vendors that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {vendorsFindUniqueOrThrowArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vendorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vendorsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Find the first Vendors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindFirstOrThrowArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vendorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vendorsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__vendorsClient<vendors>, Prisma__vendorsClient<vendorsGetPayload<T>>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendors.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends vendorsCountArgs>(
      args?: Subset<T, vendorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorsAggregateArgs>(args: Subset<T, VendorsAggregateArgs>): PrismaPromise<GetVendorsAggregateType<T>>

    /**
     * Group by Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorsGroupByArgs['orderBy'] }
        : { orderBy?: VendorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vendors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vendorsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    commission_setting<T extends commission_settingFindManyArgs = {}>(args?: Subset<T, commission_settingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<commission_setting>| Null>, PrismaPromise<Array<commission_settingGetPayload<T>>| Null>>;

    location<T extends locationFindManyArgs = {}>(args?: Subset<T, locationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location>| Null>, PrismaPromise<Array<locationGetPayload<T>>| Null>>;

    reservation<T extends reservationFindManyArgs = {}>(args?: Subset<T, reservationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reservation>| Null>, PrismaPromise<Array<reservationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vendors base type for findUnique actions
   */
  export type vendorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     * 
    **/
    where: vendorsWhereUniqueInput
  }

  /**
   * vendors: findUnique
   */
  export interface vendorsFindUniqueArgs extends vendorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendors base type for findFirst actions
   */
  export type vendorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     * 
    **/
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendors.
     * 
    **/
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendors.
     * 
    **/
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }

  /**
   * vendors: findFirst
   */
  export interface vendorsFindFirstArgs extends vendorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendors findMany
   */
  export type vendorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     * 
    **/
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     * 
    **/
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vendors.
     * 
    **/
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * vendors create
   */
  export type vendorsCreateArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * The data needed to create a vendors.
     * 
    **/
    data: XOR<vendorsCreateInput, vendorsUncheckedCreateInput>
  }


  /**
   * vendors createMany
   */
  export type vendorsCreateManyArgs = {
    /**
     * The data used to create many vendors.
     * 
    **/
    data: Enumerable<vendorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vendors update
   */
  export type vendorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * The data needed to update a vendors.
     * 
    **/
    data: XOR<vendorsUpdateInput, vendorsUncheckedUpdateInput>
    /**
     * Choose, which vendors to update.
     * 
    **/
    where: vendorsWhereUniqueInput
  }


  /**
   * vendors updateMany
   */
  export type vendorsUpdateManyArgs = {
    /**
     * The data used to update vendors.
     * 
    **/
    data: XOR<vendorsUpdateManyMutationInput, vendorsUncheckedUpdateManyInput>
    /**
     * Filter which vendors to update
     * 
    **/
    where?: vendorsWhereInput
  }


  /**
   * vendors upsert
   */
  export type vendorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * The filter to search for the vendors to update in case it exists.
     * 
    **/
    where: vendorsWhereUniqueInput
    /**
     * In case the vendors found by the `where` argument doesn't exist, create a new vendors with this data.
     * 
    **/
    create: XOR<vendorsCreateInput, vendorsUncheckedCreateInput>
    /**
     * In case the vendors was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<vendorsUpdateInput, vendorsUncheckedUpdateInput>
  }


  /**
   * vendors delete
   */
  export type vendorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
    /**
     * Filter which vendors to delete.
     * 
    **/
    where: vendorsWhereUniqueInput
  }


  /**
   * vendors deleteMany
   */
  export type vendorsDeleteManyArgs = {
    /**
     * Filter which vendors to delete
     * 
    **/
    where?: vendorsWhereInput
  }


  /**
   * vendors: findUniqueOrThrow
   */
  export type vendorsFindUniqueOrThrowArgs = vendorsFindUniqueArgsBase
      

  /**
   * vendors: findFirstOrThrow
   */
  export type vendorsFindFirstOrThrowArgs = vendorsFindFirstArgsBase
      

  /**
   * vendors without action
   */
  export type vendorsArgs = {
    /**
     * Select specific fields to fetch from the vendors
     * 
    **/
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vendorsInclude | null
  }



  /**
   * Model airports
   */


  export type AggregateAirports = {
    _count: AirportsCountAggregateOutputType | null
    _avg: AirportsAvgAggregateOutputType | null
    _sum: AirportsSumAggregateOutputType | null
    _min: AirportsMinAggregateOutputType | null
    _max: AirportsMaxAggregateOutputType | null
  }

  export type AirportsAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    id: number | null
  }

  export type AirportsSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    id: number | null
  }

  export type AirportsMinAggregateOutputType = {
    iata_code: string | null
    country_code: string | null
    icao_code: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
    id: number | null
  }

  export type AirportsMaxAggregateOutputType = {
    iata_code: string | null
    country_code: string | null
    icao_code: string | null
    name: string | null
    latitude: number | null
    longitude: number | null
    id: number | null
  }

  export type AirportsCountAggregateOutputType = {
    iata_code: number
    country_code: number
    icao_code: number
    name: number
    latitude: number
    longitude: number
    id: number
    _all: number
  }


  export type AirportsAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    id?: true
  }

  export type AirportsSumAggregateInputType = {
    latitude?: true
    longitude?: true
    id?: true
  }

  export type AirportsMinAggregateInputType = {
    iata_code?: true
    country_code?: true
    icao_code?: true
    name?: true
    latitude?: true
    longitude?: true
    id?: true
  }

  export type AirportsMaxAggregateInputType = {
    iata_code?: true
    country_code?: true
    icao_code?: true
    name?: true
    latitude?: true
    longitude?: true
    id?: true
  }

  export type AirportsCountAggregateInputType = {
    iata_code?: true
    country_code?: true
    icao_code?: true
    name?: true
    latitude?: true
    longitude?: true
    id?: true
    _all?: true
  }

  export type AirportsAggregateArgs = {
    /**
     * Filter which airports to aggregate.
     * 
    **/
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     * 
    **/
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned airports
    **/
    _count?: true | AirportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirportsMaxAggregateInputType
  }

  export type GetAirportsAggregateType<T extends AirportsAggregateArgs> = {
        [P in keyof T & keyof AggregateAirports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirports[P]>
      : GetScalarType<T[P], AggregateAirports[P]>
  }




  export type AirportsGroupByArgs = {
    where?: airportsWhereInput
    orderBy?: Enumerable<airportsOrderByWithAggregationInput>
    by: Array<AirportsScalarFieldEnum>
    having?: airportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirportsCountAggregateInputType | true
    _avg?: AirportsAvgAggregateInputType
    _sum?: AirportsSumAggregateInputType
    _min?: AirportsMinAggregateInputType
    _max?: AirportsMaxAggregateInputType
  }


  export type AirportsGroupByOutputType = {
    iata_code: string
    country_code: string | null
    icao_code: string
    name: string
    latitude: number
    longitude: number
    id: number
    _count: AirportsCountAggregateOutputType | null
    _avg: AirportsAvgAggregateOutputType | null
    _sum: AirportsSumAggregateOutputType | null
    _min: AirportsMinAggregateOutputType | null
    _max: AirportsMaxAggregateOutputType | null
  }

  type GetAirportsGroupByPayload<T extends AirportsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AirportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirportsGroupByOutputType[P]>
            : GetScalarType<T[P], AirportsGroupByOutputType[P]>
        }
      >
    >


  export type airportsSelect = {
    iata_code?: boolean
    country_code?: boolean
    icao_code?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    id?: boolean
    countries?: boolean | countriesArgs
  }

  export type airportsInclude = {
    countries?: boolean | countriesArgs
  }

  export type airportsGetPayload<
    S extends boolean | null | undefined | airportsArgs,
    U = keyof S
      > = S extends true
        ? airports
    : S extends undefined
    ? never
    : S extends airportsArgs | airportsFindManyArgs
    ?'include' extends U
    ? airports  & {
    [P in TrueKeys<S['include']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'countries' ? countriesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof airports ? airports[P] : never
  } 
    : airports
  : airports


  type airportsCountArgs = Merge<
    Omit<airportsFindManyArgs, 'select' | 'include'> & {
      select?: AirportsCountAggregateInputType | true
    }
  >

  export interface airportsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Airports that matches the filter.
     * @param {airportsFindUniqueArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends airportsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, airportsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'airports'> extends True ? CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>> : CheckSelect<T, Prisma__airportsClient<airports | null, null>, Prisma__airportsClient<airportsGetPayload<T> | null, null>>

    /**
     * Find the first Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindFirstArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends airportsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, airportsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'airports'> extends True ? CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>> : CheckSelect<T, Prisma__airportsClient<airports | null, null>, Prisma__airportsClient<airportsGetPayload<T> | null, null>>

    /**
     * Find zero or more Airports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Airports
     * const airports = await prisma.airports.findMany()
     * 
     * // Get first 10 Airports
     * const airports = await prisma.airports.findMany({ take: 10 })
     * 
     * // Only select the `iata_code`
     * const airportsWithIata_codeOnly = await prisma.airports.findMany({ select: { iata_code: true } })
     * 
    **/
    findMany<T extends airportsFindManyArgs>(
      args?: SelectSubset<T, airportsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<airports>>, PrismaPromise<Array<airportsGetPayload<T>>>>

    /**
     * Create a Airports.
     * @param {airportsCreateArgs} args - Arguments to create a Airports.
     * @example
     * // Create one Airports
     * const Airports = await prisma.airports.create({
     *   data: {
     *     // ... data to create a Airports
     *   }
     * })
     * 
    **/
    create<T extends airportsCreateArgs>(
      args: SelectSubset<T, airportsCreateArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Create many Airports.
     *     @param {airportsCreateManyArgs} args - Arguments to create many Airports.
     *     @example
     *     // Create many Airports
     *     const airports = await prisma.airports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends airportsCreateManyArgs>(
      args?: SelectSubset<T, airportsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Airports.
     * @param {airportsDeleteArgs} args - Arguments to delete one Airports.
     * @example
     * // Delete one Airports
     * const Airports = await prisma.airports.delete({
     *   where: {
     *     // ... filter to delete one Airports
     *   }
     * })
     * 
    **/
    delete<T extends airportsDeleteArgs>(
      args: SelectSubset<T, airportsDeleteArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Update one Airports.
     * @param {airportsUpdateArgs} args - Arguments to update one Airports.
     * @example
     * // Update one Airports
     * const airports = await prisma.airports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends airportsUpdateArgs>(
      args: SelectSubset<T, airportsUpdateArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Delete zero or more Airports.
     * @param {airportsDeleteManyArgs} args - Arguments to filter Airports to delete.
     * @example
     * // Delete a few Airports
     * const { count } = await prisma.airports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends airportsDeleteManyArgs>(
      args?: SelectSubset<T, airportsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Airports
     * const airports = await prisma.airports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends airportsUpdateManyArgs>(
      args: SelectSubset<T, airportsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Airports.
     * @param {airportsUpsertArgs} args - Arguments to update or create a Airports.
     * @example
     * // Update or create a Airports
     * const airports = await prisma.airports.upsert({
     *   create: {
     *     // ... data to create a Airports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Airports we want to update
     *   }
     * })
    **/
    upsert<T extends airportsUpsertArgs>(
      args: SelectSubset<T, airportsUpsertArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Find one Airports that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {airportsFindUniqueOrThrowArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends airportsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, airportsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Find the first Airports that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsFindFirstOrThrowArgs} args - Arguments to find a Airports
     * @example
     * // Get one Airports
     * const airports = await prisma.airports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends airportsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, airportsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__airportsClient<airports>, Prisma__airportsClient<airportsGetPayload<T>>>

    /**
     * Count the number of Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {airportsCountArgs} args - Arguments to filter Airports to count.
     * @example
     * // Count the number of Airports
     * const count = await prisma.airports.count({
     *   where: {
     *     // ... the filter for the Airports we want to count
     *   }
     * })
    **/
    count<T extends airportsCountArgs>(
      args?: Subset<T, airportsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirportsAggregateArgs>(args: Subset<T, AirportsAggregateArgs>): PrismaPromise<GetAirportsAggregateType<T>>

    /**
     * Group by Airports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirportsGroupByArgs['orderBy'] }
        : { orderBy?: AirportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirportsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for airports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__airportsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    countries<T extends countriesArgs = {}>(args?: Subset<T, countriesArgs>): CheckSelect<T, Prisma__countriesClient<countries | Null>, Prisma__countriesClient<countriesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * airports base type for findUnique actions
   */
  export type airportsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * Filter, which airports to fetch.
     * 
    **/
    where: airportsWhereUniqueInput
  }

  /**
   * airports: findUnique
   */
  export interface airportsFindUniqueArgs extends airportsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airports base type for findFirst actions
   */
  export type airportsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * Filter, which airports to fetch.
     * 
    **/
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     * 
    **/
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for airports.
     * 
    **/
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of airports.
     * 
    **/
    distinct?: Enumerable<AirportsScalarFieldEnum>
  }

  /**
   * airports: findFirst
   */
  export interface airportsFindFirstArgs extends airportsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * airports findMany
   */
  export type airportsFindManyArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * Filter, which airports to fetch.
     * 
    **/
    where?: airportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of airports to fetch.
     * 
    **/
    orderBy?: Enumerable<airportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing airports.
     * 
    **/
    cursor?: airportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` airports from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` airports.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AirportsScalarFieldEnum>
  }


  /**
   * airports create
   */
  export type airportsCreateArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * The data needed to create a airports.
     * 
    **/
    data: XOR<airportsCreateInput, airportsUncheckedCreateInput>
  }


  /**
   * airports createMany
   */
  export type airportsCreateManyArgs = {
    /**
     * The data used to create many airports.
     * 
    **/
    data: Enumerable<airportsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * airports update
   */
  export type airportsUpdateArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * The data needed to update a airports.
     * 
    **/
    data: XOR<airportsUpdateInput, airportsUncheckedUpdateInput>
    /**
     * Choose, which airports to update.
     * 
    **/
    where: airportsWhereUniqueInput
  }


  /**
   * airports updateMany
   */
  export type airportsUpdateManyArgs = {
    /**
     * The data used to update airports.
     * 
    **/
    data: XOR<airportsUpdateManyMutationInput, airportsUncheckedUpdateManyInput>
    /**
     * Filter which airports to update
     * 
    **/
    where?: airportsWhereInput
  }


  /**
   * airports upsert
   */
  export type airportsUpsertArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * The filter to search for the airports to update in case it exists.
     * 
    **/
    where: airportsWhereUniqueInput
    /**
     * In case the airports found by the `where` argument doesn't exist, create a new airports with this data.
     * 
    **/
    create: XOR<airportsCreateInput, airportsUncheckedCreateInput>
    /**
     * In case the airports was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<airportsUpdateInput, airportsUncheckedUpdateInput>
  }


  /**
   * airports delete
   */
  export type airportsDeleteArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
    /**
     * Filter which airports to delete.
     * 
    **/
    where: airportsWhereUniqueInput
  }


  /**
   * airports deleteMany
   */
  export type airportsDeleteManyArgs = {
    /**
     * Filter which airports to delete
     * 
    **/
    where?: airportsWhereInput
  }


  /**
   * airports: findUniqueOrThrow
   */
  export type airportsFindUniqueOrThrowArgs = airportsFindUniqueArgsBase
      

  /**
   * airports: findFirstOrThrow
   */
  export type airportsFindFirstOrThrowArgs = airportsFindFirstArgsBase
      

  /**
   * airports without action
   */
  export type airportsArgs = {
    /**
     * Select specific fields to fetch from the airports
     * 
    **/
    select?: airportsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: airportsInclude | null
  }



  /**
   * Model categories
   */


  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    _all: number
  }


  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    _all?: true
  }

  export type CategoriesAggregateArgs = {
    /**
     * Filter which categories to aggregate.
     * 
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type CategoriesGroupByArgs = {
    where?: categoriesWhereInput
    orderBy?: Enumerable<categoriesOrderByWithAggregationInput>
    by: Array<CategoriesScalarFieldEnum>
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }


  export type CategoriesGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends CategoriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect = {
    id?: boolean
    name?: boolean
    icon?: boolean
    location?: boolean | locationFindManyArgs
    _count?: boolean | CategoriesCountOutputTypeArgs
  }

  export type categoriesInclude = {
    location?: boolean | locationFindManyArgs
    _count?: boolean | CategoriesCountOutputTypeArgs
  }

  export type categoriesGetPayload<
    S extends boolean | null | undefined | categoriesArgs,
    U = keyof S
      > = S extends true
        ? categories
    : S extends undefined
    ? never
    : S extends categoriesArgs | categoriesFindManyArgs
    ?'include' extends U
    ? categories  & {
    [P in TrueKeys<S['include']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CategoriesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'location' ? Array < locationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CategoriesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof categories ? categories[P] : never
  } 
    : categories
  : categories


  type categoriesCountArgs = Merge<
    Omit<categoriesFindManyArgs, 'select' | 'include'> & {
      select?: CategoriesCountAggregateInputType | true
    }
  >

  export interface categoriesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'categories'> extends True ? CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>> : CheckSelect<T, Prisma__categoriesClient<categories | null, null>, Prisma__categoriesClient<categoriesGetPayload<T> | null, null>>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'categories'> extends True ? CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>> : CheckSelect<T, Prisma__categoriesClient<categories | null, null>, Prisma__categoriesClient<categoriesGetPayload<T> | null, null>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoriesFindManyArgs>(
      args?: SelectSubset<T, categoriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<categories>>, PrismaPromise<Array<categoriesGetPayload<T>>>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
    **/
    create<T extends categoriesCreateArgs>(
      args: SelectSubset<T, categoriesCreateArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Create many Categories.
     *     @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const categories = await prisma.categories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoriesCreateManyArgs>(
      args?: SelectSubset<T, categoriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
    **/
    delete<T extends categoriesDeleteArgs>(
      args: SelectSubset<T, categoriesDeleteArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoriesUpdateArgs>(
      args: SelectSubset<T, categoriesUpdateArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoriesDeleteManyArgs>(
      args?: SelectSubset<T, categoriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoriesUpdateManyArgs>(
      args: SelectSubset<T, categoriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
    **/
    upsert<T extends categoriesUpsertArgs>(
      args: SelectSubset<T, categoriesUpsertArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Find one Categories that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, categoriesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Find the first Categories that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, categoriesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__categoriesClient<categories>, Prisma__categoriesClient<categoriesGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriesGroupByArgs['orderBy'] }
        : { orderBy?: CategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoriesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    location<T extends locationFindManyArgs = {}>(args?: Subset<T, locationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<location>| Null>, PrismaPromise<Array<locationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * categories base type for findUnique actions
   */
  export type categoriesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * Filter, which categories to fetch.
     * 
    **/
    where: categoriesWhereUniqueInput
  }

  /**
   * categories: findUnique
   */
  export interface categoriesFindUniqueArgs extends categoriesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categories base type for findFirst actions
   */
  export type categoriesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * Filter, which categories to fetch.
     * 
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     * 
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     * 
    **/
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }

  /**
   * categories: findFirst
   */
  export interface categoriesFindFirstArgs extends categoriesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * Filter, which categories to fetch.
     * 
    **/
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     * 
    **/
    orderBy?: Enumerable<categoriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     * 
    **/
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriesScalarFieldEnum>
  }


  /**
   * categories create
   */
  export type categoriesCreateArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * The data needed to create a categories.
     * 
    **/
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }


  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs = {
    /**
     * The data used to create many categories.
     * 
    **/
    data: Enumerable<categoriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * categories update
   */
  export type categoriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * The data needed to update a categories.
     * 
    **/
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     * 
    **/
    where: categoriesWhereUniqueInput
  }


  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs = {
    /**
     * The data used to update categories.
     * 
    **/
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     * 
    **/
    where?: categoriesWhereInput
  }


  /**
   * categories upsert
   */
  export type categoriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * The filter to search for the categories to update in case it exists.
     * 
    **/
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     * 
    **/
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }


  /**
   * categories delete
   */
  export type categoriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
    /**
     * Filter which categories to delete.
     * 
    **/
    where: categoriesWhereUniqueInput
  }


  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs = {
    /**
     * Filter which categories to delete
     * 
    **/
    where?: categoriesWhereInput
  }


  /**
   * categories: findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs = categoriesFindUniqueArgsBase
      

  /**
   * categories: findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs = categoriesFindFirstArgsBase
      

  /**
   * categories without action
   */
  export type categoriesArgs = {
    /**
     * Select specific fields to fetch from the categories
     * 
    **/
    select?: categoriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: categoriesInclude | null
  }



  /**
   * Model payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    user_id: number | null
    IMS_commission: Decimal | null
    exchange_rate: Decimal | null
    paid_agency: Decimal | null
    paid_supplier: Decimal | null
    basic_rate: Decimal | null
    net: Decimal | null
    commission: Decimal | null
    service_total_amount: Decimal | null
    service_rate: Decimal | null
    etc_rate: Decimal | null
    total_amount: Decimal | null
    pg_amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    user_id: number | null
    IMS_commission: Decimal | null
    exchange_rate: Decimal | null
    paid_agency: Decimal | null
    paid_supplier: Decimal | null
    basic_rate: Decimal | null
    net: Decimal | null
    commission: Decimal | null
    service_total_amount: Decimal | null
    service_rate: Decimal | null
    etc_rate: Decimal | null
    total_amount: Decimal | null
    pg_amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    order_id: string | null
    user_id: number | null
    IMS_commission: Decimal | null
    agency_id: string | null
    agency_name: string | null
    pay_type: string | null
    exchange_rate: Decimal | null
    first_name: string | null
    korean_name: string | null
    last_name: string | null
    paid_agency: Decimal | null
    paid_supplier_date: Date | null
    paid_supplier: Decimal | null
    basic_rate: Decimal | null
    net: Decimal | null
    commission: Decimal | null
    currency: string | null
    service_total_amount: Decimal | null
    service_rate: Decimal | null
    reservation_id: string | null
    supplier: string | null
    imp_uid: string | null
    merchant_uid: string | null
    etc_rate: Decimal | null
    total_amount: Decimal | null
    pg_amount: Decimal | null
    paid_agency_date: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    order_id: string | null
    user_id: number | null
    IMS_commission: Decimal | null
    agency_id: string | null
    agency_name: string | null
    pay_type: string | null
    exchange_rate: Decimal | null
    first_name: string | null
    korean_name: string | null
    last_name: string | null
    paid_agency: Decimal | null
    paid_supplier_date: Date | null
    paid_supplier: Decimal | null
    basic_rate: Decimal | null
    net: Decimal | null
    commission: Decimal | null
    currency: string | null
    service_total_amount: Decimal | null
    service_rate: Decimal | null
    reservation_id: string | null
    supplier: string | null
    imp_uid: string | null
    merchant_uid: string | null
    etc_rate: Decimal | null
    total_amount: Decimal | null
    pg_amount: Decimal | null
    paid_agency_date: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    order_id: number
    user_id: number
    IMS_commission: number
    agency_id: number
    agency_name: number
    pay_type: number
    exchange_rate: number
    first_name: number
    korean_name: number
    last_name: number
    paid_agency: number
    paid_supplier_date: number
    paid_supplier: number
    basic_rate: number
    net: number
    commission: number
    currency: number
    service_total_amount: number
    service_rate: number
    reservation_id: number
    supplier: number
    imp_uid: number
    merchant_uid: number
    etc_rate: number
    total_amount: number
    pg_amount: number
    paid_agency_date: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    user_id?: true
    IMS_commission?: true
    exchange_rate?: true
    paid_agency?: true
    paid_supplier?: true
    basic_rate?: true
    net?: true
    commission?: true
    service_total_amount?: true
    service_rate?: true
    etc_rate?: true
    total_amount?: true
    pg_amount?: true
  }

  export type PaymentSumAggregateInputType = {
    user_id?: true
    IMS_commission?: true
    exchange_rate?: true
    paid_agency?: true
    paid_supplier?: true
    basic_rate?: true
    net?: true
    commission?: true
    service_total_amount?: true
    service_rate?: true
    etc_rate?: true
    total_amount?: true
    pg_amount?: true
  }

  export type PaymentMinAggregateInputType = {
    order_id?: true
    user_id?: true
    IMS_commission?: true
    agency_id?: true
    agency_name?: true
    pay_type?: true
    exchange_rate?: true
    first_name?: true
    korean_name?: true
    last_name?: true
    paid_agency?: true
    paid_supplier_date?: true
    paid_supplier?: true
    basic_rate?: true
    net?: true
    commission?: true
    currency?: true
    service_total_amount?: true
    service_rate?: true
    reservation_id?: true
    supplier?: true
    imp_uid?: true
    merchant_uid?: true
    etc_rate?: true
    total_amount?: true
    pg_amount?: true
    paid_agency_date?: true
  }

  export type PaymentMaxAggregateInputType = {
    order_id?: true
    user_id?: true
    IMS_commission?: true
    agency_id?: true
    agency_name?: true
    pay_type?: true
    exchange_rate?: true
    first_name?: true
    korean_name?: true
    last_name?: true
    paid_agency?: true
    paid_supplier_date?: true
    paid_supplier?: true
    basic_rate?: true
    net?: true
    commission?: true
    currency?: true
    service_total_amount?: true
    service_rate?: true
    reservation_id?: true
    supplier?: true
    imp_uid?: true
    merchant_uid?: true
    etc_rate?: true
    total_amount?: true
    pg_amount?: true
    paid_agency_date?: true
  }

  export type PaymentCountAggregateInputType = {
    order_id?: true
    user_id?: true
    IMS_commission?: true
    agency_id?: true
    agency_name?: true
    pay_type?: true
    exchange_rate?: true
    first_name?: true
    korean_name?: true
    last_name?: true
    paid_agency?: true
    paid_supplier_date?: true
    paid_supplier?: true
    basic_rate?: true
    net?: true
    commission?: true
    currency?: true
    service_total_amount?: true
    service_rate?: true
    reservation_id?: true
    supplier?: true
    imp_uid?: true
    merchant_uid?: true
    etc_rate?: true
    total_amount?: true
    pg_amount?: true
    paid_agency_date?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which payment to aggregate.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithAggregationInput>
    by: Array<PaymentScalarFieldEnum>
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    order_id: string
    user_id: number | null
    IMS_commission: Decimal | null
    agency_id: string | null
    agency_name: string | null
    pay_type: string | null
    exchange_rate: Decimal | null
    first_name: string | null
    korean_name: string | null
    last_name: string | null
    paid_agency: Decimal | null
    paid_supplier_date: Date | null
    paid_supplier: Decimal | null
    basic_rate: Decimal | null
    net: Decimal | null
    commission: Decimal | null
    currency: string | null
    service_total_amount: Decimal | null
    service_rate: Decimal | null
    reservation_id: string | null
    supplier: string | null
    imp_uid: string | null
    merchant_uid: string | null
    etc_rate: Decimal | null
    total_amount: Decimal | null
    pg_amount: Decimal | null
    paid_agency_date: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect = {
    order_id?: boolean
    user_id?: boolean
    IMS_commission?: boolean
    agency_id?: boolean
    agency_name?: boolean
    pay_type?: boolean
    exchange_rate?: boolean
    first_name?: boolean
    korean_name?: boolean
    last_name?: boolean
    paid_agency?: boolean
    paid_supplier_date?: boolean
    paid_supplier?: boolean
    basic_rate?: boolean
    net?: boolean
    commission?: boolean
    currency?: boolean
    service_total_amount?: boolean
    service_rate?: boolean
    reservation_id?: boolean
    supplier?: boolean
    imp_uid?: boolean
    merchant_uid?: boolean
    etc_rate?: boolean
    total_amount?: boolean
    pg_amount?: boolean
    paid_agency_date?: boolean
    reservation?: boolean | reservationArgs
    users?: boolean | usersArgs
  }

  export type paymentInclude = {
    reservation?: boolean | reservationArgs
    users?: boolean | usersArgs
  }

  export type paymentGetPayload<
    S extends boolean | null | undefined | paymentArgs,
    U = keyof S
      > = S extends true
        ? payment
    : S extends undefined
    ? never
    : S extends paymentArgs | paymentFindManyArgs
    ?'include' extends U
    ? payment  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reservation' ? reservationGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'users' ? usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reservation' ? reservationGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'users' ? usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof payment ? payment[P] : never
  } 
    : payment
  : payment


  type paymentCountArgs = Merge<
    Omit<paymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface paymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment'> extends True ? CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>> : CheckSelect<T, Prisma__paymentClient<payment | null, null>, Prisma__paymentClient<paymentGetPayload<T> | null, null>>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment'> extends True ? CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>> : CheckSelect<T, Prisma__paymentClient<payment | null, null>, Prisma__paymentClient<paymentGetPayload<T> | null, null>>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const paymentWithOrder_idOnly = await prisma.payment.findMany({ select: { order_id: true } })
     * 
    **/
    findMany<T extends paymentFindManyArgs>(
      args?: SelectSubset<T, paymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<payment>>, PrismaPromise<Array<paymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends paymentCreateArgs>(
      args: SelectSubset<T, paymentCreateArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paymentCreateManyArgs>(
      args?: SelectSubset<T, paymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends paymentDeleteArgs>(
      args: SelectSubset<T, paymentDeleteArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paymentUpdateArgs>(
      args: SelectSubset<T, paymentUpdateArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paymentDeleteManyArgs>(
      args?: SelectSubset<T, paymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paymentUpdateManyArgs>(
      args: SelectSubset<T, paymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends paymentUpsertArgs>(
      args: SelectSubset<T, paymentUpsertArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Find one Payment that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paymentFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paymentFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__paymentClient<payment>, Prisma__paymentClient<paymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paymentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservation<T extends reservationArgs = {}>(args?: Subset<T, reservationArgs>): CheckSelect<T, Prisma__reservationClient<reservation | Null>, Prisma__reservationClient<reservationGetPayload<T> | Null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | Null>, Prisma__usersClient<usersGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payment base type for findUnique actions
   */
  export type paymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     * 
    **/
    where: paymentWhereUniqueInput
  }

  /**
   * payment: findUnique
   */
  export interface paymentFindUniqueArgs extends paymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment base type for findFirst actions
   */
  export type paymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     * 
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * payment: findFirst
   */
  export interface paymentFindFirstArgs extends paymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findMany
   */
  export type paymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * Filter, which payments to fetch.
     * 
    **/
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     * 
    **/
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     * 
    **/
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment create
   */
  export type paymentCreateArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * The data needed to create a payment.
     * 
    **/
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }


  /**
   * payment createMany
   */
  export type paymentCreateManyArgs = {
    /**
     * The data used to create many payments.
     * 
    **/
    data: Enumerable<paymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payment update
   */
  export type paymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * The data needed to update a payment.
     * 
    **/
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     * 
    **/
    where: paymentWhereUniqueInput
  }


  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs = {
    /**
     * The data used to update payments.
     * 
    **/
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     * 
    **/
    where?: paymentWhereInput
  }


  /**
   * payment upsert
   */
  export type paymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * The filter to search for the payment to update in case it exists.
     * 
    **/
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     * 
    **/
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }


  /**
   * payment delete
   */
  export type paymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
    /**
     * Filter which payment to delete.
     * 
    **/
    where: paymentWhereUniqueInput
  }


  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs = {
    /**
     * Filter which payments to delete
     * 
    **/
    where?: paymentWhereInput
  }


  /**
   * payment: findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs = paymentFindUniqueArgsBase
      

  /**
   * payment: findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs = paymentFindFirstArgsBase
      

  /**
   * payment without action
   */
  export type paymentArgs = {
    /**
     * Select specific fields to fetch from the payment
     * 
    **/
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: paymentInclude | null
  }



  /**
   * Model exchange_rates
   */


  export type AggregateExchange_rates = {
    _count: Exchange_ratesCountAggregateOutputType | null
    _avg: Exchange_ratesAvgAggregateOutputType | null
    _sum: Exchange_ratesSumAggregateOutputType | null
    _min: Exchange_ratesMinAggregateOutputType | null
    _max: Exchange_ratesMaxAggregateOutputType | null
  }

  export type Exchange_ratesAvgAggregateOutputType = {
    id: number | null
    rate: number | null
  }

  export type Exchange_ratesSumAggregateOutputType = {
    id: number | null
    rate: number | null
  }

  export type Exchange_ratesMinAggregateOutputType = {
    id: number | null
    from_code: string | null
    to_code: string | null
    rate: number | null
  }

  export type Exchange_ratesMaxAggregateOutputType = {
    id: number | null
    from_code: string | null
    to_code: string | null
    rate: number | null
  }

  export type Exchange_ratesCountAggregateOutputType = {
    id: number
    from_code: number
    to_code: number
    rate: number
    _all: number
  }


  export type Exchange_ratesAvgAggregateInputType = {
    id?: true
    rate?: true
  }

  export type Exchange_ratesSumAggregateInputType = {
    id?: true
    rate?: true
  }

  export type Exchange_ratesMinAggregateInputType = {
    id?: true
    from_code?: true
    to_code?: true
    rate?: true
  }

  export type Exchange_ratesMaxAggregateInputType = {
    id?: true
    from_code?: true
    to_code?: true
    rate?: true
  }

  export type Exchange_ratesCountAggregateInputType = {
    id?: true
    from_code?: true
    to_code?: true
    rate?: true
    _all?: true
  }

  export type Exchange_ratesAggregateArgs = {
    /**
     * Filter which exchange_rates to aggregate.
     * 
    **/
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_ratesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exchange_rates
    **/
    _count?: true | Exchange_ratesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exchange_ratesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exchange_ratesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exchange_ratesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exchange_ratesMaxAggregateInputType
  }

  export type GetExchange_ratesAggregateType<T extends Exchange_ratesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchange_rates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchange_rates[P]>
      : GetScalarType<T[P], AggregateExchange_rates[P]>
  }




  export type Exchange_ratesGroupByArgs = {
    where?: exchange_ratesWhereInput
    orderBy?: Enumerable<exchange_ratesOrderByWithAggregationInput>
    by: Array<Exchange_ratesScalarFieldEnum>
    having?: exchange_ratesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exchange_ratesCountAggregateInputType | true
    _avg?: Exchange_ratesAvgAggregateInputType
    _sum?: Exchange_ratesSumAggregateInputType
    _min?: Exchange_ratesMinAggregateInputType
    _max?: Exchange_ratesMaxAggregateInputType
  }


  export type Exchange_ratesGroupByOutputType = {
    id: number
    from_code: string
    to_code: string
    rate: number
    _count: Exchange_ratesCountAggregateOutputType | null
    _avg: Exchange_ratesAvgAggregateOutputType | null
    _sum: Exchange_ratesSumAggregateOutputType | null
    _min: Exchange_ratesMinAggregateOutputType | null
    _max: Exchange_ratesMaxAggregateOutputType | null
  }

  type GetExchange_ratesGroupByPayload<T extends Exchange_ratesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Exchange_ratesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exchange_ratesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exchange_ratesGroupByOutputType[P]>
            : GetScalarType<T[P], Exchange_ratesGroupByOutputType[P]>
        }
      >
    >


  export type exchange_ratesSelect = {
    id?: boolean
    from_code?: boolean
    to_code?: boolean
    rate?: boolean
    exchange_rate_history?: boolean | exchange_rate_historyFindManyArgs
    _count?: boolean | Exchange_ratesCountOutputTypeArgs
  }

  export type exchange_ratesInclude = {
    exchange_rate_history?: boolean | exchange_rate_historyFindManyArgs
    _count?: boolean | Exchange_ratesCountOutputTypeArgs
  }

  export type exchange_ratesGetPayload<
    S extends boolean | null | undefined | exchange_ratesArgs,
    U = keyof S
      > = S extends true
        ? exchange_rates
    : S extends undefined
    ? never
    : S extends exchange_ratesArgs | exchange_ratesFindManyArgs
    ?'include' extends U
    ? exchange_rates  & {
    [P in TrueKeys<S['include']>]:
        P extends 'exchange_rate_history' ? Array < exchange_rate_historyGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Exchange_ratesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'exchange_rate_history' ? Array < exchange_rate_historyGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Exchange_ratesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof exchange_rates ? exchange_rates[P] : never
  } 
    : exchange_rates
  : exchange_rates


  type exchange_ratesCountArgs = Merge<
    Omit<exchange_ratesFindManyArgs, 'select' | 'include'> & {
      select?: Exchange_ratesCountAggregateInputType | true
    }
  >

  export interface exchange_ratesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Exchange_rates that matches the filter.
     * @param {exchange_ratesFindUniqueArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends exchange_ratesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, exchange_ratesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exchange_rates'> extends True ? CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>> : CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates | null, null>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T> | null, null>>

    /**
     * Find the first Exchange_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindFirstArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends exchange_ratesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, exchange_ratesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exchange_rates'> extends True ? CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>> : CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates | null, null>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T> | null, null>>

    /**
     * Find zero or more Exchange_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findMany()
     * 
     * // Get first 10 Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchange_ratesWithIdOnly = await prisma.exchange_rates.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends exchange_ratesFindManyArgs>(
      args?: SelectSubset<T, exchange_ratesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exchange_rates>>, PrismaPromise<Array<exchange_ratesGetPayload<T>>>>

    /**
     * Create a Exchange_rates.
     * @param {exchange_ratesCreateArgs} args - Arguments to create a Exchange_rates.
     * @example
     * // Create one Exchange_rates
     * const Exchange_rates = await prisma.exchange_rates.create({
     *   data: {
     *     // ... data to create a Exchange_rates
     *   }
     * })
     * 
    **/
    create<T extends exchange_ratesCreateArgs>(
      args: SelectSubset<T, exchange_ratesCreateArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Create many Exchange_rates.
     *     @param {exchange_ratesCreateManyArgs} args - Arguments to create many Exchange_rates.
     *     @example
     *     // Create many Exchange_rates
     *     const exchange_rates = await prisma.exchange_rates.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends exchange_ratesCreateManyArgs>(
      args?: SelectSubset<T, exchange_ratesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exchange_rates.
     * @param {exchange_ratesDeleteArgs} args - Arguments to delete one Exchange_rates.
     * @example
     * // Delete one Exchange_rates
     * const Exchange_rates = await prisma.exchange_rates.delete({
     *   where: {
     *     // ... filter to delete one Exchange_rates
     *   }
     * })
     * 
    **/
    delete<T extends exchange_ratesDeleteArgs>(
      args: SelectSubset<T, exchange_ratesDeleteArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Update one Exchange_rates.
     * @param {exchange_ratesUpdateArgs} args - Arguments to update one Exchange_rates.
     * @example
     * // Update one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends exchange_ratesUpdateArgs>(
      args: SelectSubset<T, exchange_ratesUpdateArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Delete zero or more Exchange_rates.
     * @param {exchange_ratesDeleteManyArgs} args - Arguments to filter Exchange_rates to delete.
     * @example
     * // Delete a few Exchange_rates
     * const { count } = await prisma.exchange_rates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends exchange_ratesDeleteManyArgs>(
      args?: SelectSubset<T, exchange_ratesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends exchange_ratesUpdateManyArgs>(
      args: SelectSubset<T, exchange_ratesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exchange_rates.
     * @param {exchange_ratesUpsertArgs} args - Arguments to update or create a Exchange_rates.
     * @example
     * // Update or create a Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.upsert({
     *   create: {
     *     // ... data to create a Exchange_rates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchange_rates we want to update
     *   }
     * })
    **/
    upsert<T extends exchange_ratesUpsertArgs>(
      args: SelectSubset<T, exchange_ratesUpsertArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Find one Exchange_rates that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {exchange_ratesFindUniqueOrThrowArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends exchange_ratesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, exchange_ratesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Find the first Exchange_rates that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindFirstOrThrowArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends exchange_ratesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exchange_ratesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T>>>

    /**
     * Count the number of Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesCountArgs} args - Arguments to filter Exchange_rates to count.
     * @example
     * // Count the number of Exchange_rates
     * const count = await prisma.exchange_rates.count({
     *   where: {
     *     // ... the filter for the Exchange_rates we want to count
     *   }
     * })
    **/
    count<T extends exchange_ratesCountArgs>(
      args?: Subset<T, exchange_ratesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exchange_ratesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exchange_ratesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exchange_ratesAggregateArgs>(args: Subset<T, Exchange_ratesAggregateArgs>): PrismaPromise<GetExchange_ratesAggregateType<T>>

    /**
     * Group by Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exchange_ratesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Exchange_ratesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Exchange_ratesGroupByArgs['orderBy'] }
        : { orderBy?: Exchange_ratesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Exchange_ratesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchange_ratesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for exchange_rates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__exchange_ratesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    exchange_rate_history<T extends exchange_rate_historyFindManyArgs = {}>(args?: Subset<T, exchange_rate_historyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<exchange_rate_history>| Null>, PrismaPromise<Array<exchange_rate_historyGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * exchange_rates base type for findUnique actions
   */
  export type exchange_ratesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * Filter, which exchange_rates to fetch.
     * 
    **/
    where: exchange_ratesWhereUniqueInput
  }

  /**
   * exchange_rates: findUnique
   */
  export interface exchange_ratesFindUniqueArgs extends exchange_ratesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchange_rates base type for findFirst actions
   */
  export type exchange_ratesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * Filter, which exchange_rates to fetch.
     * 
    **/
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_ratesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchange_rates.
     * 
    **/
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchange_rates.
     * 
    **/
    distinct?: Enumerable<Exchange_ratesScalarFieldEnum>
  }

  /**
   * exchange_rates: findFirst
   */
  export interface exchange_ratesFindFirstArgs extends exchange_ratesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchange_rates findMany
   */
  export type exchange_ratesFindManyArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * Filter, which exchange_rates to fetch.
     * 
    **/
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_ratesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exchange_rates.
     * 
    **/
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Exchange_ratesScalarFieldEnum>
  }


  /**
   * exchange_rates create
   */
  export type exchange_ratesCreateArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * The data needed to create a exchange_rates.
     * 
    **/
    data: XOR<exchange_ratesCreateInput, exchange_ratesUncheckedCreateInput>
  }


  /**
   * exchange_rates createMany
   */
  export type exchange_ratesCreateManyArgs = {
    /**
     * The data used to create many exchange_rates.
     * 
    **/
    data: Enumerable<exchange_ratesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exchange_rates update
   */
  export type exchange_ratesUpdateArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * The data needed to update a exchange_rates.
     * 
    **/
    data: XOR<exchange_ratesUpdateInput, exchange_ratesUncheckedUpdateInput>
    /**
     * Choose, which exchange_rates to update.
     * 
    **/
    where: exchange_ratesWhereUniqueInput
  }


  /**
   * exchange_rates updateMany
   */
  export type exchange_ratesUpdateManyArgs = {
    /**
     * The data used to update exchange_rates.
     * 
    **/
    data: XOR<exchange_ratesUpdateManyMutationInput, exchange_ratesUncheckedUpdateManyInput>
    /**
     * Filter which exchange_rates to update
     * 
    **/
    where?: exchange_ratesWhereInput
  }


  /**
   * exchange_rates upsert
   */
  export type exchange_ratesUpsertArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * The filter to search for the exchange_rates to update in case it exists.
     * 
    **/
    where: exchange_ratesWhereUniqueInput
    /**
     * In case the exchange_rates found by the `where` argument doesn't exist, create a new exchange_rates with this data.
     * 
    **/
    create: XOR<exchange_ratesCreateInput, exchange_ratesUncheckedCreateInput>
    /**
     * In case the exchange_rates was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<exchange_ratesUpdateInput, exchange_ratesUncheckedUpdateInput>
  }


  /**
   * exchange_rates delete
   */
  export type exchange_ratesDeleteArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
    /**
     * Filter which exchange_rates to delete.
     * 
    **/
    where: exchange_ratesWhereUniqueInput
  }


  /**
   * exchange_rates deleteMany
   */
  export type exchange_ratesDeleteManyArgs = {
    /**
     * Filter which exchange_rates to delete
     * 
    **/
    where?: exchange_ratesWhereInput
  }


  /**
   * exchange_rates: findUniqueOrThrow
   */
  export type exchange_ratesFindUniqueOrThrowArgs = exchange_ratesFindUniqueArgsBase
      

  /**
   * exchange_rates: findFirstOrThrow
   */
  export type exchange_ratesFindFirstOrThrowArgs = exchange_ratesFindFirstArgsBase
      

  /**
   * exchange_rates without action
   */
  export type exchange_ratesArgs = {
    /**
     * Select specific fields to fetch from the exchange_rates
     * 
    **/
    select?: exchange_ratesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_ratesInclude | null
  }



  /**
   * Model admin_permissions
   */


  export type AggregateAdmin_permissions = {
    _count: Admin_permissionsCountAggregateOutputType | null
    _avg: Admin_permissionsAvgAggregateOutputType | null
    _sum: Admin_permissionsSumAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  export type Admin_permissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type Admin_permissionsSumAggregateOutputType = {
    id: number | null
  }

  export type Admin_permissionsMinAggregateOutputType = {
    id: number | null
    action: string | null
    description: string | null
  }

  export type Admin_permissionsMaxAggregateOutputType = {
    id: number | null
    action: string | null
    description: string | null
  }

  export type Admin_permissionsCountAggregateOutputType = {
    id: number
    action: number
    description: number
    _all: number
  }


  export type Admin_permissionsAvgAggregateInputType = {
    id?: true
  }

  export type Admin_permissionsSumAggregateInputType = {
    id?: true
  }

  export type Admin_permissionsMinAggregateInputType = {
    id?: true
    action?: true
    description?: true
  }

  export type Admin_permissionsMaxAggregateInputType = {
    id?: true
    action?: true
    description?: true
  }

  export type Admin_permissionsCountAggregateInputType = {
    id?: true
    action?: true
    description?: true
    _all?: true
  }

  export type Admin_permissionsAggregateArgs = {
    /**
     * Filter which admin_permissions to aggregate.
     * 
    **/
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_permissions
    **/
    _count?: true | Admin_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_permissionsMaxAggregateInputType
  }

  export type GetAdmin_permissionsAggregateType<T extends Admin_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_permissions[P]>
      : GetScalarType<T[P], AggregateAdmin_permissions[P]>
  }




  export type Admin_permissionsGroupByArgs = {
    where?: admin_permissionsWhereInput
    orderBy?: Enumerable<admin_permissionsOrderByWithAggregationInput>
    by: Array<Admin_permissionsScalarFieldEnum>
    having?: admin_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_permissionsCountAggregateInputType | true
    _avg?: Admin_permissionsAvgAggregateInputType
    _sum?: Admin_permissionsSumAggregateInputType
    _min?: Admin_permissionsMinAggregateInputType
    _max?: Admin_permissionsMaxAggregateInputType
  }


  export type Admin_permissionsGroupByOutputType = {
    id: number
    action: string
    description: string | null
    _count: Admin_permissionsCountAggregateOutputType | null
    _avg: Admin_permissionsAvgAggregateOutputType | null
    _sum: Admin_permissionsSumAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  type GetAdmin_permissionsGroupByPayload<T extends Admin_permissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_permissionsSelect = {
    id?: boolean
    action?: boolean
    description?: boolean
    admin_roles_permissions?: boolean | admin_roles_permissionsFindManyArgs
    _count?: boolean | Admin_permissionsCountOutputTypeArgs
  }

  export type admin_permissionsInclude = {
    admin_roles_permissions?: boolean | admin_roles_permissionsFindManyArgs
    _count?: boolean | Admin_permissionsCountOutputTypeArgs
  }

  export type admin_permissionsGetPayload<
    S extends boolean | null | undefined | admin_permissionsArgs,
    U = keyof S
      > = S extends true
        ? admin_permissions
    : S extends undefined
    ? never
    : S extends admin_permissionsArgs | admin_permissionsFindManyArgs
    ?'include' extends U
    ? admin_permissions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'admin_roles_permissions' ? Array < admin_roles_permissionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_permissionsCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'admin_roles_permissions' ? Array < admin_roles_permissionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_permissionsCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof admin_permissions ? admin_permissions[P] : never
  } 
    : admin_permissions
  : admin_permissions


  type admin_permissionsCountArgs = Merge<
    Omit<admin_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Admin_permissionsCountAggregateInputType | true
    }
  >

  export interface admin_permissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Admin_permissions that matches the filter.
     * @param {admin_permissionsFindUniqueArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admin_permissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admin_permissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin_permissions'> extends True ? CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>> : CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions | null, null>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T> | null, null>>

    /**
     * Find the first Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admin_permissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admin_permissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin_permissions'> extends True ? CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>> : CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions | null, null>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T> | null, null>>

    /**
     * Find zero or more Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany()
     * 
     * // Get first 10 Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_permissionsWithIdOnly = await prisma.admin_permissions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends admin_permissionsFindManyArgs>(
      args?: SelectSubset<T, admin_permissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admin_permissions>>, PrismaPromise<Array<admin_permissionsGetPayload<T>>>>

    /**
     * Create a Admin_permissions.
     * @param {admin_permissionsCreateArgs} args - Arguments to create a Admin_permissions.
     * @example
     * // Create one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.create({
     *   data: {
     *     // ... data to create a Admin_permissions
     *   }
     * })
     * 
    **/
    create<T extends admin_permissionsCreateArgs>(
      args: SelectSubset<T, admin_permissionsCreateArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Create many Admin_permissions.
     *     @param {admin_permissionsCreateManyArgs} args - Arguments to create many Admin_permissions.
     *     @example
     *     // Create many Admin_permissions
     *     const admin_permissions = await prisma.admin_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admin_permissionsCreateManyArgs>(
      args?: SelectSubset<T, admin_permissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_permissions.
     * @param {admin_permissionsDeleteArgs} args - Arguments to delete one Admin_permissions.
     * @example
     * // Delete one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.delete({
     *   where: {
     *     // ... filter to delete one Admin_permissions
     *   }
     * })
     * 
    **/
    delete<T extends admin_permissionsDeleteArgs>(
      args: SelectSubset<T, admin_permissionsDeleteArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Update one Admin_permissions.
     * @param {admin_permissionsUpdateArgs} args - Arguments to update one Admin_permissions.
     * @example
     * // Update one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admin_permissionsUpdateArgs>(
      args: SelectSubset<T, admin_permissionsUpdateArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Delete zero or more Admin_permissions.
     * @param {admin_permissionsDeleteManyArgs} args - Arguments to filter Admin_permissions to delete.
     * @example
     * // Delete a few Admin_permissions
     * const { count } = await prisma.admin_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admin_permissionsDeleteManyArgs>(
      args?: SelectSubset<T, admin_permissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admin_permissionsUpdateManyArgs>(
      args: SelectSubset<T, admin_permissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_permissions.
     * @param {admin_permissionsUpsertArgs} args - Arguments to update or create a Admin_permissions.
     * @example
     * // Update or create a Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.upsert({
     *   create: {
     *     // ... data to create a Admin_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends admin_permissionsUpsertArgs>(
      args: SelectSubset<T, admin_permissionsUpsertArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Find one Admin_permissions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admin_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admin_permissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admin_permissionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Find the first Admin_permissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admin_permissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admin_permissionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T>>>

    /**
     * Count the number of Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsCountArgs} args - Arguments to filter Admin_permissions to count.
     * @example
     * // Count the number of Admin_permissions
     * const count = await prisma.admin_permissions.count({
     *   where: {
     *     // ... the filter for the Admin_permissions we want to count
     *   }
     * })
    **/
    count<T extends admin_permissionsCountArgs>(
      args?: Subset<T, admin_permissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_permissionsAggregateArgs>(args: Subset<T, Admin_permissionsAggregateArgs>): PrismaPromise<GetAdmin_permissionsAggregateType<T>>

    /**
     * Group by Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: Admin_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_permissionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admin_permissionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin_roles_permissions<T extends admin_roles_permissionsFindManyArgs = {}>(args?: Subset<T, admin_roles_permissionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_roles_permissions>| Null>, PrismaPromise<Array<admin_roles_permissionsGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin_permissions base type for findUnique actions
   */
  export type admin_permissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * Filter, which admin_permissions to fetch.
     * 
    **/
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions: findUnique
   */
  export interface admin_permissionsFindUniqueArgs extends admin_permissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_permissions base type for findFirst actions
   */
  export type admin_permissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * Filter, which admin_permissions to fetch.
     * 
    **/
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permissions.
     * 
    **/
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permissions.
     * 
    **/
    distinct?: Enumerable<Admin_permissionsScalarFieldEnum>
  }

  /**
   * admin_permissions: findFirst
   */
  export interface admin_permissionsFindFirstArgs extends admin_permissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_permissions findMany
   */
  export type admin_permissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * Filter, which admin_permissions to fetch.
     * 
    **/
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_permissions.
     * 
    **/
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_permissionsScalarFieldEnum>
  }


  /**
   * admin_permissions create
   */
  export type admin_permissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * The data needed to create a admin_permissions.
     * 
    **/
    data: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
  }


  /**
   * admin_permissions createMany
   */
  export type admin_permissionsCreateManyArgs = {
    /**
     * The data used to create many admin_permissions.
     * 
    **/
    data: Enumerable<admin_permissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin_permissions update
   */
  export type admin_permissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * The data needed to update a admin_permissions.
     * 
    **/
    data: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
    /**
     * Choose, which admin_permissions to update.
     * 
    **/
    where: admin_permissionsWhereUniqueInput
  }


  /**
   * admin_permissions updateMany
   */
  export type admin_permissionsUpdateManyArgs = {
    /**
     * The data used to update admin_permissions.
     * 
    **/
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permissions to update
     * 
    **/
    where?: admin_permissionsWhereInput
  }


  /**
   * admin_permissions upsert
   */
  export type admin_permissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * The filter to search for the admin_permissions to update in case it exists.
     * 
    **/
    where: admin_permissionsWhereUniqueInput
    /**
     * In case the admin_permissions found by the `where` argument doesn't exist, create a new admin_permissions with this data.
     * 
    **/
    create: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
    /**
     * In case the admin_permissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
  }


  /**
   * admin_permissions delete
   */
  export type admin_permissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
    /**
     * Filter which admin_permissions to delete.
     * 
    **/
    where: admin_permissionsWhereUniqueInput
  }


  /**
   * admin_permissions deleteMany
   */
  export type admin_permissionsDeleteManyArgs = {
    /**
     * Filter which admin_permissions to delete
     * 
    **/
    where?: admin_permissionsWhereInput
  }


  /**
   * admin_permissions: findUniqueOrThrow
   */
  export type admin_permissionsFindUniqueOrThrowArgs = admin_permissionsFindUniqueArgsBase
      

  /**
   * admin_permissions: findFirstOrThrow
   */
  export type admin_permissionsFindFirstOrThrowArgs = admin_permissionsFindFirstArgsBase
      

  /**
   * admin_permissions without action
   */
  export type admin_permissionsArgs = {
    /**
     * Select specific fields to fetch from the admin_permissions
     * 
    **/
    select?: admin_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_permissionsInclude | null
  }



  /**
   * Model admin_roles
   */


  export type AggregateAdmin_roles = {
    _count: Admin_rolesCountAggregateOutputType | null
    _avg: Admin_rolesAvgAggregateOutputType | null
    _sum: Admin_rolesSumAggregateOutputType | null
    _min: Admin_rolesMinAggregateOutputType | null
    _max: Admin_rolesMaxAggregateOutputType | null
  }

  export type Admin_rolesAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
    modified_by: number | null
    deleted: number | null
  }

  export type Admin_rolesSumAggregateOutputType = {
    id: number | null
    created_by: number | null
    modified_by: number | null
    deleted: number | null
  }

  export type Admin_rolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    modified_by: number | null
    deleted: number | null
  }

  export type Admin_rolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    modified_by: number | null
    deleted: number | null
  }

  export type Admin_rolesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_date: number
    modified_date: number
    created_by: number
    modified_by: number
    deleted: number
    _all: number
  }


  export type Admin_rolesAvgAggregateInputType = {
    id?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Admin_rolesSumAggregateInputType = {
    id?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Admin_rolesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Admin_rolesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    modified_by?: true
    deleted?: true
  }

  export type Admin_rolesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    modified_by?: true
    deleted?: true
    _all?: true
  }

  export type Admin_rolesAggregateArgs = {
    /**
     * Filter which admin_roles to aggregate.
     * 
    **/
    where?: admin_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admin_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_roles
    **/
    _count?: true | Admin_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_rolesMaxAggregateInputType
  }

  export type GetAdmin_rolesAggregateType<T extends Admin_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_roles[P]>
      : GetScalarType<T[P], AggregateAdmin_roles[P]>
  }




  export type Admin_rolesGroupByArgs = {
    where?: admin_rolesWhereInput
    orderBy?: Enumerable<admin_rolesOrderByWithAggregationInput>
    by: Array<Admin_rolesScalarFieldEnum>
    having?: admin_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_rolesCountAggregateInputType | true
    _avg?: Admin_rolesAvgAggregateInputType
    _sum?: Admin_rolesSumAggregateInputType
    _min?: Admin_rolesMinAggregateInputType
    _max?: Admin_rolesMaxAggregateInputType
  }


  export type Admin_rolesGroupByOutputType = {
    id: number
    name: string
    description: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    modified_by: number | null
    deleted: number | null
    _count: Admin_rolesCountAggregateOutputType | null
    _avg: Admin_rolesAvgAggregateOutputType | null
    _sum: Admin_rolesSumAggregateOutputType | null
    _min: Admin_rolesMinAggregateOutputType | null
    _max: Admin_rolesMaxAggregateOutputType | null
  }

  type GetAdmin_rolesGroupByPayload<T extends Admin_rolesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_rolesGroupByOutputType[P]>
        }
      >
    >


  export type admin_rolesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_date?: boolean
    modified_date?: boolean
    created_by?: boolean
    modified_by?: boolean
    deleted?: boolean
    admin_users_admin_roles_created_byToadmin_users?: boolean | admin_usersArgs
    admin_users_admin_roles_modified_byToadmin_users?: boolean | admin_usersArgs
    admin_roles_permissions?: boolean | admin_roles_permissionsFindManyArgs
    admin_users_roles?: boolean | admin_users_rolesFindManyArgs
    _count?: boolean | Admin_rolesCountOutputTypeArgs
  }

  export type admin_rolesInclude = {
    admin_users_admin_roles_created_byToadmin_users?: boolean | admin_usersArgs
    admin_users_admin_roles_modified_byToadmin_users?: boolean | admin_usersArgs
    admin_roles_permissions?: boolean | admin_roles_permissionsFindManyArgs
    admin_users_roles?: boolean | admin_users_rolesFindManyArgs
    _count?: boolean | Admin_rolesCountOutputTypeArgs
  }

  export type admin_rolesGetPayload<
    S extends boolean | null | undefined | admin_rolesArgs,
    U = keyof S
      > = S extends true
        ? admin_roles
    : S extends undefined
    ? never
    : S extends admin_rolesArgs | admin_rolesFindManyArgs
    ?'include' extends U
    ? admin_roles  & {
    [P in TrueKeys<S['include']>]:
        P extends 'admin_users_admin_roles_created_byToadmin_users' ? admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_roles_modified_byToadmin_users' ? admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'admin_roles_permissions' ? Array < admin_roles_permissionsGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'admin_users_roles' ? Array < admin_users_rolesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_rolesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'admin_users_admin_roles_created_byToadmin_users' ? admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_roles_modified_byToadmin_users' ? admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'admin_roles_permissions' ? Array < admin_roles_permissionsGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'admin_users_roles' ? Array < admin_users_rolesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_rolesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof admin_roles ? admin_roles[P] : never
  } 
    : admin_roles
  : admin_roles


  type admin_rolesCountArgs = Merge<
    Omit<admin_rolesFindManyArgs, 'select' | 'include'> & {
      select?: Admin_rolesCountAggregateInputType | true
    }
  >

  export interface admin_rolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Admin_roles that matches the filter.
     * @param {admin_rolesFindUniqueArgs} args - Arguments to find a Admin_roles
     * @example
     * // Get one Admin_roles
     * const admin_roles = await prisma.admin_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admin_rolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admin_rolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin_roles'> extends True ? CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>> : CheckSelect<T, Prisma__admin_rolesClient<admin_roles | null, null>, Prisma__admin_rolesClient<admin_rolesGetPayload<T> | null, null>>

    /**
     * Find the first Admin_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_rolesFindFirstArgs} args - Arguments to find a Admin_roles
     * @example
     * // Get one Admin_roles
     * const admin_roles = await prisma.admin_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admin_rolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admin_rolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin_roles'> extends True ? CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>> : CheckSelect<T, Prisma__admin_rolesClient<admin_roles | null, null>, Prisma__admin_rolesClient<admin_rolesGetPayload<T> | null, null>>

    /**
     * Find zero or more Admin_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_roles
     * const admin_roles = await prisma.admin_roles.findMany()
     * 
     * // Get first 10 Admin_roles
     * const admin_roles = await prisma.admin_roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_rolesWithIdOnly = await prisma.admin_roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends admin_rolesFindManyArgs>(
      args?: SelectSubset<T, admin_rolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admin_roles>>, PrismaPromise<Array<admin_rolesGetPayload<T>>>>

    /**
     * Create a Admin_roles.
     * @param {admin_rolesCreateArgs} args - Arguments to create a Admin_roles.
     * @example
     * // Create one Admin_roles
     * const Admin_roles = await prisma.admin_roles.create({
     *   data: {
     *     // ... data to create a Admin_roles
     *   }
     * })
     * 
    **/
    create<T extends admin_rolesCreateArgs>(
      args: SelectSubset<T, admin_rolesCreateArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Create many Admin_roles.
     *     @param {admin_rolesCreateManyArgs} args - Arguments to create many Admin_roles.
     *     @example
     *     // Create many Admin_roles
     *     const admin_roles = await prisma.admin_roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admin_rolesCreateManyArgs>(
      args?: SelectSubset<T, admin_rolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_roles.
     * @param {admin_rolesDeleteArgs} args - Arguments to delete one Admin_roles.
     * @example
     * // Delete one Admin_roles
     * const Admin_roles = await prisma.admin_roles.delete({
     *   where: {
     *     // ... filter to delete one Admin_roles
     *   }
     * })
     * 
    **/
    delete<T extends admin_rolesDeleteArgs>(
      args: SelectSubset<T, admin_rolesDeleteArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Update one Admin_roles.
     * @param {admin_rolesUpdateArgs} args - Arguments to update one Admin_roles.
     * @example
     * // Update one Admin_roles
     * const admin_roles = await prisma.admin_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admin_rolesUpdateArgs>(
      args: SelectSubset<T, admin_rolesUpdateArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Delete zero or more Admin_roles.
     * @param {admin_rolesDeleteManyArgs} args - Arguments to filter Admin_roles to delete.
     * @example
     * // Delete a few Admin_roles
     * const { count } = await prisma.admin_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admin_rolesDeleteManyArgs>(
      args?: SelectSubset<T, admin_rolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_roles
     * const admin_roles = await prisma.admin_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admin_rolesUpdateManyArgs>(
      args: SelectSubset<T, admin_rolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_roles.
     * @param {admin_rolesUpsertArgs} args - Arguments to update or create a Admin_roles.
     * @example
     * // Update or create a Admin_roles
     * const admin_roles = await prisma.admin_roles.upsert({
     *   create: {
     *     // ... data to create a Admin_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_roles we want to update
     *   }
     * })
    **/
    upsert<T extends admin_rolesUpsertArgs>(
      args: SelectSubset<T, admin_rolesUpsertArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Find one Admin_roles that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admin_rolesFindUniqueOrThrowArgs} args - Arguments to find a Admin_roles
     * @example
     * // Get one Admin_roles
     * const admin_roles = await prisma.admin_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admin_rolesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admin_rolesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Find the first Admin_roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_rolesFindFirstOrThrowArgs} args - Arguments to find a Admin_roles
     * @example
     * // Get one Admin_roles
     * const admin_roles = await prisma.admin_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admin_rolesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admin_rolesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_rolesClient<admin_roles>, Prisma__admin_rolesClient<admin_rolesGetPayload<T>>>

    /**
     * Count the number of Admin_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_rolesCountArgs} args - Arguments to filter Admin_roles to count.
     * @example
     * // Count the number of Admin_roles
     * const count = await prisma.admin_roles.count({
     *   where: {
     *     // ... the filter for the Admin_roles we want to count
     *   }
     * })
    **/
    count<T extends admin_rolesCountArgs>(
      args?: Subset<T, admin_rolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_rolesAggregateArgs>(args: Subset<T, Admin_rolesAggregateArgs>): PrismaPromise<GetAdmin_rolesAggregateType<T>>

    /**
     * Group by Admin_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_rolesGroupByArgs['orderBy'] }
        : { orderBy?: Admin_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_rolesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admin_rolesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin_users_admin_roles_created_byToadmin_users<T extends admin_usersArgs = {}>(args?: Subset<T, admin_usersArgs>): CheckSelect<T, Prisma__admin_usersClient<admin_users | Null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | Null>>;

    admin_users_admin_roles_modified_byToadmin_users<T extends admin_usersArgs = {}>(args?: Subset<T, admin_usersArgs>): CheckSelect<T, Prisma__admin_usersClient<admin_users | Null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | Null>>;

    admin_roles_permissions<T extends admin_roles_permissionsFindManyArgs = {}>(args?: Subset<T, admin_roles_permissionsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_roles_permissions>| Null>, PrismaPromise<Array<admin_roles_permissionsGetPayload<T>>| Null>>;

    admin_users_roles<T extends admin_users_rolesFindManyArgs = {}>(args?: Subset<T, admin_users_rolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_users_roles>| Null>, PrismaPromise<Array<admin_users_rolesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin_roles base type for findUnique actions
   */
  export type admin_rolesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * Filter, which admin_roles to fetch.
     * 
    **/
    where: admin_rolesWhereUniqueInput
  }

  /**
   * admin_roles: findUnique
   */
  export interface admin_rolesFindUniqueArgs extends admin_rolesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_roles base type for findFirst actions
   */
  export type admin_rolesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * Filter, which admin_roles to fetch.
     * 
    **/
    where?: admin_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_roles.
     * 
    **/
    cursor?: admin_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_roles.
     * 
    **/
    distinct?: Enumerable<Admin_rolesScalarFieldEnum>
  }

  /**
   * admin_roles: findFirst
   */
  export interface admin_rolesFindFirstArgs extends admin_rolesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_roles findMany
   */
  export type admin_rolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * Filter, which admin_roles to fetch.
     * 
    **/
    where?: admin_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_roles.
     * 
    **/
    cursor?: admin_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_rolesScalarFieldEnum>
  }


  /**
   * admin_roles create
   */
  export type admin_rolesCreateArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * The data needed to create a admin_roles.
     * 
    **/
    data: XOR<admin_rolesCreateInput, admin_rolesUncheckedCreateInput>
  }


  /**
   * admin_roles createMany
   */
  export type admin_rolesCreateManyArgs = {
    /**
     * The data used to create many admin_roles.
     * 
    **/
    data: Enumerable<admin_rolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin_roles update
   */
  export type admin_rolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * The data needed to update a admin_roles.
     * 
    **/
    data: XOR<admin_rolesUpdateInput, admin_rolesUncheckedUpdateInput>
    /**
     * Choose, which admin_roles to update.
     * 
    **/
    where: admin_rolesWhereUniqueInput
  }


  /**
   * admin_roles updateMany
   */
  export type admin_rolesUpdateManyArgs = {
    /**
     * The data used to update admin_roles.
     * 
    **/
    data: XOR<admin_rolesUpdateManyMutationInput, admin_rolesUncheckedUpdateManyInput>
    /**
     * Filter which admin_roles to update
     * 
    **/
    where?: admin_rolesWhereInput
  }


  /**
   * admin_roles upsert
   */
  export type admin_rolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * The filter to search for the admin_roles to update in case it exists.
     * 
    **/
    where: admin_rolesWhereUniqueInput
    /**
     * In case the admin_roles found by the `where` argument doesn't exist, create a new admin_roles with this data.
     * 
    **/
    create: XOR<admin_rolesCreateInput, admin_rolesUncheckedCreateInput>
    /**
     * In case the admin_roles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admin_rolesUpdateInput, admin_rolesUncheckedUpdateInput>
  }


  /**
   * admin_roles delete
   */
  export type admin_rolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
    /**
     * Filter which admin_roles to delete.
     * 
    **/
    where: admin_rolesWhereUniqueInput
  }


  /**
   * admin_roles deleteMany
   */
  export type admin_rolesDeleteManyArgs = {
    /**
     * Filter which admin_roles to delete
     * 
    **/
    where?: admin_rolesWhereInput
  }


  /**
   * admin_roles: findUniqueOrThrow
   */
  export type admin_rolesFindUniqueOrThrowArgs = admin_rolesFindUniqueArgsBase
      

  /**
   * admin_roles: findFirstOrThrow
   */
  export type admin_rolesFindFirstOrThrowArgs = admin_rolesFindFirstArgsBase
      

  /**
   * admin_roles without action
   */
  export type admin_rolesArgs = {
    /**
     * Select specific fields to fetch from the admin_roles
     * 
    **/
    select?: admin_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_rolesInclude | null
  }



  /**
   * Model admin_roles_permissions
   */


  export type AggregateAdmin_roles_permissions = {
    _count: Admin_roles_permissionsCountAggregateOutputType | null
    _avg: Admin_roles_permissionsAvgAggregateOutputType | null
    _sum: Admin_roles_permissionsSumAggregateOutputType | null
    _min: Admin_roles_permissionsMinAggregateOutputType | null
    _max: Admin_roles_permissionsMaxAggregateOutputType | null
  }

  export type Admin_roles_permissionsAvgAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Admin_roles_permissionsSumAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Admin_roles_permissionsMinAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Admin_roles_permissionsMaxAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Admin_roles_permissionsCountAggregateOutputType = {
    permission_id: number
    role_id: number
    _all: number
  }


  export type Admin_roles_permissionsAvgAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Admin_roles_permissionsSumAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Admin_roles_permissionsMinAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Admin_roles_permissionsMaxAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Admin_roles_permissionsCountAggregateInputType = {
    permission_id?: true
    role_id?: true
    _all?: true
  }

  export type Admin_roles_permissionsAggregateArgs = {
    /**
     * Filter which admin_roles_permissions to aggregate.
     * 
    **/
    where?: admin_roles_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_roles_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admin_roles_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles_permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_roles_permissions
    **/
    _count?: true | Admin_roles_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_roles_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_roles_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_roles_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_roles_permissionsMaxAggregateInputType
  }

  export type GetAdmin_roles_permissionsAggregateType<T extends Admin_roles_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_roles_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_roles_permissions[P]>
      : GetScalarType<T[P], AggregateAdmin_roles_permissions[P]>
  }




  export type Admin_roles_permissionsGroupByArgs = {
    where?: admin_roles_permissionsWhereInput
    orderBy?: Enumerable<admin_roles_permissionsOrderByWithAggregationInput>
    by: Array<Admin_roles_permissionsScalarFieldEnum>
    having?: admin_roles_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_roles_permissionsCountAggregateInputType | true
    _avg?: Admin_roles_permissionsAvgAggregateInputType
    _sum?: Admin_roles_permissionsSumAggregateInputType
    _min?: Admin_roles_permissionsMinAggregateInputType
    _max?: Admin_roles_permissionsMaxAggregateInputType
  }


  export type Admin_roles_permissionsGroupByOutputType = {
    permission_id: number
    role_id: number
    _count: Admin_roles_permissionsCountAggregateOutputType | null
    _avg: Admin_roles_permissionsAvgAggregateOutputType | null
    _sum: Admin_roles_permissionsSumAggregateOutputType | null
    _min: Admin_roles_permissionsMinAggregateOutputType | null
    _max: Admin_roles_permissionsMaxAggregateOutputType | null
  }

  type GetAdmin_roles_permissionsGroupByPayload<T extends Admin_roles_permissionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_roles_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_roles_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_roles_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_roles_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_roles_permissionsSelect = {
    permission_id?: boolean
    role_id?: boolean
    admin_permissions?: boolean | admin_permissionsArgs
    admin_roles?: boolean | admin_rolesArgs
  }

  export type admin_roles_permissionsInclude = {
    admin_permissions?: boolean | admin_permissionsArgs
    admin_roles?: boolean | admin_rolesArgs
  }

  export type admin_roles_permissionsGetPayload<
    S extends boolean | null | undefined | admin_roles_permissionsArgs,
    U = keyof S
      > = S extends true
        ? admin_roles_permissions
    : S extends undefined
    ? never
    : S extends admin_roles_permissionsArgs | admin_roles_permissionsFindManyArgs
    ?'include' extends U
    ? admin_roles_permissions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'admin_permissions' ? admin_permissionsGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'admin_roles' ? admin_rolesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'admin_permissions' ? admin_permissionsGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'admin_roles' ? admin_rolesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof admin_roles_permissions ? admin_roles_permissions[P] : never
  } 
    : admin_roles_permissions
  : admin_roles_permissions


  type admin_roles_permissionsCountArgs = Merge<
    Omit<admin_roles_permissionsFindManyArgs, 'select' | 'include'> & {
      select?: Admin_roles_permissionsCountAggregateInputType | true
    }
  >

  export interface admin_roles_permissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Admin_roles_permissions that matches the filter.
     * @param {admin_roles_permissionsFindUniqueArgs} args - Arguments to find a Admin_roles_permissions
     * @example
     * // Get one Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admin_roles_permissionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admin_roles_permissionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin_roles_permissions'> extends True ? CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>> : CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions | null, null>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T> | null, null>>

    /**
     * Find the first Admin_roles_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_roles_permissionsFindFirstArgs} args - Arguments to find a Admin_roles_permissions
     * @example
     * // Get one Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admin_roles_permissionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admin_roles_permissionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin_roles_permissions'> extends True ? CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>> : CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions | null, null>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T> | null, null>>

    /**
     * Find zero or more Admin_roles_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_roles_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findMany()
     * 
     * // Get first 10 Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const admin_roles_permissionsWithPermission_idOnly = await prisma.admin_roles_permissions.findMany({ select: { permission_id: true } })
     * 
    **/
    findMany<T extends admin_roles_permissionsFindManyArgs>(
      args?: SelectSubset<T, admin_roles_permissionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admin_roles_permissions>>, PrismaPromise<Array<admin_roles_permissionsGetPayload<T>>>>

    /**
     * Create a Admin_roles_permissions.
     * @param {admin_roles_permissionsCreateArgs} args - Arguments to create a Admin_roles_permissions.
     * @example
     * // Create one Admin_roles_permissions
     * const Admin_roles_permissions = await prisma.admin_roles_permissions.create({
     *   data: {
     *     // ... data to create a Admin_roles_permissions
     *   }
     * })
     * 
    **/
    create<T extends admin_roles_permissionsCreateArgs>(
      args: SelectSubset<T, admin_roles_permissionsCreateArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Create many Admin_roles_permissions.
     *     @param {admin_roles_permissionsCreateManyArgs} args - Arguments to create many Admin_roles_permissions.
     *     @example
     *     // Create many Admin_roles_permissions
     *     const admin_roles_permissions = await prisma.admin_roles_permissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admin_roles_permissionsCreateManyArgs>(
      args?: SelectSubset<T, admin_roles_permissionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_roles_permissions.
     * @param {admin_roles_permissionsDeleteArgs} args - Arguments to delete one Admin_roles_permissions.
     * @example
     * // Delete one Admin_roles_permissions
     * const Admin_roles_permissions = await prisma.admin_roles_permissions.delete({
     *   where: {
     *     // ... filter to delete one Admin_roles_permissions
     *   }
     * })
     * 
    **/
    delete<T extends admin_roles_permissionsDeleteArgs>(
      args: SelectSubset<T, admin_roles_permissionsDeleteArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Update one Admin_roles_permissions.
     * @param {admin_roles_permissionsUpdateArgs} args - Arguments to update one Admin_roles_permissions.
     * @example
     * // Update one Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admin_roles_permissionsUpdateArgs>(
      args: SelectSubset<T, admin_roles_permissionsUpdateArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Delete zero or more Admin_roles_permissions.
     * @param {admin_roles_permissionsDeleteManyArgs} args - Arguments to filter Admin_roles_permissions to delete.
     * @example
     * // Delete a few Admin_roles_permissions
     * const { count } = await prisma.admin_roles_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admin_roles_permissionsDeleteManyArgs>(
      args?: SelectSubset<T, admin_roles_permissionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_roles_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_roles_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admin_roles_permissionsUpdateManyArgs>(
      args: SelectSubset<T, admin_roles_permissionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_roles_permissions.
     * @param {admin_roles_permissionsUpsertArgs} args - Arguments to update or create a Admin_roles_permissions.
     * @example
     * // Update or create a Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.upsert({
     *   create: {
     *     // ... data to create a Admin_roles_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_roles_permissions we want to update
     *   }
     * })
    **/
    upsert<T extends admin_roles_permissionsUpsertArgs>(
      args: SelectSubset<T, admin_roles_permissionsUpsertArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Find one Admin_roles_permissions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admin_roles_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_roles_permissions
     * @example
     * // Get one Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admin_roles_permissionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admin_roles_permissionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Find the first Admin_roles_permissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_roles_permissionsFindFirstOrThrowArgs} args - Arguments to find a Admin_roles_permissions
     * @example
     * // Get one Admin_roles_permissions
     * const admin_roles_permissions = await prisma.admin_roles_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admin_roles_permissionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admin_roles_permissionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_roles_permissionsClient<admin_roles_permissions>, Prisma__admin_roles_permissionsClient<admin_roles_permissionsGetPayload<T>>>

    /**
     * Count the number of Admin_roles_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_roles_permissionsCountArgs} args - Arguments to filter Admin_roles_permissions to count.
     * @example
     * // Count the number of Admin_roles_permissions
     * const count = await prisma.admin_roles_permissions.count({
     *   where: {
     *     // ... the filter for the Admin_roles_permissions we want to count
     *   }
     * })
    **/
    count<T extends admin_roles_permissionsCountArgs>(
      args?: Subset<T, admin_roles_permissionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_roles_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_roles_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_roles_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_roles_permissionsAggregateArgs>(args: Subset<T, Admin_roles_permissionsAggregateArgs>): PrismaPromise<GetAdmin_roles_permissionsAggregateType<T>>

    /**
     * Group by Admin_roles_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_roles_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_roles_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_roles_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: Admin_roles_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_roles_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_roles_permissionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_roles_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admin_roles_permissionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin_permissions<T extends admin_permissionsArgs = {}>(args?: Subset<T, admin_permissionsArgs>): CheckSelect<T, Prisma__admin_permissionsClient<admin_permissions | Null>, Prisma__admin_permissionsClient<admin_permissionsGetPayload<T> | Null>>;

    admin_roles<T extends admin_rolesArgs = {}>(args?: Subset<T, admin_rolesArgs>): CheckSelect<T, Prisma__admin_rolesClient<admin_roles | Null>, Prisma__admin_rolesClient<admin_rolesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin_roles_permissions base type for findUnique actions
   */
  export type admin_roles_permissionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * Filter, which admin_roles_permissions to fetch.
     * 
    **/
    where: admin_roles_permissionsWhereUniqueInput
  }

  /**
   * admin_roles_permissions: findUnique
   */
  export interface admin_roles_permissionsFindUniqueArgs extends admin_roles_permissionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_roles_permissions base type for findFirst actions
   */
  export type admin_roles_permissionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * Filter, which admin_roles_permissions to fetch.
     * 
    **/
    where?: admin_roles_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_roles_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_roles_permissions.
     * 
    **/
    cursor?: admin_roles_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles_permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_roles_permissions.
     * 
    **/
    distinct?: Enumerable<Admin_roles_permissionsScalarFieldEnum>
  }

  /**
   * admin_roles_permissions: findFirst
   */
  export interface admin_roles_permissionsFindFirstArgs extends admin_roles_permissionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_roles_permissions findMany
   */
  export type admin_roles_permissionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * Filter, which admin_roles_permissions to fetch.
     * 
    **/
    where?: admin_roles_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_roles_permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_roles_permissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_roles_permissions.
     * 
    **/
    cursor?: admin_roles_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_roles_permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_roles_permissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_roles_permissionsScalarFieldEnum>
  }


  /**
   * admin_roles_permissions create
   */
  export type admin_roles_permissionsCreateArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * The data needed to create a admin_roles_permissions.
     * 
    **/
    data: XOR<admin_roles_permissionsCreateInput, admin_roles_permissionsUncheckedCreateInput>
  }


  /**
   * admin_roles_permissions createMany
   */
  export type admin_roles_permissionsCreateManyArgs = {
    /**
     * The data used to create many admin_roles_permissions.
     * 
    **/
    data: Enumerable<admin_roles_permissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin_roles_permissions update
   */
  export type admin_roles_permissionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * The data needed to update a admin_roles_permissions.
     * 
    **/
    data: XOR<admin_roles_permissionsUpdateInput, admin_roles_permissionsUncheckedUpdateInput>
    /**
     * Choose, which admin_roles_permissions to update.
     * 
    **/
    where: admin_roles_permissionsWhereUniqueInput
  }


  /**
   * admin_roles_permissions updateMany
   */
  export type admin_roles_permissionsUpdateManyArgs = {
    /**
     * The data used to update admin_roles_permissions.
     * 
    **/
    data: XOR<admin_roles_permissionsUpdateManyMutationInput, admin_roles_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_roles_permissions to update
     * 
    **/
    where?: admin_roles_permissionsWhereInput
  }


  /**
   * admin_roles_permissions upsert
   */
  export type admin_roles_permissionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * The filter to search for the admin_roles_permissions to update in case it exists.
     * 
    **/
    where: admin_roles_permissionsWhereUniqueInput
    /**
     * In case the admin_roles_permissions found by the `where` argument doesn't exist, create a new admin_roles_permissions with this data.
     * 
    **/
    create: XOR<admin_roles_permissionsCreateInput, admin_roles_permissionsUncheckedCreateInput>
    /**
     * In case the admin_roles_permissions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admin_roles_permissionsUpdateInput, admin_roles_permissionsUncheckedUpdateInput>
  }


  /**
   * admin_roles_permissions delete
   */
  export type admin_roles_permissionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
    /**
     * Filter which admin_roles_permissions to delete.
     * 
    **/
    where: admin_roles_permissionsWhereUniqueInput
  }


  /**
   * admin_roles_permissions deleteMany
   */
  export type admin_roles_permissionsDeleteManyArgs = {
    /**
     * Filter which admin_roles_permissions to delete
     * 
    **/
    where?: admin_roles_permissionsWhereInput
  }


  /**
   * admin_roles_permissions: findUniqueOrThrow
   */
  export type admin_roles_permissionsFindUniqueOrThrowArgs = admin_roles_permissionsFindUniqueArgsBase
      

  /**
   * admin_roles_permissions: findFirstOrThrow
   */
  export type admin_roles_permissionsFindFirstOrThrowArgs = admin_roles_permissionsFindFirstArgsBase
      

  /**
   * admin_roles_permissions without action
   */
  export type admin_roles_permissionsArgs = {
    /**
     * Select specific fields to fetch from the admin_roles_permissions
     * 
    **/
    select?: admin_roles_permissionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_roles_permissionsInclude | null
  }



  /**
   * Model admin_users
   */


  export type AggregateAdmin_users = {
    _count: Admin_usersCountAggregateOutputType | null
    _avg: Admin_usersAvgAggregateOutputType | null
    _sum: Admin_usersSumAggregateOutputType | null
    _min: Admin_usersMinAggregateOutputType | null
    _max: Admin_usersMaxAggregateOutputType | null
  }

  export type Admin_usersAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
    deleted: number | null
    modified_by: number | null
  }

  export type Admin_usersSumAggregateOutputType = {
    id: number | null
    created_by: number | null
    deleted: number | null
    modified_by: number | null
  }

  export type Admin_usersMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    hash_pass: string | null
    first_name: string | null
    last_name: string | null
    phone_mobile: string | null
    address: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    deleted: number | null
    hash_rt: string | null
    modified_by: number | null
    status: string | null
    agency_id: string | null
  }

  export type Admin_usersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    hash_pass: string | null
    first_name: string | null
    last_name: string | null
    phone_mobile: string | null
    address: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    deleted: number | null
    hash_rt: string | null
    modified_by: number | null
    status: string | null
    agency_id: string | null
  }

  export type Admin_usersCountAggregateOutputType = {
    id: number
    username: number
    email: number
    hash_pass: number
    first_name: number
    last_name: number
    phone_mobile: number
    address: number
    created_date: number
    modified_date: number
    created_by: number
    deleted: number
    hash_rt: number
    modified_by: number
    status: number
    agency_id: number
    _all: number
  }


  export type Admin_usersAvgAggregateInputType = {
    id?: true
    created_by?: true
    deleted?: true
    modified_by?: true
  }

  export type Admin_usersSumAggregateInputType = {
    id?: true
    created_by?: true
    deleted?: true
    modified_by?: true
  }

  export type Admin_usersMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    hash_pass?: true
    first_name?: true
    last_name?: true
    phone_mobile?: true
    address?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    deleted?: true
    hash_rt?: true
    modified_by?: true
    status?: true
    agency_id?: true
  }

  export type Admin_usersMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    hash_pass?: true
    first_name?: true
    last_name?: true
    phone_mobile?: true
    address?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    deleted?: true
    hash_rt?: true
    modified_by?: true
    status?: true
    agency_id?: true
  }

  export type Admin_usersCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    hash_pass?: true
    first_name?: true
    last_name?: true
    phone_mobile?: true
    address?: true
    created_date?: true
    modified_date?: true
    created_by?: true
    deleted?: true
    hash_rt?: true
    modified_by?: true
    status?: true
    agency_id?: true
    _all?: true
  }

  export type Admin_usersAggregateArgs = {
    /**
     * Filter which admin_users to aggregate.
     * 
    **/
    where?: admin_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admin_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_users
    **/
    _count?: true | Admin_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_usersMaxAggregateInputType
  }

  export type GetAdmin_usersAggregateType<T extends Admin_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_users[P]>
      : GetScalarType<T[P], AggregateAdmin_users[P]>
  }




  export type Admin_usersGroupByArgs = {
    where?: admin_usersWhereInput
    orderBy?: Enumerable<admin_usersOrderByWithAggregationInput>
    by: Array<Admin_usersScalarFieldEnum>
    having?: admin_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_usersCountAggregateInputType | true
    _avg?: Admin_usersAvgAggregateInputType
    _sum?: Admin_usersSumAggregateInputType
    _min?: Admin_usersMinAggregateInputType
    _max?: Admin_usersMaxAggregateInputType
  }


  export type Admin_usersGroupByOutputType = {
    id: number
    username: string | null
    email: string | null
    hash_pass: string | null
    first_name: string | null
    last_name: string
    phone_mobile: string | null
    address: string | null
    created_date: Date | null
    modified_date: Date | null
    created_by: number | null
    deleted: number | null
    hash_rt: string | null
    modified_by: number | null
    status: string | null
    agency_id: string | null
    _count: Admin_usersCountAggregateOutputType | null
    _avg: Admin_usersAvgAggregateOutputType | null
    _sum: Admin_usersSumAggregateOutputType | null
    _min: Admin_usersMinAggregateOutputType | null
    _max: Admin_usersMaxAggregateOutputType | null
  }

  type GetAdmin_usersGroupByPayload<T extends Admin_usersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_usersGroupByOutputType[P]>
        }
      >
    >


  export type admin_usersSelect = {
    id?: boolean
    username?: boolean
    email?: boolean
    hash_pass?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_mobile?: boolean
    address?: boolean
    created_date?: boolean
    modified_date?: boolean
    created_by?: boolean
    deleted?: boolean
    hash_rt?: boolean
    modified_by?: boolean
    status?: boolean
    agency_id?: boolean
    agencies?: boolean | agenciesArgs
    admin_users_admin_usersToadmin_users_created_by?: boolean | admin_usersArgs
    admin_users_admin_usersToadmin_users_modified_by?: boolean | admin_usersArgs
    admin_roles_admin_roles_created_byToadmin_users?: boolean | admin_rolesFindManyArgs
    admin_roles_admin_roles_modified_byToadmin_users?: boolean | admin_rolesFindManyArgs
    other_admin_users_admin_usersToadmin_users_created_by?: boolean | admin_usersFindManyArgs
    other_admin_users_admin_usersToadmin_users_modified_by?: boolean | admin_usersFindManyArgs
    admin_users_roles?: boolean | admin_users_rolesFindManyArgs
    _count?: boolean | Admin_usersCountOutputTypeArgs
  }

  export type admin_usersInclude = {
    agencies?: boolean | agenciesArgs
    admin_users_admin_usersToadmin_users_created_by?: boolean | admin_usersArgs
    admin_users_admin_usersToadmin_users_modified_by?: boolean | admin_usersArgs
    admin_roles_admin_roles_created_byToadmin_users?: boolean | admin_rolesFindManyArgs
    admin_roles_admin_roles_modified_byToadmin_users?: boolean | admin_rolesFindManyArgs
    other_admin_users_admin_usersToadmin_users_created_by?: boolean | admin_usersFindManyArgs
    other_admin_users_admin_usersToadmin_users_modified_by?: boolean | admin_usersFindManyArgs
    admin_users_roles?: boolean | admin_users_rolesFindManyArgs
    _count?: boolean | Admin_usersCountOutputTypeArgs
  }

  export type admin_usersGetPayload<
    S extends boolean | null | undefined | admin_usersArgs,
    U = keyof S
      > = S extends true
        ? admin_users
    : S extends undefined
    ? never
    : S extends admin_usersArgs | admin_usersFindManyArgs
    ?'include' extends U
    ? admin_users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_usersToadmin_users_created_by' ? admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_usersToadmin_users_modified_by' ? admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'admin_roles_admin_roles_created_byToadmin_users' ? Array < admin_rolesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'admin_roles_admin_roles_modified_byToadmin_users' ? Array < admin_rolesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'other_admin_users_admin_usersToadmin_users_created_by' ? Array < admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'other_admin_users_admin_usersToadmin_users_modified_by' ? Array < admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'admin_users_roles' ? Array < admin_users_rolesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_usersCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_usersToadmin_users_created_by' ? admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'admin_users_admin_usersToadmin_users_modified_by' ? admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'admin_roles_admin_roles_created_byToadmin_users' ? Array < admin_rolesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'admin_roles_admin_roles_modified_byToadmin_users' ? Array < admin_rolesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'other_admin_users_admin_usersToadmin_users_created_by' ? Array < admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'other_admin_users_admin_usersToadmin_users_modified_by' ? Array < admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'admin_users_roles' ? Array < admin_users_rolesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Admin_usersCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof admin_users ? admin_users[P] : never
  } 
    : admin_users
  : admin_users


  type admin_usersCountArgs = Merge<
    Omit<admin_usersFindManyArgs, 'select' | 'include'> & {
      select?: Admin_usersCountAggregateInputType | true
    }
  >

  export interface admin_usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Admin_users that matches the filter.
     * @param {admin_usersFindUniqueArgs} args - Arguments to find a Admin_users
     * @example
     * // Get one Admin_users
     * const admin_users = await prisma.admin_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admin_usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admin_usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin_users'> extends True ? CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>> : CheckSelect<T, Prisma__admin_usersClient<admin_users | null, null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | null, null>>

    /**
     * Find the first Admin_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_usersFindFirstArgs} args - Arguments to find a Admin_users
     * @example
     * // Get one Admin_users
     * const admin_users = await prisma.admin_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admin_usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admin_usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin_users'> extends True ? CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>> : CheckSelect<T, Prisma__admin_usersClient<admin_users | null, null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | null, null>>

    /**
     * Find zero or more Admin_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_users
     * const admin_users = await prisma.admin_users.findMany()
     * 
     * // Get first 10 Admin_users
     * const admin_users = await prisma.admin_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_usersWithIdOnly = await prisma.admin_users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends admin_usersFindManyArgs>(
      args?: SelectSubset<T, admin_usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admin_users>>, PrismaPromise<Array<admin_usersGetPayload<T>>>>

    /**
     * Create a Admin_users.
     * @param {admin_usersCreateArgs} args - Arguments to create a Admin_users.
     * @example
     * // Create one Admin_users
     * const Admin_users = await prisma.admin_users.create({
     *   data: {
     *     // ... data to create a Admin_users
     *   }
     * })
     * 
    **/
    create<T extends admin_usersCreateArgs>(
      args: SelectSubset<T, admin_usersCreateArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Create many Admin_users.
     *     @param {admin_usersCreateManyArgs} args - Arguments to create many Admin_users.
     *     @example
     *     // Create many Admin_users
     *     const admin_users = await prisma.admin_users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admin_usersCreateManyArgs>(
      args?: SelectSubset<T, admin_usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_users.
     * @param {admin_usersDeleteArgs} args - Arguments to delete one Admin_users.
     * @example
     * // Delete one Admin_users
     * const Admin_users = await prisma.admin_users.delete({
     *   where: {
     *     // ... filter to delete one Admin_users
     *   }
     * })
     * 
    **/
    delete<T extends admin_usersDeleteArgs>(
      args: SelectSubset<T, admin_usersDeleteArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Update one Admin_users.
     * @param {admin_usersUpdateArgs} args - Arguments to update one Admin_users.
     * @example
     * // Update one Admin_users
     * const admin_users = await prisma.admin_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admin_usersUpdateArgs>(
      args: SelectSubset<T, admin_usersUpdateArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Delete zero or more Admin_users.
     * @param {admin_usersDeleteManyArgs} args - Arguments to filter Admin_users to delete.
     * @example
     * // Delete a few Admin_users
     * const { count } = await prisma.admin_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admin_usersDeleteManyArgs>(
      args?: SelectSubset<T, admin_usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_users
     * const admin_users = await prisma.admin_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admin_usersUpdateManyArgs>(
      args: SelectSubset<T, admin_usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_users.
     * @param {admin_usersUpsertArgs} args - Arguments to update or create a Admin_users.
     * @example
     * // Update or create a Admin_users
     * const admin_users = await prisma.admin_users.upsert({
     *   create: {
     *     // ... data to create a Admin_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_users we want to update
     *   }
     * })
    **/
    upsert<T extends admin_usersUpsertArgs>(
      args: SelectSubset<T, admin_usersUpsertArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Find one Admin_users that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admin_usersFindUniqueOrThrowArgs} args - Arguments to find a Admin_users
     * @example
     * // Get one Admin_users
     * const admin_users = await prisma.admin_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admin_usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admin_usersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Find the first Admin_users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_usersFindFirstOrThrowArgs} args - Arguments to find a Admin_users
     * @example
     * // Get one Admin_users
     * const admin_users = await prisma.admin_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admin_usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admin_usersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_usersClient<admin_users>, Prisma__admin_usersClient<admin_usersGetPayload<T>>>

    /**
     * Count the number of Admin_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_usersCountArgs} args - Arguments to filter Admin_users to count.
     * @example
     * // Count the number of Admin_users
     * const count = await prisma.admin_users.count({
     *   where: {
     *     // ... the filter for the Admin_users we want to count
     *   }
     * })
    **/
    count<T extends admin_usersCountArgs>(
      args?: Subset<T, admin_usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_usersAggregateArgs>(args: Subset<T, Admin_usersAggregateArgs>): PrismaPromise<GetAdmin_usersAggregateType<T>>

    /**
     * Group by Admin_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_usersGroupByArgs['orderBy'] }
        : { orderBy?: Admin_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_usersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admin_usersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    agencies<T extends agenciesArgs = {}>(args?: Subset<T, agenciesArgs>): CheckSelect<T, Prisma__agenciesClient<agencies | Null>, Prisma__agenciesClient<agenciesGetPayload<T> | Null>>;

    admin_users_admin_usersToadmin_users_created_by<T extends admin_usersArgs = {}>(args?: Subset<T, admin_usersArgs>): CheckSelect<T, Prisma__admin_usersClient<admin_users | Null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | Null>>;

    admin_users_admin_usersToadmin_users_modified_by<T extends admin_usersArgs = {}>(args?: Subset<T, admin_usersArgs>): CheckSelect<T, Prisma__admin_usersClient<admin_users | Null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | Null>>;

    admin_roles_admin_roles_created_byToadmin_users<T extends admin_rolesFindManyArgs = {}>(args?: Subset<T, admin_rolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_roles>| Null>, PrismaPromise<Array<admin_rolesGetPayload<T>>| Null>>;

    admin_roles_admin_roles_modified_byToadmin_users<T extends admin_rolesFindManyArgs = {}>(args?: Subset<T, admin_rolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_roles>| Null>, PrismaPromise<Array<admin_rolesGetPayload<T>>| Null>>;

    other_admin_users_admin_usersToadmin_users_created_by<T extends admin_usersFindManyArgs = {}>(args?: Subset<T, admin_usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_users>| Null>, PrismaPromise<Array<admin_usersGetPayload<T>>| Null>>;

    other_admin_users_admin_usersToadmin_users_modified_by<T extends admin_usersFindManyArgs = {}>(args?: Subset<T, admin_usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_users>| Null>, PrismaPromise<Array<admin_usersGetPayload<T>>| Null>>;

    admin_users_roles<T extends admin_users_rolesFindManyArgs = {}>(args?: Subset<T, admin_users_rolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_users_roles>| Null>, PrismaPromise<Array<admin_users_rolesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin_users base type for findUnique actions
   */
  export type admin_usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * Filter, which admin_users to fetch.
     * 
    **/
    where: admin_usersWhereUniqueInput
  }

  /**
   * admin_users: findUnique
   */
  export interface admin_usersFindUniqueArgs extends admin_usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_users base type for findFirst actions
   */
  export type admin_usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * Filter, which admin_users to fetch.
     * 
    **/
    where?: admin_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_users.
     * 
    **/
    cursor?: admin_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_users.
     * 
    **/
    distinct?: Enumerable<Admin_usersScalarFieldEnum>
  }

  /**
   * admin_users: findFirst
   */
  export interface admin_usersFindFirstArgs extends admin_usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_users findMany
   */
  export type admin_usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * Filter, which admin_users to fetch.
     * 
    **/
    where?: admin_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_users.
     * 
    **/
    cursor?: admin_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_usersScalarFieldEnum>
  }


  /**
   * admin_users create
   */
  export type admin_usersCreateArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * The data needed to create a admin_users.
     * 
    **/
    data: XOR<admin_usersCreateInput, admin_usersUncheckedCreateInput>
  }


  /**
   * admin_users createMany
   */
  export type admin_usersCreateManyArgs = {
    /**
     * The data used to create many admin_users.
     * 
    **/
    data: Enumerable<admin_usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin_users update
   */
  export type admin_usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * The data needed to update a admin_users.
     * 
    **/
    data: XOR<admin_usersUpdateInput, admin_usersUncheckedUpdateInput>
    /**
     * Choose, which admin_users to update.
     * 
    **/
    where: admin_usersWhereUniqueInput
  }


  /**
   * admin_users updateMany
   */
  export type admin_usersUpdateManyArgs = {
    /**
     * The data used to update admin_users.
     * 
    **/
    data: XOR<admin_usersUpdateManyMutationInput, admin_usersUncheckedUpdateManyInput>
    /**
     * Filter which admin_users to update
     * 
    **/
    where?: admin_usersWhereInput
  }


  /**
   * admin_users upsert
   */
  export type admin_usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * The filter to search for the admin_users to update in case it exists.
     * 
    **/
    where: admin_usersWhereUniqueInput
    /**
     * In case the admin_users found by the `where` argument doesn't exist, create a new admin_users with this data.
     * 
    **/
    create: XOR<admin_usersCreateInput, admin_usersUncheckedCreateInput>
    /**
     * In case the admin_users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admin_usersUpdateInput, admin_usersUncheckedUpdateInput>
  }


  /**
   * admin_users delete
   */
  export type admin_usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
    /**
     * Filter which admin_users to delete.
     * 
    **/
    where: admin_usersWhereUniqueInput
  }


  /**
   * admin_users deleteMany
   */
  export type admin_usersDeleteManyArgs = {
    /**
     * Filter which admin_users to delete
     * 
    **/
    where?: admin_usersWhereInput
  }


  /**
   * admin_users: findUniqueOrThrow
   */
  export type admin_usersFindUniqueOrThrowArgs = admin_usersFindUniqueArgsBase
      

  /**
   * admin_users: findFirstOrThrow
   */
  export type admin_usersFindFirstOrThrowArgs = admin_usersFindFirstArgsBase
      

  /**
   * admin_users without action
   */
  export type admin_usersArgs = {
    /**
     * Select specific fields to fetch from the admin_users
     * 
    **/
    select?: admin_usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_usersInclude | null
  }



  /**
   * Model admin_users_roles
   */


  export type AggregateAdmin_users_roles = {
    _count: Admin_users_rolesCountAggregateOutputType | null
    _avg: Admin_users_rolesAvgAggregateOutputType | null
    _sum: Admin_users_rolesSumAggregateOutputType | null
    _min: Admin_users_rolesMinAggregateOutputType | null
    _max: Admin_users_rolesMaxAggregateOutputType | null
  }

  export type Admin_users_rolesAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Admin_users_rolesSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Admin_users_rolesMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Admin_users_rolesMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type Admin_users_rolesCountAggregateOutputType = {
    user_id: number
    role_id: number
    _all: number
  }


  export type Admin_users_rolesAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Admin_users_rolesSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Admin_users_rolesMinAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Admin_users_rolesMaxAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type Admin_users_rolesCountAggregateInputType = {
    user_id?: true
    role_id?: true
    _all?: true
  }

  export type Admin_users_rolesAggregateArgs = {
    /**
     * Filter which admin_users_roles to aggregate.
     * 
    **/
    where?: admin_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_users_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: admin_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_users_roles
    **/
    _count?: true | Admin_users_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_users_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_users_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_users_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_users_rolesMaxAggregateInputType
  }

  export type GetAdmin_users_rolesAggregateType<T extends Admin_users_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_users_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_users_roles[P]>
      : GetScalarType<T[P], AggregateAdmin_users_roles[P]>
  }




  export type Admin_users_rolesGroupByArgs = {
    where?: admin_users_rolesWhereInput
    orderBy?: Enumerable<admin_users_rolesOrderByWithAggregationInput>
    by: Array<Admin_users_rolesScalarFieldEnum>
    having?: admin_users_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_users_rolesCountAggregateInputType | true
    _avg?: Admin_users_rolesAvgAggregateInputType
    _sum?: Admin_users_rolesSumAggregateInputType
    _min?: Admin_users_rolesMinAggregateInputType
    _max?: Admin_users_rolesMaxAggregateInputType
  }


  export type Admin_users_rolesGroupByOutputType = {
    user_id: number
    role_id: number
    _count: Admin_users_rolesCountAggregateOutputType | null
    _avg: Admin_users_rolesAvgAggregateOutputType | null
    _sum: Admin_users_rolesSumAggregateOutputType | null
    _min: Admin_users_rolesMinAggregateOutputType | null
    _max: Admin_users_rolesMaxAggregateOutputType | null
  }

  type GetAdmin_users_rolesGroupByPayload<T extends Admin_users_rolesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Admin_users_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_users_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_users_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_users_rolesGroupByOutputType[P]>
        }
      >
    >


  export type admin_users_rolesSelect = {
    user_id?: boolean
    role_id?: boolean
    admin_roles?: boolean | admin_rolesArgs
    admin_users?: boolean | admin_usersArgs
  }

  export type admin_users_rolesInclude = {
    admin_roles?: boolean | admin_rolesArgs
    admin_users?: boolean | admin_usersArgs
  }

  export type admin_users_rolesGetPayload<
    S extends boolean | null | undefined | admin_users_rolesArgs,
    U = keyof S
      > = S extends true
        ? admin_users_roles
    : S extends undefined
    ? never
    : S extends admin_users_rolesArgs | admin_users_rolesFindManyArgs
    ?'include' extends U
    ? admin_users_roles  & {
    [P in TrueKeys<S['include']>]:
        P extends 'admin_roles' ? admin_rolesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'admin_users' ? admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'admin_roles' ? admin_rolesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'admin_users' ? admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof admin_users_roles ? admin_users_roles[P] : never
  } 
    : admin_users_roles
  : admin_users_roles


  type admin_users_rolesCountArgs = Merge<
    Omit<admin_users_rolesFindManyArgs, 'select' | 'include'> & {
      select?: Admin_users_rolesCountAggregateInputType | true
    }
  >

  export interface admin_users_rolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Admin_users_roles that matches the filter.
     * @param {admin_users_rolesFindUniqueArgs} args - Arguments to find a Admin_users_roles
     * @example
     * // Get one Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends admin_users_rolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, admin_users_rolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'admin_users_roles'> extends True ? CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>> : CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles | null, null>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T> | null, null>>

    /**
     * Find the first Admin_users_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_users_rolesFindFirstArgs} args - Arguments to find a Admin_users_roles
     * @example
     * // Get one Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends admin_users_rolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, admin_users_rolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'admin_users_roles'> extends True ? CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>> : CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles | null, null>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T> | null, null>>

    /**
     * Find zero or more Admin_users_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_users_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findMany()
     * 
     * // Get first 10 Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const admin_users_rolesWithUser_idOnly = await prisma.admin_users_roles.findMany({ select: { user_id: true } })
     * 
    **/
    findMany<T extends admin_users_rolesFindManyArgs>(
      args?: SelectSubset<T, admin_users_rolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<admin_users_roles>>, PrismaPromise<Array<admin_users_rolesGetPayload<T>>>>

    /**
     * Create a Admin_users_roles.
     * @param {admin_users_rolesCreateArgs} args - Arguments to create a Admin_users_roles.
     * @example
     * // Create one Admin_users_roles
     * const Admin_users_roles = await prisma.admin_users_roles.create({
     *   data: {
     *     // ... data to create a Admin_users_roles
     *   }
     * })
     * 
    **/
    create<T extends admin_users_rolesCreateArgs>(
      args: SelectSubset<T, admin_users_rolesCreateArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Create many Admin_users_roles.
     *     @param {admin_users_rolesCreateManyArgs} args - Arguments to create many Admin_users_roles.
     *     @example
     *     // Create many Admin_users_roles
     *     const admin_users_roles = await prisma.admin_users_roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends admin_users_rolesCreateManyArgs>(
      args?: SelectSubset<T, admin_users_rolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Admin_users_roles.
     * @param {admin_users_rolesDeleteArgs} args - Arguments to delete one Admin_users_roles.
     * @example
     * // Delete one Admin_users_roles
     * const Admin_users_roles = await prisma.admin_users_roles.delete({
     *   where: {
     *     // ... filter to delete one Admin_users_roles
     *   }
     * })
     * 
    **/
    delete<T extends admin_users_rolesDeleteArgs>(
      args: SelectSubset<T, admin_users_rolesDeleteArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Update one Admin_users_roles.
     * @param {admin_users_rolesUpdateArgs} args - Arguments to update one Admin_users_roles.
     * @example
     * // Update one Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends admin_users_rolesUpdateArgs>(
      args: SelectSubset<T, admin_users_rolesUpdateArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Delete zero or more Admin_users_roles.
     * @param {admin_users_rolesDeleteManyArgs} args - Arguments to filter Admin_users_roles to delete.
     * @example
     * // Delete a few Admin_users_roles
     * const { count } = await prisma.admin_users_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends admin_users_rolesDeleteManyArgs>(
      args?: SelectSubset<T, admin_users_rolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_users_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends admin_users_rolesUpdateManyArgs>(
      args: SelectSubset<T, admin_users_rolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin_users_roles.
     * @param {admin_users_rolesUpsertArgs} args - Arguments to update or create a Admin_users_roles.
     * @example
     * // Update or create a Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.upsert({
     *   create: {
     *     // ... data to create a Admin_users_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_users_roles we want to update
     *   }
     * })
    **/
    upsert<T extends admin_users_rolesUpsertArgs>(
      args: SelectSubset<T, admin_users_rolesUpsertArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Find one Admin_users_roles that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {admin_users_rolesFindUniqueOrThrowArgs} args - Arguments to find a Admin_users_roles
     * @example
     * // Get one Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends admin_users_rolesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, admin_users_rolesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Find the first Admin_users_roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_users_rolesFindFirstOrThrowArgs} args - Arguments to find a Admin_users_roles
     * @example
     * // Get one Admin_users_roles
     * const admin_users_roles = await prisma.admin_users_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends admin_users_rolesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, admin_users_rolesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__admin_users_rolesClient<admin_users_roles>, Prisma__admin_users_rolesClient<admin_users_rolesGetPayload<T>>>

    /**
     * Count the number of Admin_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_users_rolesCountArgs} args - Arguments to filter Admin_users_roles to count.
     * @example
     * // Count the number of Admin_users_roles
     * const count = await prisma.admin_users_roles.count({
     *   where: {
     *     // ... the filter for the Admin_users_roles we want to count
     *   }
     * })
    **/
    count<T extends admin_users_rolesCountArgs>(
      args?: Subset<T, admin_users_rolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_users_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_users_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_users_rolesAggregateArgs>(args: Subset<T, Admin_users_rolesAggregateArgs>): PrismaPromise<GetAdmin_users_rolesAggregateType<T>>

    /**
     * Group by Admin_users_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_users_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Admin_users_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Admin_users_rolesGroupByArgs['orderBy'] }
        : { orderBy?: Admin_users_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Admin_users_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_users_rolesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_users_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__admin_users_rolesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin_roles<T extends admin_rolesArgs = {}>(args?: Subset<T, admin_rolesArgs>): CheckSelect<T, Prisma__admin_rolesClient<admin_roles | Null>, Prisma__admin_rolesClient<admin_rolesGetPayload<T> | Null>>;

    admin_users<T extends admin_usersArgs = {}>(args?: Subset<T, admin_usersArgs>): CheckSelect<T, Prisma__admin_usersClient<admin_users | Null>, Prisma__admin_usersClient<admin_usersGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * admin_users_roles base type for findUnique actions
   */
  export type admin_users_rolesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * Filter, which admin_users_roles to fetch.
     * 
    **/
    where: admin_users_rolesWhereUniqueInput
  }

  /**
   * admin_users_roles: findUnique
   */
  export interface admin_users_rolesFindUniqueArgs extends admin_users_rolesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_users_roles base type for findFirst actions
   */
  export type admin_users_rolesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * Filter, which admin_users_roles to fetch.
     * 
    **/
    where?: admin_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_users_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_users_roles.
     * 
    **/
    cursor?: admin_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users_roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_users_roles.
     * 
    **/
    distinct?: Enumerable<Admin_users_rolesScalarFieldEnum>
  }

  /**
   * admin_users_roles: findFirst
   */
  export interface admin_users_rolesFindFirstArgs extends admin_users_rolesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * admin_users_roles findMany
   */
  export type admin_users_rolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * Filter, which admin_users_roles to fetch.
     * 
    **/
    where?: admin_users_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_users_roles to fetch.
     * 
    **/
    orderBy?: Enumerable<admin_users_rolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_users_roles.
     * 
    **/
    cursor?: admin_users_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_users_roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_users_roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Admin_users_rolesScalarFieldEnum>
  }


  /**
   * admin_users_roles create
   */
  export type admin_users_rolesCreateArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * The data needed to create a admin_users_roles.
     * 
    **/
    data: XOR<admin_users_rolesCreateInput, admin_users_rolesUncheckedCreateInput>
  }


  /**
   * admin_users_roles createMany
   */
  export type admin_users_rolesCreateManyArgs = {
    /**
     * The data used to create many admin_users_roles.
     * 
    **/
    data: Enumerable<admin_users_rolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * admin_users_roles update
   */
  export type admin_users_rolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * The data needed to update a admin_users_roles.
     * 
    **/
    data: XOR<admin_users_rolesUpdateInput, admin_users_rolesUncheckedUpdateInput>
    /**
     * Choose, which admin_users_roles to update.
     * 
    **/
    where: admin_users_rolesWhereUniqueInput
  }


  /**
   * admin_users_roles updateMany
   */
  export type admin_users_rolesUpdateManyArgs = {
    /**
     * The data used to update admin_users_roles.
     * 
    **/
    data: XOR<admin_users_rolesUpdateManyMutationInput, admin_users_rolesUncheckedUpdateManyInput>
    /**
     * Filter which admin_users_roles to update
     * 
    **/
    where?: admin_users_rolesWhereInput
  }


  /**
   * admin_users_roles upsert
   */
  export type admin_users_rolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * The filter to search for the admin_users_roles to update in case it exists.
     * 
    **/
    where: admin_users_rolesWhereUniqueInput
    /**
     * In case the admin_users_roles found by the `where` argument doesn't exist, create a new admin_users_roles with this data.
     * 
    **/
    create: XOR<admin_users_rolesCreateInput, admin_users_rolesUncheckedCreateInput>
    /**
     * In case the admin_users_roles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<admin_users_rolesUpdateInput, admin_users_rolesUncheckedUpdateInput>
  }


  /**
   * admin_users_roles delete
   */
  export type admin_users_rolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
    /**
     * Filter which admin_users_roles to delete.
     * 
    **/
    where: admin_users_rolesWhereUniqueInput
  }


  /**
   * admin_users_roles deleteMany
   */
  export type admin_users_rolesDeleteManyArgs = {
    /**
     * Filter which admin_users_roles to delete
     * 
    **/
    where?: admin_users_rolesWhereInput
  }


  /**
   * admin_users_roles: findUniqueOrThrow
   */
  export type admin_users_rolesFindUniqueOrThrowArgs = admin_users_rolesFindUniqueArgsBase
      

  /**
   * admin_users_roles: findFirstOrThrow
   */
  export type admin_users_rolesFindFirstOrThrowArgs = admin_users_rolesFindFirstArgsBase
      

  /**
   * admin_users_roles without action
   */
  export type admin_users_rolesArgs = {
    /**
     * Select specific fields to fetch from the admin_users_roles
     * 
    **/
    select?: admin_users_rolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: admin_users_rolesInclude | null
  }



  /**
   * Model files
   */


  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: number | null
    file_key: string | null
    file_url: string | null
  }

  export type FilesMaxAggregateOutputType = {
    id: number | null
    file_key: string | null
    file_url: string | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    file_key: number
    file_url: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    file_key?: true
    file_url?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    file_key?: true
    file_url?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    file_key?: true
    file_url?: true
    _all?: true
  }

  export type FilesAggregateArgs = {
    /**
     * Filter which files to aggregate.
     * 
    **/
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     * 
    **/
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type FilesGroupByArgs = {
    where?: filesWhereInput
    orderBy?: Enumerable<filesOrderByWithAggregationInput>
    by: Array<FilesScalarFieldEnum>
    having?: filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }


  export type FilesGroupByOutputType = {
    id: number
    file_key: string | null
    file_url: string | null
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends FilesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type filesSelect = {
    id?: boolean
    file_key?: boolean
    file_url?: boolean
  }

  export type filesGetPayload<
    S extends boolean | null | undefined | filesArgs,
    U = keyof S
      > = S extends true
        ? files
    : S extends undefined
    ? never
    : S extends filesArgs | filesFindManyArgs
    ?'include' extends U
    ? files 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof files ? files[P] : never
  } 
    : files
  : files


  type filesCountArgs = Merge<
    Omit<filesFindManyArgs, 'select' | 'include'> & {
      select?: FilesCountAggregateInputType | true
    }
  >

  export interface filesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Files that matches the filter.
     * @param {filesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends filesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, filesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'files'> extends True ? CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>> : CheckSelect<T, Prisma__filesClient<files | null, null>, Prisma__filesClient<filesGetPayload<T> | null, null>>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends filesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, filesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'files'> extends True ? CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>> : CheckSelect<T, Prisma__filesClient<files | null, null>, Prisma__filesClient<filesGetPayload<T> | null, null>>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends filesFindManyArgs>(
      args?: SelectSubset<T, filesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<files>>, PrismaPromise<Array<filesGetPayload<T>>>>

    /**
     * Create a Files.
     * @param {filesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
    **/
    create<T extends filesCreateArgs>(
      args: SelectSubset<T, filesCreateArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Create many Files.
     *     @param {filesCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const files = await prisma.files.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends filesCreateManyArgs>(
      args?: SelectSubset<T, filesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {filesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
    **/
    delete<T extends filesDeleteArgs>(
      args: SelectSubset<T, filesDeleteArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Update one Files.
     * @param {filesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends filesUpdateArgs>(
      args: SelectSubset<T, filesUpdateArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Delete zero or more Files.
     * @param {filesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends filesDeleteManyArgs>(
      args?: SelectSubset<T, filesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends filesUpdateManyArgs>(
      args: SelectSubset<T, filesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {filesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
    **/
    upsert<T extends filesUpsertArgs>(
      args: SelectSubset<T, filesUpsertArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Find one Files that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {filesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends filesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, filesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Find the first Files that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends filesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, filesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__filesClient<files>, Prisma__filesClient<filesGetPayload<T>>>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends filesCountArgs>(
      args?: Subset<T, filesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilesGroupByArgs['orderBy'] }
        : { orderBy?: FilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__filesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * files base type for findUnique actions
   */
  export type filesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     * 
    **/
    where: filesWhereUniqueInput
  }

  /**
   * files: findUnique
   */
  export interface filesFindUniqueArgs extends filesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * files base type for findFirst actions
   */
  export type filesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     * 
    **/
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     * 
    **/
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     * 
    **/
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     * 
    **/
    distinct?: Enumerable<FilesScalarFieldEnum>
  }

  /**
   * files: findFirst
   */
  export interface filesFindFirstArgs extends filesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * files findMany
   */
  export type filesFindManyArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * Filter, which files to fetch.
     * 
    **/
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     * 
    **/
    orderBy?: Enumerable<filesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     * 
    **/
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FilesScalarFieldEnum>
  }


  /**
   * files create
   */
  export type filesCreateArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * The data needed to create a files.
     * 
    **/
    data: XOR<filesCreateInput, filesUncheckedCreateInput>
  }


  /**
   * files createMany
   */
  export type filesCreateManyArgs = {
    /**
     * The data used to create many files.
     * 
    **/
    data: Enumerable<filesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * files update
   */
  export type filesUpdateArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * The data needed to update a files.
     * 
    **/
    data: XOR<filesUpdateInput, filesUncheckedUpdateInput>
    /**
     * Choose, which files to update.
     * 
    **/
    where: filesWhereUniqueInput
  }


  /**
   * files updateMany
   */
  export type filesUpdateManyArgs = {
    /**
     * The data used to update files.
     * 
    **/
    data: XOR<filesUpdateManyMutationInput, filesUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     * 
    **/
    where?: filesWhereInput
  }


  /**
   * files upsert
   */
  export type filesUpsertArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * The filter to search for the files to update in case it exists.
     * 
    **/
    where: filesWhereUniqueInput
    /**
     * In case the files found by the `where` argument doesn't exist, create a new files with this data.
     * 
    **/
    create: XOR<filesCreateInput, filesUncheckedCreateInput>
    /**
     * In case the files was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<filesUpdateInput, filesUncheckedUpdateInput>
  }


  /**
   * files delete
   */
  export type filesDeleteArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
    /**
     * Filter which files to delete.
     * 
    **/
    where: filesWhereUniqueInput
  }


  /**
   * files deleteMany
   */
  export type filesDeleteManyArgs = {
    /**
     * Filter which files to delete
     * 
    **/
    where?: filesWhereInput
  }


  /**
   * files: findUniqueOrThrow
   */
  export type filesFindUniqueOrThrowArgs = filesFindUniqueArgsBase
      

  /**
   * files: findFirstOrThrow
   */
  export type filesFindFirstOrThrowArgs = filesFindFirstArgsBase
      

  /**
   * files without action
   */
  export type filesArgs = {
    /**
     * Select specific fields to fetch from the files
     * 
    **/
    select?: filesSelect | null
  }



  /**
   * Model settings
   */


  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    category: string | null
    name: string | null
    value: string | null
    type: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    category: string | null
    name: string | null
    value: string | null
    type: string | null
  }

  export type SettingsCountAggregateOutputType = {
    category: number
    name: number
    value: number
    type: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    category?: true
    name?: true
    value?: true
    type?: true
  }

  export type SettingsMaxAggregateInputType = {
    category?: true
    name?: true
    value?: true
    type?: true
  }

  export type SettingsCountAggregateInputType = {
    category?: true
    name?: true
    value?: true
    type?: true
    _all?: true
  }

  export type SettingsAggregateArgs = {
    /**
     * Filter which settings to aggregate.
     * 
    **/
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     * 
    **/
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs = {
    where?: settingsWhereInput
    orderBy?: Enumerable<settingsOrderByWithAggregationInput>
    by: Array<SettingsScalarFieldEnum>
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }


  export type SettingsGroupByOutputType = {
    category: string
    name: string
    value: string | null
    type: string | null
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect = {
    category?: boolean
    name?: boolean
    value?: boolean
    type?: boolean
  }

  export type settingsGetPayload<
    S extends boolean | null | undefined | settingsArgs,
    U = keyof S
      > = S extends true
        ? settings
    : S extends undefined
    ? never
    : S extends settingsArgs | settingsFindManyArgs
    ?'include' extends U
    ? settings 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof settings ? settings[P] : never
  } 
    : settings
  : settings


  type settingsCountArgs = Merge<
    Omit<settingsFindManyArgs, 'select' | 'include'> & {
      select?: SettingsCountAggregateInputType | true
    }
  >

  export interface settingsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends settingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, settingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'settings'> extends True ? CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>> : CheckSelect<T, Prisma__settingsClient<settings | null, null>, Prisma__settingsClient<settingsGetPayload<T> | null, null>>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends settingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, settingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'settings'> extends True ? CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>> : CheckSelect<T, Prisma__settingsClient<settings | null, null>, Prisma__settingsClient<settingsGetPayload<T> | null, null>>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `category`
     * const settingsWithCategoryOnly = await prisma.settings.findMany({ select: { category: true } })
     * 
    **/
    findMany<T extends settingsFindManyArgs>(
      args?: SelectSubset<T, settingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<settings>>, PrismaPromise<Array<settingsGetPayload<T>>>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
    **/
    create<T extends settingsCreateArgs>(
      args: SelectSubset<T, settingsCreateArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Create many Settings.
     *     @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     *     @example
     *     // Create many Settings
     *     const settings = await prisma.settings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends settingsCreateManyArgs>(
      args?: SelectSubset<T, settingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
    **/
    delete<T extends settingsDeleteArgs>(
      args: SelectSubset<T, settingsDeleteArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends settingsUpdateArgs>(
      args: SelectSubset<T, settingsUpdateArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends settingsDeleteManyArgs>(
      args?: SelectSubset<T, settingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends settingsUpdateManyArgs>(
      args: SelectSubset<T, settingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
    **/
    upsert<T extends settingsUpsertArgs>(
      args: SelectSubset<T, settingsUpsertArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Find one Settings that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, settingsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Find the first Settings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, settingsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__settingsClient<settings>, Prisma__settingsClient<settingsGetPayload<T>>>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__settingsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * settings base type for findUnique actions
   */
  export type settingsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * Filter, which settings to fetch.
     * 
    **/
    where: settingsWhereUniqueInput
  }

  /**
   * settings: findUnique
   */
  export interface settingsFindUniqueArgs extends settingsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * settings base type for findFirst actions
   */
  export type settingsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * Filter, which settings to fetch.
     * 
    **/
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     * 
    **/
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     * 
    **/
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     * 
    **/
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }

  /**
   * settings: findFirst
   */
  export interface settingsFindFirstArgs extends settingsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * settings findMany
   */
  export type settingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * Filter, which settings to fetch.
     * 
    **/
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     * 
    **/
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     * 
    **/
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }


  /**
   * settings create
   */
  export type settingsCreateArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * The data needed to create a settings.
     * 
    **/
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }


  /**
   * settings createMany
   */
  export type settingsCreateManyArgs = {
    /**
     * The data used to create many settings.
     * 
    **/
    data: Enumerable<settingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * settings update
   */
  export type settingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * The data needed to update a settings.
     * 
    **/
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     * 
    **/
    where: settingsWhereUniqueInput
  }


  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs = {
    /**
     * The data used to update settings.
     * 
    **/
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     * 
    **/
    where?: settingsWhereInput
  }


  /**
   * settings upsert
   */
  export type settingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * The filter to search for the settings to update in case it exists.
     * 
    **/
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     * 
    **/
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }


  /**
   * settings delete
   */
  export type settingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
    /**
     * Filter which settings to delete.
     * 
    **/
    where: settingsWhereUniqueInput
  }


  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs = {
    /**
     * Filter which settings to delete
     * 
    **/
    where?: settingsWhereInput
  }


  /**
   * settings: findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs = settingsFindUniqueArgsBase
      

  /**
   * settings: findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs = settingsFindFirstArgsBase
      

  /**
   * settings without action
   */
  export type settingsArgs = {
    /**
     * Select specific fields to fetch from the settings
     * 
    **/
    select?: settingsSelect | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    deleted: number | null
    mailing_email: number | null
    mailing_text_msg: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    deleted: number | null
    mailing_email: number | null
    mailing_text_msg: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    hash_pass: string | null
    created_date: Date | null
    modified_date: Date | null
    deleted: number | null
    hash_rt: string | null
    phone: string | null
    login_type: string | null
    external_id: string | null
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    phone_prefix: string | null
    refund_bank: string | null
    refund_account_number: string | null
    refund_account_holder: string | null
    address: string | null
    hertz_membership: string | null
    airline: string | null
    mileage_number: string | null
    mailing_email: number | null
    mailing_text_msg: number | null
    birthdate: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    hash_pass: string | null
    created_date: Date | null
    modified_date: Date | null
    deleted: number | null
    hash_rt: string | null
    phone: string | null
    login_type: string | null
    external_id: string | null
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    phone_prefix: string | null
    refund_bank: string | null
    refund_account_number: string | null
    refund_account_holder: string | null
    address: string | null
    hertz_membership: string | null
    airline: string | null
    mileage_number: string | null
    mailing_email: number | null
    mailing_text_msg: number | null
    birthdate: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    hash_pass: number
    created_date: number
    modified_date: number
    deleted: number
    hash_rt: number
    phone: number
    login_type: number
    external_id: number
    korean_name: number
    first_name: number
    last_name: number
    phone_prefix: number
    refund_bank: number
    refund_account_number: number
    refund_account_holder: number
    address: number
    hertz_membership: number
    airline: number
    mileage_number: number
    mailing_email: number
    mailing_text_msg: number
    birthdate: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    deleted?: true
    mailing_email?: true
    mailing_text_msg?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    deleted?: true
    mailing_email?: true
    mailing_text_msg?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    hash_pass?: true
    created_date?: true
    modified_date?: true
    deleted?: true
    hash_rt?: true
    phone?: true
    login_type?: true
    external_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    phone_prefix?: true
    refund_bank?: true
    refund_account_number?: true
    refund_account_holder?: true
    address?: true
    hertz_membership?: true
    airline?: true
    mileage_number?: true
    mailing_email?: true
    mailing_text_msg?: true
    birthdate?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    hash_pass?: true
    created_date?: true
    modified_date?: true
    deleted?: true
    hash_rt?: true
    phone?: true
    login_type?: true
    external_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    phone_prefix?: true
    refund_bank?: true
    refund_account_number?: true
    refund_account_holder?: true
    address?: true
    hertz_membership?: true
    airline?: true
    mileage_number?: true
    mailing_email?: true
    mailing_text_msg?: true
    birthdate?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    hash_pass?: true
    created_date?: true
    modified_date?: true
    deleted?: true
    hash_rt?: true
    phone?: true
    login_type?: true
    external_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    phone_prefix?: true
    refund_bank?: true
    refund_account_number?: true
    refund_account_holder?: true
    address?: true
    hertz_membership?: true
    airline?: true
    mileage_number?: true
    mailing_email?: true
    mailing_text_msg?: true
    birthdate?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    email: string
    hash_pass: string | null
    created_date: Date | null
    modified_date: Date | null
    deleted: number | null
    hash_rt: string | null
    phone: string | null
    login_type: string | null
    external_id: string | null
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    phone_prefix: string | null
    refund_bank: string | null
    refund_account_number: string | null
    refund_account_holder: string | null
    address: string | null
    hertz_membership: string | null
    airline: string | null
    mileage_number: string | null
    mailing_email: number | null
    mailing_text_msg: number | null
    birthdate: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    email?: boolean
    hash_pass?: boolean
    created_date?: boolean
    modified_date?: boolean
    deleted?: boolean
    hash_rt?: boolean
    phone?: boolean
    login_type?: boolean
    external_id?: boolean
    korean_name?: boolean
    first_name?: boolean
    last_name?: boolean
    phone_prefix?: boolean
    refund_bank?: boolean
    refund_account_number?: boolean
    refund_account_holder?: boolean
    address?: boolean
    hertz_membership?: boolean
    airline?: boolean
    mileage_number?: boolean
    mailing_email?: boolean
    mailing_text_msg?: boolean
    birthdate?: boolean
    payment?: boolean | paymentFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    payment?: boolean | paymentFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'payment' ? Array < paymentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'payment' ? Array < paymentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof users ? users[P] : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null, null>, Prisma__usersClient<usersGetPayload<T> | null, null>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null, null>, Prisma__usersClient<usersGetPayload<T> | null, null>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find one Users that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payment<T extends paymentFindManyArgs = {}>(args?: Subset<T, paymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<payment>| Null>, PrismaPromise<Array<paymentGetPayload<T>>| Null>>;

    reservation<T extends reservationFindManyArgs = {}>(args?: Subset<T, reservationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reservation>| Null>, PrismaPromise<Array<reservationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }

  /**
   * users: findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users: findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users: findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = usersFindUniqueArgsBase
      

  /**
   * users: findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = usersFindFirstArgsBase
      

  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Model packages
   */


  export type AggregatePackages = {
    _count: PackagesCountAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  export type PackagesMinAggregateOutputType = {
    price_id: string | null
    service_id: string | null
  }

  export type PackagesMaxAggregateOutputType = {
    price_id: string | null
    service_id: string | null
  }

  export type PackagesCountAggregateOutputType = {
    price_id: number
    service_id: number
    _all: number
  }


  export type PackagesMinAggregateInputType = {
    price_id?: true
    service_id?: true
  }

  export type PackagesMaxAggregateInputType = {
    price_id?: true
    service_id?: true
  }

  export type PackagesCountAggregateInputType = {
    price_id?: true
    service_id?: true
    _all?: true
  }

  export type PackagesAggregateArgs = {
    /**
     * Filter which packages to aggregate.
     * 
    **/
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     * 
    **/
    orderBy?: Enumerable<packagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned packages
    **/
    _count?: true | PackagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagesMaxAggregateInputType
  }

  export type GetPackagesAggregateType<T extends PackagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePackages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackages[P]>
      : GetScalarType<T[P], AggregatePackages[P]>
  }




  export type PackagesGroupByArgs = {
    where?: packagesWhereInput
    orderBy?: Enumerable<packagesOrderByWithAggregationInput>
    by: Array<PackagesScalarFieldEnum>
    having?: packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagesCountAggregateInputType | true
    _min?: PackagesMinAggregateInputType
    _max?: PackagesMaxAggregateInputType
  }


  export type PackagesGroupByOutputType = {
    price_id: string
    service_id: string
    _count: PackagesCountAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  type GetPackagesGroupByPayload<T extends PackagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PackagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagesGroupByOutputType[P]>
            : GetScalarType<T[P], PackagesGroupByOutputType[P]>
        }
      >
    >


  export type packagesSelect = {
    price_id?: boolean
    service_id?: boolean
    price_codes?: boolean | price_codesArgs
    services?: boolean | servicesArgs
  }

  export type packagesInclude = {
    price_codes?: boolean | price_codesArgs
    services?: boolean | servicesArgs
  }

  export type packagesGetPayload<
    S extends boolean | null | undefined | packagesArgs,
    U = keyof S
      > = S extends true
        ? packages
    : S extends undefined
    ? never
    : S extends packagesArgs | packagesFindManyArgs
    ?'include' extends U
    ? packages  & {
    [P in TrueKeys<S['include']>]:
        P extends 'price_codes' ? price_codesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'services' ? servicesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'price_codes' ? price_codesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'services' ? servicesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof packages ? packages[P] : never
  } 
    : packages
  : packages


  type packagesCountArgs = Merge<
    Omit<packagesFindManyArgs, 'select' | 'include'> & {
      select?: PackagesCountAggregateInputType | true
    }
  >

  export interface packagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Packages that matches the filter.
     * @param {packagesFindUniqueArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends packagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, packagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'packages'> extends True ? CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>> : CheckSelect<T, Prisma__packagesClient<packages | null, null>, Prisma__packagesClient<packagesGetPayload<T> | null, null>>

    /**
     * Find the first Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends packagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, packagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'packages'> extends True ? CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>> : CheckSelect<T, Prisma__packagesClient<packages | null, null>, Prisma__packagesClient<packagesGetPayload<T> | null, null>>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.packages.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.packages.findMany({ take: 10 })
     * 
     * // Only select the `price_id`
     * const packagesWithPrice_idOnly = await prisma.packages.findMany({ select: { price_id: true } })
     * 
    **/
    findMany<T extends packagesFindManyArgs>(
      args?: SelectSubset<T, packagesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<packages>>, PrismaPromise<Array<packagesGetPayload<T>>>>

    /**
     * Create a Packages.
     * @param {packagesCreateArgs} args - Arguments to create a Packages.
     * @example
     * // Create one Packages
     * const Packages = await prisma.packages.create({
     *   data: {
     *     // ... data to create a Packages
     *   }
     * })
     * 
    **/
    create<T extends packagesCreateArgs>(
      args: SelectSubset<T, packagesCreateArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Create many Packages.
     *     @param {packagesCreateManyArgs} args - Arguments to create many Packages.
     *     @example
     *     // Create many Packages
     *     const packages = await prisma.packages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends packagesCreateManyArgs>(
      args?: SelectSubset<T, packagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Packages.
     * @param {packagesDeleteArgs} args - Arguments to delete one Packages.
     * @example
     * // Delete one Packages
     * const Packages = await prisma.packages.delete({
     *   where: {
     *     // ... filter to delete one Packages
     *   }
     * })
     * 
    **/
    delete<T extends packagesDeleteArgs>(
      args: SelectSubset<T, packagesDeleteArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Update one Packages.
     * @param {packagesUpdateArgs} args - Arguments to update one Packages.
     * @example
     * // Update one Packages
     * const packages = await prisma.packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends packagesUpdateArgs>(
      args: SelectSubset<T, packagesUpdateArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Delete zero or more Packages.
     * @param {packagesDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends packagesDeleteManyArgs>(
      args?: SelectSubset<T, packagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends packagesUpdateManyArgs>(
      args: SelectSubset<T, packagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Packages.
     * @param {packagesUpsertArgs} args - Arguments to update or create a Packages.
     * @example
     * // Update or create a Packages
     * const packages = await prisma.packages.upsert({
     *   create: {
     *     // ... data to create a Packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Packages we want to update
     *   }
     * })
    **/
    upsert<T extends packagesUpsertArgs>(
      args: SelectSubset<T, packagesUpsertArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Find one Packages that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {packagesFindUniqueOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends packagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, packagesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Find the first Packages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends packagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, packagesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__packagesClient<packages>, Prisma__packagesClient<packagesGetPayload<T>>>

    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.packages.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends packagesCountArgs>(
      args?: Subset<T, packagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagesAggregateArgs>(args: Subset<T, PackagesAggregateArgs>): PrismaPromise<GetPackagesAggregateType<T>>

    /**
     * Group by Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackagesGroupByArgs['orderBy'] }
        : { orderBy?: PackagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__packagesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    price_codes<T extends price_codesArgs = {}>(args?: Subset<T, price_codesArgs>): CheckSelect<T, Prisma__price_codesClient<price_codes | Null>, Prisma__price_codesClient<price_codesGetPayload<T> | Null>>;

    services<T extends servicesArgs = {}>(args?: Subset<T, servicesArgs>): CheckSelect<T, Prisma__servicesClient<services | Null>, Prisma__servicesClient<servicesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * packages base type for findUnique actions
   */
  export type packagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * Filter, which packages to fetch.
     * 
    **/
    where: packagesWhereUniqueInput
  }

  /**
   * packages: findUnique
   */
  export interface packagesFindUniqueArgs extends packagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * packages base type for findFirst actions
   */
  export type packagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * Filter, which packages to fetch.
     * 
    **/
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     * 
    **/
    orderBy?: Enumerable<packagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     * 
    **/
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     * 
    **/
    distinct?: Enumerable<PackagesScalarFieldEnum>
  }

  /**
   * packages: findFirst
   */
  export interface packagesFindFirstArgs extends packagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * packages findMany
   */
  export type packagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * Filter, which packages to fetch.
     * 
    **/
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     * 
    **/
    orderBy?: Enumerable<packagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing packages.
     * 
    **/
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PackagesScalarFieldEnum>
  }


  /**
   * packages create
   */
  export type packagesCreateArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * The data needed to create a packages.
     * 
    **/
    data: XOR<packagesCreateInput, packagesUncheckedCreateInput>
  }


  /**
   * packages createMany
   */
  export type packagesCreateManyArgs = {
    /**
     * The data used to create many packages.
     * 
    **/
    data: Enumerable<packagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * packages update
   */
  export type packagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * The data needed to update a packages.
     * 
    **/
    data: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
    /**
     * Choose, which packages to update.
     * 
    **/
    where: packagesWhereUniqueInput
  }


  /**
   * packages updateMany
   */
  export type packagesUpdateManyArgs = {
    /**
     * The data used to update packages.
     * 
    **/
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     * 
    **/
    where?: packagesWhereInput
  }


  /**
   * packages upsert
   */
  export type packagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * The filter to search for the packages to update in case it exists.
     * 
    **/
    where: packagesWhereUniqueInput
    /**
     * In case the packages found by the `where` argument doesn't exist, create a new packages with this data.
     * 
    **/
    create: XOR<packagesCreateInput, packagesUncheckedCreateInput>
    /**
     * In case the packages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
  }


  /**
   * packages delete
   */
  export type packagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
    /**
     * Filter which packages to delete.
     * 
    **/
    where: packagesWhereUniqueInput
  }


  /**
   * packages deleteMany
   */
  export type packagesDeleteManyArgs = {
    /**
     * Filter which packages to delete
     * 
    **/
    where?: packagesWhereInput
  }


  /**
   * packages: findUniqueOrThrow
   */
  export type packagesFindUniqueOrThrowArgs = packagesFindUniqueArgsBase
      

  /**
   * packages: findFirstOrThrow
   */
  export type packagesFindFirstOrThrowArgs = packagesFindFirstArgsBase
      

  /**
   * packages without action
   */
  export type packagesArgs = {
    /**
     * Select specific fields to fetch from the packages
     * 
    **/
    select?: packagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: packagesInclude | null
  }



  /**
   * Model price_codes
   */


  export type AggregatePrice_codes = {
    _count: Price_codesCountAggregateOutputType | null
    _min: Price_codesMinAggregateOutputType | null
    _max: Price_codesMaxAggregateOutputType | null
  }

  export type Price_codesMinAggregateOutputType = {
    id: string | null
    price_code: string | null
    country_code: string | null
    name: string | null
    price_type: string | null
    vendor_id: string | null
    ITCode: string | null
    cdpNumber: string | null
    show: boolean | null
    insurance: boolean | null
    ko_name: string | null
  }

  export type Price_codesMaxAggregateOutputType = {
    id: string | null
    price_code: string | null
    country_code: string | null
    name: string | null
    price_type: string | null
    vendor_id: string | null
    ITCode: string | null
    cdpNumber: string | null
    show: boolean | null
    insurance: boolean | null
    ko_name: string | null
  }

  export type Price_codesCountAggregateOutputType = {
    id: number
    price_code: number
    country_code: number
    name: number
    price_type: number
    vendor_id: number
    ITCode: number
    cdpNumber: number
    show: number
    insurance: number
    ko_name: number
    _all: number
  }


  export type Price_codesMinAggregateInputType = {
    id?: true
    price_code?: true
    country_code?: true
    name?: true
    price_type?: true
    vendor_id?: true
    ITCode?: true
    cdpNumber?: true
    show?: true
    insurance?: true
    ko_name?: true
  }

  export type Price_codesMaxAggregateInputType = {
    id?: true
    price_code?: true
    country_code?: true
    name?: true
    price_type?: true
    vendor_id?: true
    ITCode?: true
    cdpNumber?: true
    show?: true
    insurance?: true
    ko_name?: true
  }

  export type Price_codesCountAggregateInputType = {
    id?: true
    price_code?: true
    country_code?: true
    name?: true
    price_type?: true
    vendor_id?: true
    ITCode?: true
    cdpNumber?: true
    show?: true
    insurance?: true
    ko_name?: true
    _all?: true
  }

  export type Price_codesAggregateArgs = {
    /**
     * Filter which price_codes to aggregate.
     * 
    **/
    where?: price_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_codesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: price_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_codes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned price_codes
    **/
    _count?: true | Price_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Price_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Price_codesMaxAggregateInputType
  }

  export type GetPrice_codesAggregateType<T extends Price_codesAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice_codes[P]>
      : GetScalarType<T[P], AggregatePrice_codes[P]>
  }




  export type Price_codesGroupByArgs = {
    where?: price_codesWhereInput
    orderBy?: Enumerable<price_codesOrderByWithAggregationInput>
    by: Array<Price_codesScalarFieldEnum>
    having?: price_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Price_codesCountAggregateInputType | true
    _min?: Price_codesMinAggregateInputType
    _max?: Price_codesMaxAggregateInputType
  }


  export type Price_codesGroupByOutputType = {
    id: string
    price_code: string
    country_code: string
    name: string | null
    price_type: string | null
    vendor_id: string | null
    ITCode: string | null
    cdpNumber: string | null
    show: boolean | null
    insurance: boolean | null
    ko_name: string | null
    _count: Price_codesCountAggregateOutputType | null
    _min: Price_codesMinAggregateOutputType | null
    _max: Price_codesMaxAggregateOutputType | null
  }

  type GetPrice_codesGroupByPayload<T extends Price_codesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Price_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Price_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Price_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Price_codesGroupByOutputType[P]>
        }
      >
    >


  export type price_codesSelect = {
    id?: boolean
    price_code?: boolean
    country_code?: boolean
    name?: boolean
    price_type?: boolean
    vendor_id?: boolean
    ITCode?: boolean
    cdpNumber?: boolean
    show?: boolean
    insurance?: boolean
    ko_name?: boolean
    packages?: boolean | packagesFindManyArgs
    _count?: boolean | Price_codesCountOutputTypeArgs
  }

  export type price_codesInclude = {
    packages?: boolean | packagesFindManyArgs
    _count?: boolean | Price_codesCountOutputTypeArgs
  }

  export type price_codesGetPayload<
    S extends boolean | null | undefined | price_codesArgs,
    U = keyof S
      > = S extends true
        ? price_codes
    : S extends undefined
    ? never
    : S extends price_codesArgs | price_codesFindManyArgs
    ?'include' extends U
    ? price_codes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'packages' ? Array < packagesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Price_codesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'packages' ? Array < packagesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Price_codesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof price_codes ? price_codes[P] : never
  } 
    : price_codes
  : price_codes


  type price_codesCountArgs = Merge<
    Omit<price_codesFindManyArgs, 'select' | 'include'> & {
      select?: Price_codesCountAggregateInputType | true
    }
  >

  export interface price_codesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Price_codes that matches the filter.
     * @param {price_codesFindUniqueArgs} args - Arguments to find a Price_codes
     * @example
     * // Get one Price_codes
     * const price_codes = await prisma.price_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends price_codesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, price_codesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'price_codes'> extends True ? CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>> : CheckSelect<T, Prisma__price_codesClient<price_codes | null, null>, Prisma__price_codesClient<price_codesGetPayload<T> | null, null>>

    /**
     * Find the first Price_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_codesFindFirstArgs} args - Arguments to find a Price_codes
     * @example
     * // Get one Price_codes
     * const price_codes = await prisma.price_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends price_codesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, price_codesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'price_codes'> extends True ? CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>> : CheckSelect<T, Prisma__price_codesClient<price_codes | null, null>, Prisma__price_codesClient<price_codesGetPayload<T> | null, null>>

    /**
     * Find zero or more Price_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_codesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Price_codes
     * const price_codes = await prisma.price_codes.findMany()
     * 
     * // Get first 10 Price_codes
     * const price_codes = await prisma.price_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const price_codesWithIdOnly = await prisma.price_codes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends price_codesFindManyArgs>(
      args?: SelectSubset<T, price_codesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<price_codes>>, PrismaPromise<Array<price_codesGetPayload<T>>>>

    /**
     * Create a Price_codes.
     * @param {price_codesCreateArgs} args - Arguments to create a Price_codes.
     * @example
     * // Create one Price_codes
     * const Price_codes = await prisma.price_codes.create({
     *   data: {
     *     // ... data to create a Price_codes
     *   }
     * })
     * 
    **/
    create<T extends price_codesCreateArgs>(
      args: SelectSubset<T, price_codesCreateArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Create many Price_codes.
     *     @param {price_codesCreateManyArgs} args - Arguments to create many Price_codes.
     *     @example
     *     // Create many Price_codes
     *     const price_codes = await prisma.price_codes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends price_codesCreateManyArgs>(
      args?: SelectSubset<T, price_codesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Price_codes.
     * @param {price_codesDeleteArgs} args - Arguments to delete one Price_codes.
     * @example
     * // Delete one Price_codes
     * const Price_codes = await prisma.price_codes.delete({
     *   where: {
     *     // ... filter to delete one Price_codes
     *   }
     * })
     * 
    **/
    delete<T extends price_codesDeleteArgs>(
      args: SelectSubset<T, price_codesDeleteArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Update one Price_codes.
     * @param {price_codesUpdateArgs} args - Arguments to update one Price_codes.
     * @example
     * // Update one Price_codes
     * const price_codes = await prisma.price_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends price_codesUpdateArgs>(
      args: SelectSubset<T, price_codesUpdateArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Delete zero or more Price_codes.
     * @param {price_codesDeleteManyArgs} args - Arguments to filter Price_codes to delete.
     * @example
     * // Delete a few Price_codes
     * const { count } = await prisma.price_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends price_codesDeleteManyArgs>(
      args?: SelectSubset<T, price_codesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Price_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Price_codes
     * const price_codes = await prisma.price_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends price_codesUpdateManyArgs>(
      args: SelectSubset<T, price_codesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Price_codes.
     * @param {price_codesUpsertArgs} args - Arguments to update or create a Price_codes.
     * @example
     * // Update or create a Price_codes
     * const price_codes = await prisma.price_codes.upsert({
     *   create: {
     *     // ... data to create a Price_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price_codes we want to update
     *   }
     * })
    **/
    upsert<T extends price_codesUpsertArgs>(
      args: SelectSubset<T, price_codesUpsertArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Find one Price_codes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {price_codesFindUniqueOrThrowArgs} args - Arguments to find a Price_codes
     * @example
     * // Get one Price_codes
     * const price_codes = await prisma.price_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends price_codesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, price_codesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Find the first Price_codes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_codesFindFirstOrThrowArgs} args - Arguments to find a Price_codes
     * @example
     * // Get one Price_codes
     * const price_codes = await prisma.price_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends price_codesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, price_codesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__price_codesClient<price_codes>, Prisma__price_codesClient<price_codesGetPayload<T>>>

    /**
     * Count the number of Price_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {price_codesCountArgs} args - Arguments to filter Price_codes to count.
     * @example
     * // Count the number of Price_codes
     * const count = await prisma.price_codes.count({
     *   where: {
     *     // ... the filter for the Price_codes we want to count
     *   }
     * })
    **/
    count<T extends price_codesCountArgs>(
      args?: Subset<T, price_codesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Price_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Price_codesAggregateArgs>(args: Subset<T, Price_codesAggregateArgs>): PrismaPromise<GetPrice_codesAggregateType<T>>

    /**
     * Group by Price_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Price_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Price_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Price_codesGroupByArgs['orderBy'] }
        : { orderBy?: Price_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Price_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrice_codesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for price_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__price_codesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    packages<T extends packagesFindManyArgs = {}>(args?: Subset<T, packagesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<packages>| Null>, PrismaPromise<Array<packagesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * price_codes base type for findUnique actions
   */
  export type price_codesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * Filter, which price_codes to fetch.
     * 
    **/
    where: price_codesWhereUniqueInput
  }

  /**
   * price_codes: findUnique
   */
  export interface price_codesFindUniqueArgs extends price_codesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * price_codes base type for findFirst actions
   */
  export type price_codesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * Filter, which price_codes to fetch.
     * 
    **/
    where?: price_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_codesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for price_codes.
     * 
    **/
    cursor?: price_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_codes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of price_codes.
     * 
    **/
    distinct?: Enumerable<Price_codesScalarFieldEnum>
  }

  /**
   * price_codes: findFirst
   */
  export interface price_codesFindFirstArgs extends price_codesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * price_codes findMany
   */
  export type price_codesFindManyArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * Filter, which price_codes to fetch.
     * 
    **/
    where?: price_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of price_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<price_codesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing price_codes.
     * 
    **/
    cursor?: price_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` price_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` price_codes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Price_codesScalarFieldEnum>
  }


  /**
   * price_codes create
   */
  export type price_codesCreateArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * The data needed to create a price_codes.
     * 
    **/
    data: XOR<price_codesCreateInput, price_codesUncheckedCreateInput>
  }


  /**
   * price_codes createMany
   */
  export type price_codesCreateManyArgs = {
    /**
     * The data used to create many price_codes.
     * 
    **/
    data: Enumerable<price_codesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * price_codes update
   */
  export type price_codesUpdateArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * The data needed to update a price_codes.
     * 
    **/
    data: XOR<price_codesUpdateInput, price_codesUncheckedUpdateInput>
    /**
     * Choose, which price_codes to update.
     * 
    **/
    where: price_codesWhereUniqueInput
  }


  /**
   * price_codes updateMany
   */
  export type price_codesUpdateManyArgs = {
    /**
     * The data used to update price_codes.
     * 
    **/
    data: XOR<price_codesUpdateManyMutationInput, price_codesUncheckedUpdateManyInput>
    /**
     * Filter which price_codes to update
     * 
    **/
    where?: price_codesWhereInput
  }


  /**
   * price_codes upsert
   */
  export type price_codesUpsertArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * The filter to search for the price_codes to update in case it exists.
     * 
    **/
    where: price_codesWhereUniqueInput
    /**
     * In case the price_codes found by the `where` argument doesn't exist, create a new price_codes with this data.
     * 
    **/
    create: XOR<price_codesCreateInput, price_codesUncheckedCreateInput>
    /**
     * In case the price_codes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<price_codesUpdateInput, price_codesUncheckedUpdateInput>
  }


  /**
   * price_codes delete
   */
  export type price_codesDeleteArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
    /**
     * Filter which price_codes to delete.
     * 
    **/
    where: price_codesWhereUniqueInput
  }


  /**
   * price_codes deleteMany
   */
  export type price_codesDeleteManyArgs = {
    /**
     * Filter which price_codes to delete
     * 
    **/
    where?: price_codesWhereInput
  }


  /**
   * price_codes: findUniqueOrThrow
   */
  export type price_codesFindUniqueOrThrowArgs = price_codesFindUniqueArgsBase
      

  /**
   * price_codes: findFirstOrThrow
   */
  export type price_codesFindFirstOrThrowArgs = price_codesFindFirstArgsBase
      

  /**
   * price_codes without action
   */
  export type price_codesArgs = {
    /**
     * Select specific fields to fetch from the price_codes
     * 
    **/
    select?: price_codesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: price_codesInclude | null
  }



  /**
   * Model reservation
   */


  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    exchange_rate: Decimal | null
    user_id: number | null
    dropFee: Decimal | null
    rate_amount: Decimal | null
    rate_foreigner_amount: Decimal | null
    total_amount: Decimal | null
    total_foreigner_amount: Decimal | null
  }

  export type ReservationSumAggregateOutputType = {
    exchange_rate: Decimal | null
    user_id: number | null
    dropFee: Decimal | null
    rate_amount: Decimal | null
    rate_foreigner_amount: Decimal | null
    total_amount: Decimal | null
    total_foreigner_amount: Decimal | null
  }

  export type ReservationMinAggregateOutputType = {
    supplier: string | null
    agent_name: string | null
    agent: string | null
    date_request: Date | null
    res_status: string | null
    invoice: string | null
    res_id: string | null
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    pickup_loc: string | null
    return_loc: string | null
    pickup_datetime: string | null
    return_datetime: string | null
    pay_type: string | null
    currency: string | null
    exchange_rate: Decimal | null
    user_id: number | null
    car_model: string | null
    extra_equipmens: string | null
    insurance_info: string | null
    office_address: string | null
    office_name: string | null
    office_time: string | null
    phone_code: string | null
    phone_number: string | null
    services: string | null
    size_car: string | null
    type_car: string | null
    date_cancel: Date | null
    email: string | null
    flight_brand: string | null
    flight_number: string | null
    frequent_flyer: string | null
    hertz_membership: string | null
    office_second_address: string | null
    office_second_name: string | null
    office_second_time: string | null
    dropFee: Decimal | null
    rate_amount: Decimal | null
    rate_foreigner_amount: Decimal | null
    tax: string | null
    total_amount: Decimal | null
    total_foreigner_amount: Decimal | null
  }

  export type ReservationMaxAggregateOutputType = {
    supplier: string | null
    agent_name: string | null
    agent: string | null
    date_request: Date | null
    res_status: string | null
    invoice: string | null
    res_id: string | null
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    pickup_loc: string | null
    return_loc: string | null
    pickup_datetime: string | null
    return_datetime: string | null
    pay_type: string | null
    currency: string | null
    exchange_rate: Decimal | null
    user_id: number | null
    car_model: string | null
    extra_equipmens: string | null
    insurance_info: string | null
    office_address: string | null
    office_name: string | null
    office_time: string | null
    phone_code: string | null
    phone_number: string | null
    services: string | null
    size_car: string | null
    type_car: string | null
    date_cancel: Date | null
    email: string | null
    flight_brand: string | null
    flight_number: string | null
    frequent_flyer: string | null
    hertz_membership: string | null
    office_second_address: string | null
    office_second_name: string | null
    office_second_time: string | null
    dropFee: Decimal | null
    rate_amount: Decimal | null
    rate_foreigner_amount: Decimal | null
    tax: string | null
    total_amount: Decimal | null
    total_foreigner_amount: Decimal | null
  }

  export type ReservationCountAggregateOutputType = {
    supplier: number
    agent_name: number
    agent: number
    date_request: number
    res_status: number
    invoice: number
    res_id: number
    korean_name: number
    first_name: number
    last_name: number
    pickup_loc: number
    return_loc: number
    pickup_datetime: number
    return_datetime: number
    pay_type: number
    currency: number
    exchange_rate: number
    user_id: number
    car_model: number
    extra_equipmens: number
    insurance_info: number
    office_address: number
    office_name: number
    office_time: number
    phone_code: number
    phone_number: number
    services: number
    size_car: number
    type_car: number
    date_cancel: number
    email: number
    flight_brand: number
    flight_number: number
    frequent_flyer: number
    hertz_membership: number
    office_second_address: number
    office_second_name: number
    office_second_time: number
    dropFee: number
    rate_amount: number
    rate_foreigner_amount: number
    tax: number
    total_amount: number
    total_foreigner_amount: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    exchange_rate?: true
    user_id?: true
    dropFee?: true
    rate_amount?: true
    rate_foreigner_amount?: true
    total_amount?: true
    total_foreigner_amount?: true
  }

  export type ReservationSumAggregateInputType = {
    exchange_rate?: true
    user_id?: true
    dropFee?: true
    rate_amount?: true
    rate_foreigner_amount?: true
    total_amount?: true
    total_foreigner_amount?: true
  }

  export type ReservationMinAggregateInputType = {
    supplier?: true
    agent_name?: true
    agent?: true
    date_request?: true
    res_status?: true
    invoice?: true
    res_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    pickup_loc?: true
    return_loc?: true
    pickup_datetime?: true
    return_datetime?: true
    pay_type?: true
    currency?: true
    exchange_rate?: true
    user_id?: true
    car_model?: true
    extra_equipmens?: true
    insurance_info?: true
    office_address?: true
    office_name?: true
    office_time?: true
    phone_code?: true
    phone_number?: true
    services?: true
    size_car?: true
    type_car?: true
    date_cancel?: true
    email?: true
    flight_brand?: true
    flight_number?: true
    frequent_flyer?: true
    hertz_membership?: true
    office_second_address?: true
    office_second_name?: true
    office_second_time?: true
    dropFee?: true
    rate_amount?: true
    rate_foreigner_amount?: true
    tax?: true
    total_amount?: true
    total_foreigner_amount?: true
  }

  export type ReservationMaxAggregateInputType = {
    supplier?: true
    agent_name?: true
    agent?: true
    date_request?: true
    res_status?: true
    invoice?: true
    res_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    pickup_loc?: true
    return_loc?: true
    pickup_datetime?: true
    return_datetime?: true
    pay_type?: true
    currency?: true
    exchange_rate?: true
    user_id?: true
    car_model?: true
    extra_equipmens?: true
    insurance_info?: true
    office_address?: true
    office_name?: true
    office_time?: true
    phone_code?: true
    phone_number?: true
    services?: true
    size_car?: true
    type_car?: true
    date_cancel?: true
    email?: true
    flight_brand?: true
    flight_number?: true
    frequent_flyer?: true
    hertz_membership?: true
    office_second_address?: true
    office_second_name?: true
    office_second_time?: true
    dropFee?: true
    rate_amount?: true
    rate_foreigner_amount?: true
    tax?: true
    total_amount?: true
    total_foreigner_amount?: true
  }

  export type ReservationCountAggregateInputType = {
    supplier?: true
    agent_name?: true
    agent?: true
    date_request?: true
    res_status?: true
    invoice?: true
    res_id?: true
    korean_name?: true
    first_name?: true
    last_name?: true
    pickup_loc?: true
    return_loc?: true
    pickup_datetime?: true
    return_datetime?: true
    pay_type?: true
    currency?: true
    exchange_rate?: true
    user_id?: true
    car_model?: true
    extra_equipmens?: true
    insurance_info?: true
    office_address?: true
    office_name?: true
    office_time?: true
    phone_code?: true
    phone_number?: true
    services?: true
    size_car?: true
    type_car?: true
    date_cancel?: true
    email?: true
    flight_brand?: true
    flight_number?: true
    frequent_flyer?: true
    hertz_membership?: true
    office_second_address?: true
    office_second_name?: true
    office_second_time?: true
    dropFee?: true
    rate_amount?: true
    rate_foreigner_amount?: true
    tax?: true
    total_amount?: true
    total_foreigner_amount?: true
    _all?: true
  }

  export type ReservationAggregateArgs = {
    /**
     * Filter which reservation to aggregate.
     * 
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     * 
    **/
    orderBy?: Enumerable<reservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs = {
    where?: reservationWhereInput
    orderBy?: Enumerable<reservationOrderByWithAggregationInput>
    by: Array<ReservationScalarFieldEnum>
    having?: reservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }


  export type ReservationGroupByOutputType = {
    supplier: string | null
    agent_name: string | null
    agent: string | null
    date_request: Date | null
    res_status: string | null
    invoice: string | null
    res_id: string
    korean_name: string | null
    first_name: string | null
    last_name: string | null
    pickup_loc: string | null
    return_loc: string | null
    pickup_datetime: string | null
    return_datetime: string | null
    pay_type: string | null
    currency: string | null
    exchange_rate: Decimal | null
    user_id: number | null
    car_model: string | null
    extra_equipmens: string | null
    insurance_info: string | null
    office_address: string | null
    office_name: string | null
    office_time: string | null
    phone_code: string | null
    phone_number: string | null
    services: string | null
    size_car: string | null
    type_car: string | null
    date_cancel: Date | null
    email: string | null
    flight_brand: string | null
    flight_number: string | null
    frequent_flyer: string | null
    hertz_membership: string | null
    office_second_address: string | null
    office_second_name: string | null
    office_second_time: string | null
    dropFee: Decimal | null
    rate_amount: Decimal | null
    rate_foreigner_amount: Decimal | null
    tax: string | null
    total_amount: Decimal | null
    total_foreigner_amount: Decimal | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type reservationSelect = {
    supplier?: boolean
    agent_name?: boolean
    agent?: boolean
    date_request?: boolean
    res_status?: boolean
    invoice?: boolean
    res_id?: boolean
    korean_name?: boolean
    first_name?: boolean
    last_name?: boolean
    pickup_loc?: boolean
    return_loc?: boolean
    pickup_datetime?: boolean
    return_datetime?: boolean
    pay_type?: boolean
    currency?: boolean
    exchange_rate?: boolean
    user_id?: boolean
    car_model?: boolean
    extra_equipmens?: boolean
    insurance_info?: boolean
    office_address?: boolean
    office_name?: boolean
    office_time?: boolean
    phone_code?: boolean
    phone_number?: boolean
    services?: boolean
    size_car?: boolean
    type_car?: boolean
    date_cancel?: boolean
    email?: boolean
    flight_brand?: boolean
    flight_number?: boolean
    frequent_flyer?: boolean
    hertz_membership?: boolean
    office_second_address?: boolean
    office_second_name?: boolean
    office_second_time?: boolean
    dropFee?: boolean
    rate_amount?: boolean
    rate_foreigner_amount?: boolean
    tax?: boolean
    total_amount?: boolean
    total_foreigner_amount?: boolean
    agencies?: boolean | agenciesArgs
    vendors?: boolean | vendorsArgs
    users?: boolean | usersArgs
    payment?: boolean | paymentFindManyArgs
    _count?: boolean | ReservationCountOutputTypeArgs
  }

  export type reservationInclude = {
    agencies?: boolean | agenciesArgs
    vendors?: boolean | vendorsArgs
    users?: boolean | usersArgs
    payment?: boolean | paymentFindManyArgs
    _count?: boolean | ReservationCountOutputTypeArgs
  }

  export type reservationGetPayload<
    S extends boolean | null | undefined | reservationArgs,
    U = keyof S
      > = S extends true
        ? reservation
    : S extends undefined
    ? never
    : S extends reservationArgs | reservationFindManyArgs
    ?'include' extends U
    ? reservation  & {
    [P in TrueKeys<S['include']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'users' ? usersGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'payment' ? Array < paymentGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ReservationCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'users' ? usersGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'payment' ? Array < paymentGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ReservationCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof reservation ? reservation[P] : never
  } 
    : reservation
  : reservation


  type reservationCountArgs = Merge<
    Omit<reservationFindManyArgs, 'select' | 'include'> & {
      select?: ReservationCountAggregateInputType | true
    }
  >

  export interface reservationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {reservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reservationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reservationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reservation'> extends True ? CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>> : CheckSelect<T, Prisma__reservationClient<reservation | null, null>, Prisma__reservationClient<reservationGetPayload<T> | null, null>>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reservationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reservationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reservation'> extends True ? CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>> : CheckSelect<T, Prisma__reservationClient<reservation | null, null>, Prisma__reservationClient<reservationGetPayload<T> | null, null>>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `supplier`
     * const reservationWithSupplierOnly = await prisma.reservation.findMany({ select: { supplier: true } })
     * 
    **/
    findMany<T extends reservationFindManyArgs>(
      args?: SelectSubset<T, reservationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<reservation>>, PrismaPromise<Array<reservationGetPayload<T>>>>

    /**
     * Create a Reservation.
     * @param {reservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
    **/
    create<T extends reservationCreateArgs>(
      args: SelectSubset<T, reservationCreateArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Create many Reservations.
     *     @param {reservationCreateManyArgs} args - Arguments to create many Reservations.
     *     @example
     *     // Create many Reservations
     *     const reservation = await prisma.reservation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reservationCreateManyArgs>(
      args?: SelectSubset<T, reservationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reservation.
     * @param {reservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
    **/
    delete<T extends reservationDeleteArgs>(
      args: SelectSubset<T, reservationDeleteArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Update one Reservation.
     * @param {reservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reservationUpdateArgs>(
      args: SelectSubset<T, reservationUpdateArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Delete zero or more Reservations.
     * @param {reservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reservationDeleteManyArgs>(
      args?: SelectSubset<T, reservationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reservationUpdateManyArgs>(
      args: SelectSubset<T, reservationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {reservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
    **/
    upsert<T extends reservationUpsertArgs>(
      args: SelectSubset<T, reservationUpsertArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Find one Reservation that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {reservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reservationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reservationFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Find the first Reservation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reservationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reservationFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends reservationCountArgs>(
      args?: Subset<T, reservationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reservationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    agencies<T extends agenciesArgs = {}>(args?: Subset<T, agenciesArgs>): CheckSelect<T, Prisma__agenciesClient<agencies | Null>, Prisma__agenciesClient<agenciesGetPayload<T> | Null>>;

    vendors<T extends vendorsArgs = {}>(args?: Subset<T, vendorsArgs>): CheckSelect<T, Prisma__vendorsClient<vendors | Null>, Prisma__vendorsClient<vendorsGetPayload<T> | Null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | Null>, Prisma__usersClient<usersGetPayload<T> | Null>>;

    payment<T extends paymentFindManyArgs = {}>(args?: Subset<T, paymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<payment>| Null>, PrismaPromise<Array<paymentGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reservation base type for findUnique actions
   */
  export type reservationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * Filter, which reservation to fetch.
     * 
    **/
    where: reservationWhereUniqueInput
  }

  /**
   * reservation: findUnique
   */
  export interface reservationFindUniqueArgs extends reservationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reservation base type for findFirst actions
   */
  export type reservationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * Filter, which reservation to fetch.
     * 
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     * 
    **/
    orderBy?: Enumerable<reservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
     * 
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
     * 
    **/
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }

  /**
   * reservation: findFirst
   */
  export interface reservationFindFirstArgs extends reservationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reservation findMany
   */
  export type reservationFindManyArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * Filter, which reservations to fetch.
     * 
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
     * 
    **/
    orderBy?: Enumerable<reservationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservations.
     * 
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * reservation create
   */
  export type reservationCreateArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * The data needed to create a reservation.
     * 
    **/
    data: XOR<reservationCreateInput, reservationUncheckedCreateInput>
  }


  /**
   * reservation createMany
   */
  export type reservationCreateManyArgs = {
    /**
     * The data used to create many reservations.
     * 
    **/
    data: Enumerable<reservationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reservation update
   */
  export type reservationUpdateArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * The data needed to update a reservation.
     * 
    **/
    data: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
    /**
     * Choose, which reservation to update.
     * 
    **/
    where: reservationWhereUniqueInput
  }


  /**
   * reservation updateMany
   */
  export type reservationUpdateManyArgs = {
    /**
     * The data used to update reservations.
     * 
    **/
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyInput>
    /**
     * Filter which reservations to update
     * 
    **/
    where?: reservationWhereInput
  }


  /**
   * reservation upsert
   */
  export type reservationUpsertArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * The filter to search for the reservation to update in case it exists.
     * 
    **/
    where: reservationWhereUniqueInput
    /**
     * In case the reservation found by the `where` argument doesn't exist, create a new reservation with this data.
     * 
    **/
    create: XOR<reservationCreateInput, reservationUncheckedCreateInput>
    /**
     * In case the reservation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
  }


  /**
   * reservation delete
   */
  export type reservationDeleteArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
    /**
     * Filter which reservation to delete.
     * 
    **/
    where: reservationWhereUniqueInput
  }


  /**
   * reservation deleteMany
   */
  export type reservationDeleteManyArgs = {
    /**
     * Filter which reservations to delete
     * 
    **/
    where?: reservationWhereInput
  }


  /**
   * reservation: findUniqueOrThrow
   */
  export type reservationFindUniqueOrThrowArgs = reservationFindUniqueArgsBase
      

  /**
   * reservation: findFirstOrThrow
   */
  export type reservationFindFirstOrThrowArgs = reservationFindFirstArgsBase
      

  /**
   * reservation without action
   */
  export type reservationArgs = {
    /**
     * Select specific fields to fetch from the reservation
     * 
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reservationInclude | null
  }



  /**
   * Model services
   */


  export type AggregateServices = {
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  export type ServicesAvgAggregateOutputType = {
    order: number | null
  }

  export type ServicesSumAggregateOutputType = {
    order: number | null
  }

  export type ServicesMinAggregateOutputType = {
    id: string | null
    description: string | null
    ko_description: string | null
    details: string | null
    order: number | null
  }

  export type ServicesMaxAggregateOutputType = {
    id: string | null
    description: string | null
    ko_description: string | null
    details: string | null
    order: number | null
  }

  export type ServicesCountAggregateOutputType = {
    id: number
    description: number
    ko_description: number
    details: number
    order: number
    _all: number
  }


  export type ServicesAvgAggregateInputType = {
    order?: true
  }

  export type ServicesSumAggregateInputType = {
    order?: true
  }

  export type ServicesMinAggregateInputType = {
    id?: true
    description?: true
    ko_description?: true
    details?: true
    order?: true
  }

  export type ServicesMaxAggregateInputType = {
    id?: true
    description?: true
    ko_description?: true
    details?: true
    order?: true
  }

  export type ServicesCountAggregateInputType = {
    id?: true
    description?: true
    ko_description?: true
    details?: true
    order?: true
    _all?: true
  }

  export type ServicesAggregateArgs = {
    /**
     * Filter which services to aggregate.
     * 
    **/
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     * 
    **/
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned services
    **/
    _count?: true | ServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesMaxAggregateInputType
  }

  export type GetServicesAggregateType<T extends ServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServices[P]>
      : GetScalarType<T[P], AggregateServices[P]>
  }




  export type ServicesGroupByArgs = {
    where?: servicesWhereInput
    orderBy?: Enumerable<servicesOrderByWithAggregationInput>
    by: Array<ServicesScalarFieldEnum>
    having?: servicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesCountAggregateInputType | true
    _avg?: ServicesAvgAggregateInputType
    _sum?: ServicesSumAggregateInputType
    _min?: ServicesMinAggregateInputType
    _max?: ServicesMaxAggregateInputType
  }


  export type ServicesGroupByOutputType = {
    id: string
    description: string | null
    ko_description: string | null
    details: string | null
    order: number | null
    _count: ServicesCountAggregateOutputType | null
    _avg: ServicesAvgAggregateOutputType | null
    _sum: ServicesSumAggregateOutputType | null
    _min: ServicesMinAggregateOutputType | null
    _max: ServicesMaxAggregateOutputType | null
  }

  type GetServicesGroupByPayload<T extends ServicesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesGroupByOutputType[P]>
        }
      >
    >


  export type servicesSelect = {
    id?: boolean
    description?: boolean
    ko_description?: boolean
    details?: boolean
    order?: boolean
    packages?: boolean | packagesFindManyArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }

  export type servicesInclude = {
    packages?: boolean | packagesFindManyArgs
    _count?: boolean | ServicesCountOutputTypeArgs
  }

  export type servicesGetPayload<
    S extends boolean | null | undefined | servicesArgs,
    U = keyof S
      > = S extends true
        ? services
    : S extends undefined
    ? never
    : S extends servicesArgs | servicesFindManyArgs
    ?'include' extends U
    ? services  & {
    [P in TrueKeys<S['include']>]:
        P extends 'packages' ? Array < packagesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'packages' ? Array < packagesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? ServicesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof services ? services[P] : never
  } 
    : services
  : services


  type servicesCountArgs = Merge<
    Omit<servicesFindManyArgs, 'select' | 'include'> & {
      select?: ServicesCountAggregateInputType | true
    }
  >

  export interface servicesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Services that matches the filter.
     * @param {servicesFindUniqueArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends servicesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, servicesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'services'> extends True ? CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>> : CheckSelect<T, Prisma__servicesClient<services | null, null>, Prisma__servicesClient<servicesGetPayload<T> | null, null>>

    /**
     * Find the first Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends servicesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, servicesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'services'> extends True ? CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>> : CheckSelect<T, Prisma__servicesClient<services | null, null>, Prisma__servicesClient<servicesGetPayload<T> | null, null>>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.services.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.services.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWithIdOnly = await prisma.services.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends servicesFindManyArgs>(
      args?: SelectSubset<T, servicesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<services>>, PrismaPromise<Array<servicesGetPayload<T>>>>

    /**
     * Create a Services.
     * @param {servicesCreateArgs} args - Arguments to create a Services.
     * @example
     * // Create one Services
     * const Services = await prisma.services.create({
     *   data: {
     *     // ... data to create a Services
     *   }
     * })
     * 
    **/
    create<T extends servicesCreateArgs>(
      args: SelectSubset<T, servicesCreateArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Create many Services.
     *     @param {servicesCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const services = await prisma.services.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends servicesCreateManyArgs>(
      args?: SelectSubset<T, servicesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Services.
     * @param {servicesDeleteArgs} args - Arguments to delete one Services.
     * @example
     * // Delete one Services
     * const Services = await prisma.services.delete({
     *   where: {
     *     // ... filter to delete one Services
     *   }
     * })
     * 
    **/
    delete<T extends servicesDeleteArgs>(
      args: SelectSubset<T, servicesDeleteArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Update one Services.
     * @param {servicesUpdateArgs} args - Arguments to update one Services.
     * @example
     * // Update one Services
     * const services = await prisma.services.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends servicesUpdateArgs>(
      args: SelectSubset<T, servicesUpdateArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Delete zero or more Services.
     * @param {servicesDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.services.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends servicesDeleteManyArgs>(
      args?: SelectSubset<T, servicesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const services = await prisma.services.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends servicesUpdateManyArgs>(
      args: SelectSubset<T, servicesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Services.
     * @param {servicesUpsertArgs} args - Arguments to update or create a Services.
     * @example
     * // Update or create a Services
     * const services = await prisma.services.upsert({
     *   create: {
     *     // ... data to create a Services
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Services we want to update
     *   }
     * })
    **/
    upsert<T extends servicesUpsertArgs>(
      args: SelectSubset<T, servicesUpsertArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Find one Services that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {servicesFindUniqueOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends servicesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, servicesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Find the first Services that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesFindFirstOrThrowArgs} args - Arguments to find a Services
     * @example
     * // Get one Services
     * const services = await prisma.services.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends servicesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, servicesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__servicesClient<services>, Prisma__servicesClient<servicesGetPayload<T>>>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicesCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.services.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends servicesCountArgs>(
      args?: Subset<T, servicesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAggregateArgs>(args: Subset<T, ServicesAggregateArgs>): PrismaPromise<GetServicesAggregateType<T>>

    /**
     * Group by Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesGroupByArgs['orderBy'] }
        : { orderBy?: ServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for services.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__servicesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    packages<T extends packagesFindManyArgs = {}>(args?: Subset<T, packagesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<packages>| Null>, PrismaPromise<Array<packagesGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * services base type for findUnique actions
   */
  export type servicesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     * 
    **/
    where: servicesWhereUniqueInput
  }

  /**
   * services: findUnique
   */
  export interface servicesFindUniqueArgs extends servicesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services base type for findFirst actions
   */
  export type servicesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     * 
    **/
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     * 
    **/
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for services.
     * 
    **/
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of services.
     * 
    **/
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }

  /**
   * services: findFirst
   */
  export interface servicesFindFirstArgs extends servicesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * services findMany
   */
  export type servicesFindManyArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * Filter, which services to fetch.
     * 
    **/
    where?: servicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of services to fetch.
     * 
    **/
    orderBy?: Enumerable<servicesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing services.
     * 
    **/
    cursor?: servicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` services from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` services.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServicesScalarFieldEnum>
  }


  /**
   * services create
   */
  export type servicesCreateArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * The data needed to create a services.
     * 
    **/
    data: XOR<servicesCreateInput, servicesUncheckedCreateInput>
  }


  /**
   * services createMany
   */
  export type servicesCreateManyArgs = {
    /**
     * The data used to create many services.
     * 
    **/
    data: Enumerable<servicesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * services update
   */
  export type servicesUpdateArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * The data needed to update a services.
     * 
    **/
    data: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
    /**
     * Choose, which services to update.
     * 
    **/
    where: servicesWhereUniqueInput
  }


  /**
   * services updateMany
   */
  export type servicesUpdateManyArgs = {
    /**
     * The data used to update services.
     * 
    **/
    data: XOR<servicesUpdateManyMutationInput, servicesUncheckedUpdateManyInput>
    /**
     * Filter which services to update
     * 
    **/
    where?: servicesWhereInput
  }


  /**
   * services upsert
   */
  export type servicesUpsertArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * The filter to search for the services to update in case it exists.
     * 
    **/
    where: servicesWhereUniqueInput
    /**
     * In case the services found by the `where` argument doesn't exist, create a new services with this data.
     * 
    **/
    create: XOR<servicesCreateInput, servicesUncheckedCreateInput>
    /**
     * In case the services was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<servicesUpdateInput, servicesUncheckedUpdateInput>
  }


  /**
   * services delete
   */
  export type servicesDeleteArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
    /**
     * Filter which services to delete.
     * 
    **/
    where: servicesWhereUniqueInput
  }


  /**
   * services deleteMany
   */
  export type servicesDeleteManyArgs = {
    /**
     * Filter which services to delete
     * 
    **/
    where?: servicesWhereInput
  }


  /**
   * services: findUniqueOrThrow
   */
  export type servicesFindUniqueOrThrowArgs = servicesFindUniqueArgsBase
      

  /**
   * services: findFirstOrThrow
   */
  export type servicesFindFirstOrThrowArgs = servicesFindFirstArgsBase
      

  /**
   * services without action
   */
  export type servicesArgs = {
    /**
     * Select specific fields to fetch from the services
     * 
    **/
    select?: servicesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: servicesInclude | null
  }



  /**
   * Model agencies
   */


  export type AggregateAgencies = {
    _count: AgenciesCountAggregateOutputType | null
    _min: AgenciesMinAggregateOutputType | null
    _max: AgenciesMaxAggregateOutputType | null
  }

  export type AgenciesMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    created_date: Date | null
  }

  export type AgenciesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    created_date: Date | null
  }

  export type AgenciesCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    created_date: number
    _all: number
  }


  export type AgenciesMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    created_date?: true
  }

  export type AgenciesMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    created_date?: true
  }

  export type AgenciesCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    created_date?: true
    _all?: true
  }

  export type AgenciesAggregateArgs = {
    /**
     * Filter which agencies to aggregate.
     * 
    **/
    where?: agenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agencies to fetch.
     * 
    **/
    orderBy?: Enumerable<agenciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: agenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agencies
    **/
    _count?: true | AgenciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgenciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgenciesMaxAggregateInputType
  }

  export type GetAgenciesAggregateType<T extends AgenciesAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencies[P]>
      : GetScalarType<T[P], AggregateAgencies[P]>
  }




  export type AgenciesGroupByArgs = {
    where?: agenciesWhereInput
    orderBy?: Enumerable<agenciesOrderByWithAggregationInput>
    by: Array<AgenciesScalarFieldEnum>
    having?: agenciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgenciesCountAggregateInputType | true
    _min?: AgenciesMinAggregateInputType
    _max?: AgenciesMaxAggregateInputType
  }


  export type AgenciesGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    created_date: Date | null
    _count: AgenciesCountAggregateOutputType | null
    _min: AgenciesMinAggregateOutputType | null
    _max: AgenciesMaxAggregateOutputType | null
  }

  type GetAgenciesGroupByPayload<T extends AgenciesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgenciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgenciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgenciesGroupByOutputType[P]>
            : GetScalarType<T[P], AgenciesGroupByOutputType[P]>
        }
      >
    >


  export type agenciesSelect = {
    id?: boolean
    name?: boolean
    logo?: boolean
    created_date?: boolean
    admin_users?: boolean | admin_usersFindManyArgs
    commission_setting?: boolean | commission_settingFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | AgenciesCountOutputTypeArgs
  }

  export type agenciesInclude = {
    admin_users?: boolean | admin_usersFindManyArgs
    commission_setting?: boolean | commission_settingFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    _count?: boolean | AgenciesCountOutputTypeArgs
  }

  export type agenciesGetPayload<
    S extends boolean | null | undefined | agenciesArgs,
    U = keyof S
      > = S extends true
        ? agencies
    : S extends undefined
    ? never
    : S extends agenciesArgs | agenciesFindManyArgs
    ?'include' extends U
    ? agencies  & {
    [P in TrueKeys<S['include']>]:
        P extends 'admin_users' ? Array < admin_usersGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'commission_setting' ? Array < commission_settingGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? AgenciesCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'admin_users' ? Array < admin_usersGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'commission_setting' ? Array < commission_settingGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'reservation' ? Array < reservationGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? AgenciesCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof agencies ? agencies[P] : never
  } 
    : agencies
  : agencies


  type agenciesCountArgs = Merge<
    Omit<agenciesFindManyArgs, 'select' | 'include'> & {
      select?: AgenciesCountAggregateInputType | true
    }
  >

  export interface agenciesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Agencies that matches the filter.
     * @param {agenciesFindUniqueArgs} args - Arguments to find a Agencies
     * @example
     * // Get one Agencies
     * const agencies = await prisma.agencies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends agenciesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, agenciesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'agencies'> extends True ? CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>> : CheckSelect<T, Prisma__agenciesClient<agencies | null, null>, Prisma__agenciesClient<agenciesGetPayload<T> | null, null>>

    /**
     * Find the first Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenciesFindFirstArgs} args - Arguments to find a Agencies
     * @example
     * // Get one Agencies
     * const agencies = await prisma.agencies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends agenciesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, agenciesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'agencies'> extends True ? CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>> : CheckSelect<T, Prisma__agenciesClient<agencies | null, null>, Prisma__agenciesClient<agenciesGetPayload<T> | null, null>>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenciesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agencies.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agencies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agenciesWithIdOnly = await prisma.agencies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends agenciesFindManyArgs>(
      args?: SelectSubset<T, agenciesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<agencies>>, PrismaPromise<Array<agenciesGetPayload<T>>>>

    /**
     * Create a Agencies.
     * @param {agenciesCreateArgs} args - Arguments to create a Agencies.
     * @example
     * // Create one Agencies
     * const Agencies = await prisma.agencies.create({
     *   data: {
     *     // ... data to create a Agencies
     *   }
     * })
     * 
    **/
    create<T extends agenciesCreateArgs>(
      args: SelectSubset<T, agenciesCreateArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Create many Agencies.
     *     @param {agenciesCreateManyArgs} args - Arguments to create many Agencies.
     *     @example
     *     // Create many Agencies
     *     const agencies = await prisma.agencies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends agenciesCreateManyArgs>(
      args?: SelectSubset<T, agenciesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Agencies.
     * @param {agenciesDeleteArgs} args - Arguments to delete one Agencies.
     * @example
     * // Delete one Agencies
     * const Agencies = await prisma.agencies.delete({
     *   where: {
     *     // ... filter to delete one Agencies
     *   }
     * })
     * 
    **/
    delete<T extends agenciesDeleteArgs>(
      args: SelectSubset<T, agenciesDeleteArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Update one Agencies.
     * @param {agenciesUpdateArgs} args - Arguments to update one Agencies.
     * @example
     * // Update one Agencies
     * const agencies = await prisma.agencies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends agenciesUpdateArgs>(
      args: SelectSubset<T, agenciesUpdateArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Delete zero or more Agencies.
     * @param {agenciesDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agencies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends agenciesDeleteManyArgs>(
      args?: SelectSubset<T, agenciesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agencies = await prisma.agencies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends agenciesUpdateManyArgs>(
      args: SelectSubset<T, agenciesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Agencies.
     * @param {agenciesUpsertArgs} args - Arguments to update or create a Agencies.
     * @example
     * // Update or create a Agencies
     * const agencies = await prisma.agencies.upsert({
     *   create: {
     *     // ... data to create a Agencies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agencies we want to update
     *   }
     * })
    **/
    upsert<T extends agenciesUpsertArgs>(
      args: SelectSubset<T, agenciesUpsertArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Find one Agencies that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {agenciesFindUniqueOrThrowArgs} args - Arguments to find a Agencies
     * @example
     * // Get one Agencies
     * const agencies = await prisma.agencies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends agenciesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, agenciesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Find the first Agencies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenciesFindFirstOrThrowArgs} args - Arguments to find a Agencies
     * @example
     * // Get one Agencies
     * const agencies = await prisma.agencies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends agenciesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, agenciesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__agenciesClient<agencies>, Prisma__agenciesClient<agenciesGetPayload<T>>>

    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agenciesCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agencies.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends agenciesCountArgs>(
      args?: Subset<T, agenciesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgenciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgenciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgenciesAggregateArgs>(args: Subset<T, AgenciesAggregateArgs>): PrismaPromise<GetAgenciesAggregateType<T>>

    /**
     * Group by Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgenciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgenciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgenciesGroupByArgs['orderBy'] }
        : { orderBy?: AgenciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgenciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgenciesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for agencies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__agenciesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    admin_users<T extends admin_usersFindManyArgs = {}>(args?: Subset<T, admin_usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<admin_users>| Null>, PrismaPromise<Array<admin_usersGetPayload<T>>| Null>>;

    commission_setting<T extends commission_settingFindManyArgs = {}>(args?: Subset<T, commission_settingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<commission_setting>| Null>, PrismaPromise<Array<commission_settingGetPayload<T>>| Null>>;

    reservation<T extends reservationFindManyArgs = {}>(args?: Subset<T, reservationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reservation>| Null>, PrismaPromise<Array<reservationGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * agencies base type for findUnique actions
   */
  export type agenciesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * Filter, which agencies to fetch.
     * 
    **/
    where: agenciesWhereUniqueInput
  }

  /**
   * agencies: findUnique
   */
  export interface agenciesFindUniqueArgs extends agenciesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agencies base type for findFirst actions
   */
  export type agenciesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * Filter, which agencies to fetch.
     * 
    **/
    where?: agenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agencies to fetch.
     * 
    **/
    orderBy?: Enumerable<agenciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agencies.
     * 
    **/
    cursor?: agenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agencies.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agencies.
     * 
    **/
    distinct?: Enumerable<AgenciesScalarFieldEnum>
  }

  /**
   * agencies: findFirst
   */
  export interface agenciesFindFirstArgs extends agenciesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * agencies findMany
   */
  export type agenciesFindManyArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * Filter, which agencies to fetch.
     * 
    **/
    where?: agenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agencies to fetch.
     * 
    **/
    orderBy?: Enumerable<agenciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agencies.
     * 
    **/
    cursor?: agenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agencies from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agencies.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgenciesScalarFieldEnum>
  }


  /**
   * agencies create
   */
  export type agenciesCreateArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * The data needed to create a agencies.
     * 
    **/
    data: XOR<agenciesCreateInput, agenciesUncheckedCreateInput>
  }


  /**
   * agencies createMany
   */
  export type agenciesCreateManyArgs = {
    /**
     * The data used to create many agencies.
     * 
    **/
    data: Enumerable<agenciesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * agencies update
   */
  export type agenciesUpdateArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * The data needed to update a agencies.
     * 
    **/
    data: XOR<agenciesUpdateInput, agenciesUncheckedUpdateInput>
    /**
     * Choose, which agencies to update.
     * 
    **/
    where: agenciesWhereUniqueInput
  }


  /**
   * agencies updateMany
   */
  export type agenciesUpdateManyArgs = {
    /**
     * The data used to update agencies.
     * 
    **/
    data: XOR<agenciesUpdateManyMutationInput, agenciesUncheckedUpdateManyInput>
    /**
     * Filter which agencies to update
     * 
    **/
    where?: agenciesWhereInput
  }


  /**
   * agencies upsert
   */
  export type agenciesUpsertArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * The filter to search for the agencies to update in case it exists.
     * 
    **/
    where: agenciesWhereUniqueInput
    /**
     * In case the agencies found by the `where` argument doesn't exist, create a new agencies with this data.
     * 
    **/
    create: XOR<agenciesCreateInput, agenciesUncheckedCreateInput>
    /**
     * In case the agencies was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<agenciesUpdateInput, agenciesUncheckedUpdateInput>
  }


  /**
   * agencies delete
   */
  export type agenciesDeleteArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
    /**
     * Filter which agencies to delete.
     * 
    **/
    where: agenciesWhereUniqueInput
  }


  /**
   * agencies deleteMany
   */
  export type agenciesDeleteManyArgs = {
    /**
     * Filter which agencies to delete
     * 
    **/
    where?: agenciesWhereInput
  }


  /**
   * agencies: findUniqueOrThrow
   */
  export type agenciesFindUniqueOrThrowArgs = agenciesFindUniqueArgsBase
      

  /**
   * agencies: findFirstOrThrow
   */
  export type agenciesFindFirstOrThrowArgs = agenciesFindFirstArgsBase
      

  /**
   * agencies without action
   */
  export type agenciesArgs = {
    /**
     * Select specific fields to fetch from the agencies
     * 
    **/
    select?: agenciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: agenciesInclude | null
  }



  /**
   * Model commission_setting
   */


  export type AggregateCommission_setting = {
    _count: Commission_settingCountAggregateOutputType | null
    _avg: Commission_settingAvgAggregateOutputType | null
    _sum: Commission_settingSumAggregateOutputType | null
    _min: Commission_settingMinAggregateOutputType | null
    _max: Commission_settingMaxAggregateOutputType | null
  }

  export type Commission_settingAvgAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type Commission_settingSumAggregateOutputType = {
    id: number | null
    amount: Decimal | null
  }

  export type Commission_settingMinAggregateOutputType = {
    id: number | null
    vendor: string | null
    agency: string | null
    payment_type: string | null
    tag: string | null
    calculation_type: string | null
    amount: Decimal | null
  }

  export type Commission_settingMaxAggregateOutputType = {
    id: number | null
    vendor: string | null
    agency: string | null
    payment_type: string | null
    tag: string | null
    calculation_type: string | null
    amount: Decimal | null
  }

  export type Commission_settingCountAggregateOutputType = {
    id: number
    vendor: number
    agency: number
    payment_type: number
    tag: number
    calculation_type: number
    amount: number
    _all: number
  }


  export type Commission_settingAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type Commission_settingSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type Commission_settingMinAggregateInputType = {
    id?: true
    vendor?: true
    agency?: true
    payment_type?: true
    tag?: true
    calculation_type?: true
    amount?: true
  }

  export type Commission_settingMaxAggregateInputType = {
    id?: true
    vendor?: true
    agency?: true
    payment_type?: true
    tag?: true
    calculation_type?: true
    amount?: true
  }

  export type Commission_settingCountAggregateInputType = {
    id?: true
    vendor?: true
    agency?: true
    payment_type?: true
    tag?: true
    calculation_type?: true
    amount?: true
    _all?: true
  }

  export type Commission_settingAggregateArgs = {
    /**
     * Filter which commission_setting to aggregate.
     * 
    **/
    where?: commission_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commission_settings to fetch.
     * 
    **/
    orderBy?: Enumerable<commission_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: commission_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commission_settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commission_settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commission_settings
    **/
    _count?: true | Commission_settingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Commission_settingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Commission_settingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Commission_settingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Commission_settingMaxAggregateInputType
  }

  export type GetCommission_settingAggregateType<T extends Commission_settingAggregateArgs> = {
        [P in keyof T & keyof AggregateCommission_setting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommission_setting[P]>
      : GetScalarType<T[P], AggregateCommission_setting[P]>
  }




  export type Commission_settingGroupByArgs = {
    where?: commission_settingWhereInput
    orderBy?: Enumerable<commission_settingOrderByWithAggregationInput>
    by: Array<Commission_settingScalarFieldEnum>
    having?: commission_settingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Commission_settingCountAggregateInputType | true
    _avg?: Commission_settingAvgAggregateInputType
    _sum?: Commission_settingSumAggregateInputType
    _min?: Commission_settingMinAggregateInputType
    _max?: Commission_settingMaxAggregateInputType
  }


  export type Commission_settingGroupByOutputType = {
    id: number
    vendor: string
    agency: string
    payment_type: string
    tag: string
    calculation_type: string
    amount: Decimal
    _count: Commission_settingCountAggregateOutputType | null
    _avg: Commission_settingAvgAggregateOutputType | null
    _sum: Commission_settingSumAggregateOutputType | null
    _min: Commission_settingMinAggregateOutputType | null
    _max: Commission_settingMaxAggregateOutputType | null
  }

  type GetCommission_settingGroupByPayload<T extends Commission_settingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Commission_settingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Commission_settingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Commission_settingGroupByOutputType[P]>
            : GetScalarType<T[P], Commission_settingGroupByOutputType[P]>
        }
      >
    >


  export type commission_settingSelect = {
    id?: boolean
    vendor?: boolean
    agency?: boolean
    payment_type?: boolean
    tag?: boolean
    calculation_type?: boolean
    amount?: boolean
    agencies?: boolean | agenciesArgs
    vendors?: boolean | vendorsArgs
  }

  export type commission_settingInclude = {
    agencies?: boolean | agenciesArgs
    vendors?: boolean | vendorsArgs
  }

  export type commission_settingGetPayload<
    S extends boolean | null | undefined | commission_settingArgs,
    U = keyof S
      > = S extends true
        ? commission_setting
    : S extends undefined
    ? never
    : S extends commission_settingArgs | commission_settingFindManyArgs
    ?'include' extends U
    ? commission_setting  & {
    [P in TrueKeys<S['include']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'agencies' ? agenciesGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'vendors' ? vendorsGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof commission_setting ? commission_setting[P] : never
  } 
    : commission_setting
  : commission_setting


  type commission_settingCountArgs = Merge<
    Omit<commission_settingFindManyArgs, 'select' | 'include'> & {
      select?: Commission_settingCountAggregateInputType | true
    }
  >

  export interface commission_settingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Commission_setting that matches the filter.
     * @param {commission_settingFindUniqueArgs} args - Arguments to find a Commission_setting
     * @example
     * // Get one Commission_setting
     * const commission_setting = await prisma.commission_setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commission_settingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, commission_settingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'commission_setting'> extends True ? CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>> : CheckSelect<T, Prisma__commission_settingClient<commission_setting | null, null>, Prisma__commission_settingClient<commission_settingGetPayload<T> | null, null>>

    /**
     * Find the first Commission_setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commission_settingFindFirstArgs} args - Arguments to find a Commission_setting
     * @example
     * // Get one Commission_setting
     * const commission_setting = await prisma.commission_setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commission_settingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, commission_settingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'commission_setting'> extends True ? CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>> : CheckSelect<T, Prisma__commission_settingClient<commission_setting | null, null>, Prisma__commission_settingClient<commission_settingGetPayload<T> | null, null>>

    /**
     * Find zero or more Commission_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commission_settingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commission_settings
     * const commission_settings = await prisma.commission_setting.findMany()
     * 
     * // Get first 10 Commission_settings
     * const commission_settings = await prisma.commission_setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commission_settingWithIdOnly = await prisma.commission_setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends commission_settingFindManyArgs>(
      args?: SelectSubset<T, commission_settingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<commission_setting>>, PrismaPromise<Array<commission_settingGetPayload<T>>>>

    /**
     * Create a Commission_setting.
     * @param {commission_settingCreateArgs} args - Arguments to create a Commission_setting.
     * @example
     * // Create one Commission_setting
     * const Commission_setting = await prisma.commission_setting.create({
     *   data: {
     *     // ... data to create a Commission_setting
     *   }
     * })
     * 
    **/
    create<T extends commission_settingCreateArgs>(
      args: SelectSubset<T, commission_settingCreateArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Create many Commission_settings.
     *     @param {commission_settingCreateManyArgs} args - Arguments to create many Commission_settings.
     *     @example
     *     // Create many Commission_settings
     *     const commission_setting = await prisma.commission_setting.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commission_settingCreateManyArgs>(
      args?: SelectSubset<T, commission_settingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Commission_setting.
     * @param {commission_settingDeleteArgs} args - Arguments to delete one Commission_setting.
     * @example
     * // Delete one Commission_setting
     * const Commission_setting = await prisma.commission_setting.delete({
     *   where: {
     *     // ... filter to delete one Commission_setting
     *   }
     * })
     * 
    **/
    delete<T extends commission_settingDeleteArgs>(
      args: SelectSubset<T, commission_settingDeleteArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Update one Commission_setting.
     * @param {commission_settingUpdateArgs} args - Arguments to update one Commission_setting.
     * @example
     * // Update one Commission_setting
     * const commission_setting = await prisma.commission_setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commission_settingUpdateArgs>(
      args: SelectSubset<T, commission_settingUpdateArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Delete zero or more Commission_settings.
     * @param {commission_settingDeleteManyArgs} args - Arguments to filter Commission_settings to delete.
     * @example
     * // Delete a few Commission_settings
     * const { count } = await prisma.commission_setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commission_settingDeleteManyArgs>(
      args?: SelectSubset<T, commission_settingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commission_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commission_settingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commission_settings
     * const commission_setting = await prisma.commission_setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commission_settingUpdateManyArgs>(
      args: SelectSubset<T, commission_settingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Commission_setting.
     * @param {commission_settingUpsertArgs} args - Arguments to update or create a Commission_setting.
     * @example
     * // Update or create a Commission_setting
     * const commission_setting = await prisma.commission_setting.upsert({
     *   create: {
     *     // ... data to create a Commission_setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commission_setting we want to update
     *   }
     * })
    **/
    upsert<T extends commission_settingUpsertArgs>(
      args: SelectSubset<T, commission_settingUpsertArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Find one Commission_setting that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {commission_settingFindUniqueOrThrowArgs} args - Arguments to find a Commission_setting
     * @example
     * // Get one Commission_setting
     * const commission_setting = await prisma.commission_setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commission_settingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, commission_settingFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Find the first Commission_setting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commission_settingFindFirstOrThrowArgs} args - Arguments to find a Commission_setting
     * @example
     * // Get one Commission_setting
     * const commission_setting = await prisma.commission_setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commission_settingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, commission_settingFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__commission_settingClient<commission_setting>, Prisma__commission_settingClient<commission_settingGetPayload<T>>>

    /**
     * Count the number of Commission_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commission_settingCountArgs} args - Arguments to filter Commission_settings to count.
     * @example
     * // Count the number of Commission_settings
     * const count = await prisma.commission_setting.count({
     *   where: {
     *     // ... the filter for the Commission_settings we want to count
     *   }
     * })
    **/
    count<T extends commission_settingCountArgs>(
      args?: Subset<T, commission_settingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Commission_settingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commission_setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Commission_settingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Commission_settingAggregateArgs>(args: Subset<T, Commission_settingAggregateArgs>): PrismaPromise<GetCommission_settingAggregateType<T>>

    /**
     * Group by Commission_setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Commission_settingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Commission_settingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Commission_settingGroupByArgs['orderBy'] }
        : { orderBy?: Commission_settingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Commission_settingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommission_settingGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for commission_setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__commission_settingClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    agencies<T extends agenciesArgs = {}>(args?: Subset<T, agenciesArgs>): CheckSelect<T, Prisma__agenciesClient<agencies | Null>, Prisma__agenciesClient<agenciesGetPayload<T> | Null>>;

    vendors<T extends vendorsArgs = {}>(args?: Subset<T, vendorsArgs>): CheckSelect<T, Prisma__vendorsClient<vendors | Null>, Prisma__vendorsClient<vendorsGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * commission_setting base type for findUnique actions
   */
  export type commission_settingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * Filter, which commission_setting to fetch.
     * 
    **/
    where: commission_settingWhereUniqueInput
  }

  /**
   * commission_setting: findUnique
   */
  export interface commission_settingFindUniqueArgs extends commission_settingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commission_setting base type for findFirst actions
   */
  export type commission_settingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * Filter, which commission_setting to fetch.
     * 
    **/
    where?: commission_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commission_settings to fetch.
     * 
    **/
    orderBy?: Enumerable<commission_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commission_settings.
     * 
    **/
    cursor?: commission_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commission_settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commission_settings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commission_settings.
     * 
    **/
    distinct?: Enumerable<Commission_settingScalarFieldEnum>
  }

  /**
   * commission_setting: findFirst
   */
  export interface commission_settingFindFirstArgs extends commission_settingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * commission_setting findMany
   */
  export type commission_settingFindManyArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * Filter, which commission_settings to fetch.
     * 
    **/
    where?: commission_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commission_settings to fetch.
     * 
    **/
    orderBy?: Enumerable<commission_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commission_settings.
     * 
    **/
    cursor?: commission_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commission_settings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commission_settings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Commission_settingScalarFieldEnum>
  }


  /**
   * commission_setting create
   */
  export type commission_settingCreateArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * The data needed to create a commission_setting.
     * 
    **/
    data: XOR<commission_settingCreateInput, commission_settingUncheckedCreateInput>
  }


  /**
   * commission_setting createMany
   */
  export type commission_settingCreateManyArgs = {
    /**
     * The data used to create many commission_settings.
     * 
    **/
    data: Enumerable<commission_settingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * commission_setting update
   */
  export type commission_settingUpdateArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * The data needed to update a commission_setting.
     * 
    **/
    data: XOR<commission_settingUpdateInput, commission_settingUncheckedUpdateInput>
    /**
     * Choose, which commission_setting to update.
     * 
    **/
    where: commission_settingWhereUniqueInput
  }


  /**
   * commission_setting updateMany
   */
  export type commission_settingUpdateManyArgs = {
    /**
     * The data used to update commission_settings.
     * 
    **/
    data: XOR<commission_settingUpdateManyMutationInput, commission_settingUncheckedUpdateManyInput>
    /**
     * Filter which commission_settings to update
     * 
    **/
    where?: commission_settingWhereInput
  }


  /**
   * commission_setting upsert
   */
  export type commission_settingUpsertArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * The filter to search for the commission_setting to update in case it exists.
     * 
    **/
    where: commission_settingWhereUniqueInput
    /**
     * In case the commission_setting found by the `where` argument doesn't exist, create a new commission_setting with this data.
     * 
    **/
    create: XOR<commission_settingCreateInput, commission_settingUncheckedCreateInput>
    /**
     * In case the commission_setting was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<commission_settingUpdateInput, commission_settingUncheckedUpdateInput>
  }


  /**
   * commission_setting delete
   */
  export type commission_settingDeleteArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
    /**
     * Filter which commission_setting to delete.
     * 
    **/
    where: commission_settingWhereUniqueInput
  }


  /**
   * commission_setting deleteMany
   */
  export type commission_settingDeleteManyArgs = {
    /**
     * Filter which commission_settings to delete
     * 
    **/
    where?: commission_settingWhereInput
  }


  /**
   * commission_setting: findUniqueOrThrow
   */
  export type commission_settingFindUniqueOrThrowArgs = commission_settingFindUniqueArgsBase
      

  /**
   * commission_setting: findFirstOrThrow
   */
  export type commission_settingFindFirstOrThrowArgs = commission_settingFindFirstArgsBase
      

  /**
   * commission_setting without action
   */
  export type commission_settingArgs = {
    /**
     * Select specific fields to fetch from the commission_setting
     * 
    **/
    select?: commission_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: commission_settingInclude | null
  }



  /**
   * Model coupons
   */


  export type AggregateCoupons = {
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  export type CouponsAvgAggregateOutputType = {
    id: number | null
    min_days: number | null
    issued_count: number | null
    used_count: number | null
  }

  export type CouponsSumAggregateOutputType = {
    id: number | null
    min_days: number | null
    issued_count: number | null
    used_count: number | null
  }

  export type CouponsMinAggregateOutputType = {
    id: number | null
    type: string | null
    coupon_name: string | null
    brand: string | null
    destination: string | null
    offer_description: string | null
    corporate_discount_number: string | null
    promotion_code: string | null
    min_days: number | null
    car_group: string | null
    pickup_start_time: Date | null
    pickup_end_time: Date | null
    order_start_time: Date | null
    order_end_time: Date | null
    issued_count: number | null
    used_count: number | null
    status: string | null
    remark: string | null
  }

  export type CouponsMaxAggregateOutputType = {
    id: number | null
    type: string | null
    coupon_name: string | null
    brand: string | null
    destination: string | null
    offer_description: string | null
    corporate_discount_number: string | null
    promotion_code: string | null
    min_days: number | null
    car_group: string | null
    pickup_start_time: Date | null
    pickup_end_time: Date | null
    order_start_time: Date | null
    order_end_time: Date | null
    issued_count: number | null
    used_count: number | null
    status: string | null
    remark: string | null
  }

  export type CouponsCountAggregateOutputType = {
    id: number
    type: number
    coupon_name: number
    brand: number
    destination: number
    offer_description: number
    corporate_discount_number: number
    promotion_code: number
    min_days: number
    car_group: number
    pickup_start_time: number
    pickup_end_time: number
    order_start_time: number
    order_end_time: number
    issued_count: number
    used_count: number
    status: number
    remark: number
    _all: number
  }


  export type CouponsAvgAggregateInputType = {
    id?: true
    min_days?: true
    issued_count?: true
    used_count?: true
  }

  export type CouponsSumAggregateInputType = {
    id?: true
    min_days?: true
    issued_count?: true
    used_count?: true
  }

  export type CouponsMinAggregateInputType = {
    id?: true
    type?: true
    coupon_name?: true
    brand?: true
    destination?: true
    offer_description?: true
    corporate_discount_number?: true
    promotion_code?: true
    min_days?: true
    car_group?: true
    pickup_start_time?: true
    pickup_end_time?: true
    order_start_time?: true
    order_end_time?: true
    issued_count?: true
    used_count?: true
    status?: true
    remark?: true
  }

  export type CouponsMaxAggregateInputType = {
    id?: true
    type?: true
    coupon_name?: true
    brand?: true
    destination?: true
    offer_description?: true
    corporate_discount_number?: true
    promotion_code?: true
    min_days?: true
    car_group?: true
    pickup_start_time?: true
    pickup_end_time?: true
    order_start_time?: true
    order_end_time?: true
    issued_count?: true
    used_count?: true
    status?: true
    remark?: true
  }

  export type CouponsCountAggregateInputType = {
    id?: true
    type?: true
    coupon_name?: true
    brand?: true
    destination?: true
    offer_description?: true
    corporate_discount_number?: true
    promotion_code?: true
    min_days?: true
    car_group?: true
    pickup_start_time?: true
    pickup_end_time?: true
    order_start_time?: true
    order_end_time?: true
    issued_count?: true
    used_count?: true
    status?: true
    remark?: true
    _all?: true
  }

  export type CouponsAggregateArgs = {
    /**
     * Filter which coupons to aggregate.
     * 
    **/
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsMaxAggregateInputType
  }

  export type GetCouponsAggregateType<T extends CouponsAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupons[P]>
      : GetScalarType<T[P], AggregateCoupons[P]>
  }




  export type CouponsGroupByArgs = {
    where?: couponsWhereInput
    orderBy?: Enumerable<couponsOrderByWithAggregationInput>
    by: Array<CouponsScalarFieldEnum>
    having?: couponsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsCountAggregateInputType | true
    _avg?: CouponsAvgAggregateInputType
    _sum?: CouponsSumAggregateInputType
    _min?: CouponsMinAggregateInputType
    _max?: CouponsMaxAggregateInputType
  }


  export type CouponsGroupByOutputType = {
    id: number
    type: string
    coupon_name: string
    brand: string
    destination: string
    offer_description: string | null
    corporate_discount_number: string
    promotion_code: string
    min_days: number
    car_group: string
    pickup_start_time: Date
    pickup_end_time: Date
    order_start_time: Date
    order_end_time: Date
    issued_count: number
    used_count: number | null
    status: string
    remark: string
    _count: CouponsCountAggregateOutputType | null
    _avg: CouponsAvgAggregateOutputType | null
    _sum: CouponsSumAggregateOutputType | null
    _min: CouponsMinAggregateOutputType | null
    _max: CouponsMaxAggregateOutputType | null
  }

  type GetCouponsGroupByPayload<T extends CouponsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CouponsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsGroupByOutputType[P]>
        }
      >
    >


  export type couponsSelect = {
    id?: boolean
    type?: boolean
    coupon_name?: boolean
    brand?: boolean
    destination?: boolean
    offer_description?: boolean
    corporate_discount_number?: boolean
    promotion_code?: boolean
    min_days?: boolean
    car_group?: boolean
    pickup_start_time?: boolean
    pickup_end_time?: boolean
    order_start_time?: boolean
    order_end_time?: boolean
    issued_count?: boolean
    used_count?: boolean
    status?: boolean
    remark?: boolean
  }

  export type couponsGetPayload<
    S extends boolean | null | undefined | couponsArgs,
    U = keyof S
      > = S extends true
        ? coupons
    : S extends undefined
    ? never
    : S extends couponsArgs | couponsFindManyArgs
    ?'include' extends U
    ? coupons 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof coupons ? coupons[P] : never
  } 
    : coupons
  : coupons


  type couponsCountArgs = Merge<
    Omit<couponsFindManyArgs, 'select' | 'include'> & {
      select?: CouponsCountAggregateInputType | true
    }
  >

  export interface couponsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Coupons that matches the filter.
     * @param {couponsFindUniqueArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends couponsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, couponsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'coupons'> extends True ? CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>> : CheckSelect<T, Prisma__couponsClient<coupons | null, null>, Prisma__couponsClient<couponsGetPayload<T> | null, null>>

    /**
     * Find the first Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends couponsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, couponsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'coupons'> extends True ? CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>> : CheckSelect<T, Prisma__couponsClient<coupons | null, null>, Prisma__couponsClient<couponsGetPayload<T> | null, null>>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupons.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsWithIdOnly = await prisma.coupons.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends couponsFindManyArgs>(
      args?: SelectSubset<T, couponsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<coupons>>, PrismaPromise<Array<couponsGetPayload<T>>>>

    /**
     * Create a Coupons.
     * @param {couponsCreateArgs} args - Arguments to create a Coupons.
     * @example
     * // Create one Coupons
     * const Coupons = await prisma.coupons.create({
     *   data: {
     *     // ... data to create a Coupons
     *   }
     * })
     * 
    **/
    create<T extends couponsCreateArgs>(
      args: SelectSubset<T, couponsCreateArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Create many Coupons.
     *     @param {couponsCreateManyArgs} args - Arguments to create many Coupons.
     *     @example
     *     // Create many Coupons
     *     const coupons = await prisma.coupons.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends couponsCreateManyArgs>(
      args?: SelectSubset<T, couponsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Coupons.
     * @param {couponsDeleteArgs} args - Arguments to delete one Coupons.
     * @example
     * // Delete one Coupons
     * const Coupons = await prisma.coupons.delete({
     *   where: {
     *     // ... filter to delete one Coupons
     *   }
     * })
     * 
    **/
    delete<T extends couponsDeleteArgs>(
      args: SelectSubset<T, couponsDeleteArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Update one Coupons.
     * @param {couponsUpdateArgs} args - Arguments to update one Coupons.
     * @example
     * // Update one Coupons
     * const coupons = await prisma.coupons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends couponsUpdateArgs>(
      args: SelectSubset<T, couponsUpdateArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Delete zero or more Coupons.
     * @param {couponsDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends couponsDeleteManyArgs>(
      args?: SelectSubset<T, couponsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupons = await prisma.coupons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends couponsUpdateManyArgs>(
      args: SelectSubset<T, couponsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupons.
     * @param {couponsUpsertArgs} args - Arguments to update or create a Coupons.
     * @example
     * // Update or create a Coupons
     * const coupons = await prisma.coupons.upsert({
     *   create: {
     *     // ... data to create a Coupons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupons we want to update
     *   }
     * })
    **/
    upsert<T extends couponsUpsertArgs>(
      args: SelectSubset<T, couponsUpsertArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Find one Coupons that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {couponsFindUniqueOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends couponsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, couponsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Find the first Coupons that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsFindFirstOrThrowArgs} args - Arguments to find a Coupons
     * @example
     * // Get one Coupons
     * const coupons = await prisma.coupons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends couponsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, couponsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__couponsClient<coupons>, Prisma__couponsClient<couponsGetPayload<T>>>

    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupons.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponsCountArgs>(
      args?: Subset<T, couponsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsAggregateArgs>(args: Subset<T, CouponsAggregateArgs>): PrismaPromise<GetCouponsAggregateType<T>>

    /**
     * Group by Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponsGroupByArgs['orderBy'] }
        : { orderBy?: CouponsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for coupons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__couponsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * coupons base type for findUnique actions
   */
  export type couponsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     * 
    **/
    where: couponsWhereUniqueInput
  }

  /**
   * coupons: findUnique
   */
  export interface couponsFindUniqueArgs extends couponsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * coupons base type for findFirst actions
   */
  export type couponsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     * 
    **/
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     * 
    **/
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     * 
    **/
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }

  /**
   * coupons: findFirst
   */
  export interface couponsFindFirstArgs extends couponsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * coupons findMany
   */
  export type couponsFindManyArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * Filter, which coupons to fetch.
     * 
    **/
    where?: couponsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     * 
    **/
    orderBy?: Enumerable<couponsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     * 
    **/
    cursor?: couponsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CouponsScalarFieldEnum>
  }


  /**
   * coupons create
   */
  export type couponsCreateArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * The data needed to create a coupons.
     * 
    **/
    data: XOR<couponsCreateInput, couponsUncheckedCreateInput>
  }


  /**
   * coupons createMany
   */
  export type couponsCreateManyArgs = {
    /**
     * The data used to create many coupons.
     * 
    **/
    data: Enumerable<couponsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * coupons update
   */
  export type couponsUpdateArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * The data needed to update a coupons.
     * 
    **/
    data: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
    /**
     * Choose, which coupons to update.
     * 
    **/
    where: couponsWhereUniqueInput
  }


  /**
   * coupons updateMany
   */
  export type couponsUpdateManyArgs = {
    /**
     * The data used to update coupons.
     * 
    **/
    data: XOR<couponsUpdateManyMutationInput, couponsUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     * 
    **/
    where?: couponsWhereInput
  }


  /**
   * coupons upsert
   */
  export type couponsUpsertArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * The filter to search for the coupons to update in case it exists.
     * 
    **/
    where: couponsWhereUniqueInput
    /**
     * In case the coupons found by the `where` argument doesn't exist, create a new coupons with this data.
     * 
    **/
    create: XOR<couponsCreateInput, couponsUncheckedCreateInput>
    /**
     * In case the coupons was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<couponsUpdateInput, couponsUncheckedUpdateInput>
  }


  /**
   * coupons delete
   */
  export type couponsDeleteArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
    /**
     * Filter which coupons to delete.
     * 
    **/
    where: couponsWhereUniqueInput
  }


  /**
   * coupons deleteMany
   */
  export type couponsDeleteManyArgs = {
    /**
     * Filter which coupons to delete
     * 
    **/
    where?: couponsWhereInput
  }


  /**
   * coupons: findUniqueOrThrow
   */
  export type couponsFindUniqueOrThrowArgs = couponsFindUniqueArgsBase
      

  /**
   * coupons: findFirstOrThrow
   */
  export type couponsFindFirstOrThrowArgs = couponsFindFirstArgsBase
      

  /**
   * coupons without action
   */
  export type couponsArgs = {
    /**
     * Select specific fields to fetch from the coupons
     * 
    **/
    select?: couponsSelect | null
  }



  /**
   * Model promotion_code
   */


  export type AggregatePromotion_code = {
    _count: Promotion_codeCountAggregateOutputType | null
    _min: Promotion_codeMinAggregateOutputType | null
    _max: Promotion_codeMaxAggregateOutputType | null
  }

  export type Promotion_codeMinAggregateOutputType = {
    cdp: string | null
    pc: string | null
    vendor_id: string | null
    country: string | null
    name: string | null
  }

  export type Promotion_codeMaxAggregateOutputType = {
    cdp: string | null
    pc: string | null
    vendor_id: string | null
    country: string | null
    name: string | null
  }

  export type Promotion_codeCountAggregateOutputType = {
    cdp: number
    pc: number
    vendor_id: number
    country: number
    name: number
    _all: number
  }


  export type Promotion_codeMinAggregateInputType = {
    cdp?: true
    pc?: true
    vendor_id?: true
    country?: true
    name?: true
  }

  export type Promotion_codeMaxAggregateInputType = {
    cdp?: true
    pc?: true
    vendor_id?: true
    country?: true
    name?: true
  }

  export type Promotion_codeCountAggregateInputType = {
    cdp?: true
    pc?: true
    vendor_id?: true
    country?: true
    name?: true
    _all?: true
  }

  export type Promotion_codeAggregateArgs = {
    /**
     * Filter which promotion_code to aggregate.
     * 
    **/
    where?: promotion_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promotion_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<promotion_codeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: promotion_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promotion_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promotion_codes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned promotion_codes
    **/
    _count?: true | Promotion_codeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Promotion_codeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Promotion_codeMaxAggregateInputType
  }

  export type GetPromotion_codeAggregateType<T extends Promotion_codeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion_code]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion_code[P]>
      : GetScalarType<T[P], AggregatePromotion_code[P]>
  }




  export type Promotion_codeGroupByArgs = {
    where?: promotion_codeWhereInput
    orderBy?: Enumerable<promotion_codeOrderByWithAggregationInput>
    by: Array<Promotion_codeScalarFieldEnum>
    having?: promotion_codeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Promotion_codeCountAggregateInputType | true
    _min?: Promotion_codeMinAggregateInputType
    _max?: Promotion_codeMaxAggregateInputType
  }


  export type Promotion_codeGroupByOutputType = {
    cdp: string
    pc: string
    vendor_id: string
    country: string
    name: string | null
    _count: Promotion_codeCountAggregateOutputType | null
    _min: Promotion_codeMinAggregateOutputType | null
    _max: Promotion_codeMaxAggregateOutputType | null
  }

  type GetPromotion_codeGroupByPayload<T extends Promotion_codeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Promotion_codeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Promotion_codeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Promotion_codeGroupByOutputType[P]>
            : GetScalarType<T[P], Promotion_codeGroupByOutputType[P]>
        }
      >
    >


  export type promotion_codeSelect = {
    cdp?: boolean
    pc?: boolean
    vendor_id?: boolean
    country?: boolean
    name?: boolean
  }

  export type promotion_codeGetPayload<
    S extends boolean | null | undefined | promotion_codeArgs,
    U = keyof S
      > = S extends true
        ? promotion_code
    : S extends undefined
    ? never
    : S extends promotion_codeArgs | promotion_codeFindManyArgs
    ?'include' extends U
    ? promotion_code 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof promotion_code ? promotion_code[P] : never
  } 
    : promotion_code
  : promotion_code


  type promotion_codeCountArgs = Merge<
    Omit<promotion_codeFindManyArgs, 'select' | 'include'> & {
      select?: Promotion_codeCountAggregateInputType | true
    }
  >

  export interface promotion_codeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Promotion_code that matches the filter.
     * @param {promotion_codeFindUniqueArgs} args - Arguments to find a Promotion_code
     * @example
     * // Get one Promotion_code
     * const promotion_code = await prisma.promotion_code.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends promotion_codeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, promotion_codeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'promotion_code'> extends True ? CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>> : CheckSelect<T, Prisma__promotion_codeClient<promotion_code | null, null>, Prisma__promotion_codeClient<promotion_codeGetPayload<T> | null, null>>

    /**
     * Find the first Promotion_code that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_codeFindFirstArgs} args - Arguments to find a Promotion_code
     * @example
     * // Get one Promotion_code
     * const promotion_code = await prisma.promotion_code.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends promotion_codeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, promotion_codeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'promotion_code'> extends True ? CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>> : CheckSelect<T, Prisma__promotion_codeClient<promotion_code | null, null>, Prisma__promotion_codeClient<promotion_codeGetPayload<T> | null, null>>

    /**
     * Find zero or more Promotion_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_codeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotion_codes
     * const promotion_codes = await prisma.promotion_code.findMany()
     * 
     * // Get first 10 Promotion_codes
     * const promotion_codes = await prisma.promotion_code.findMany({ take: 10 })
     * 
     * // Only select the `cdp`
     * const promotion_codeWithCdpOnly = await prisma.promotion_code.findMany({ select: { cdp: true } })
     * 
    **/
    findMany<T extends promotion_codeFindManyArgs>(
      args?: SelectSubset<T, promotion_codeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<promotion_code>>, PrismaPromise<Array<promotion_codeGetPayload<T>>>>

    /**
     * Create a Promotion_code.
     * @param {promotion_codeCreateArgs} args - Arguments to create a Promotion_code.
     * @example
     * // Create one Promotion_code
     * const Promotion_code = await prisma.promotion_code.create({
     *   data: {
     *     // ... data to create a Promotion_code
     *   }
     * })
     * 
    **/
    create<T extends promotion_codeCreateArgs>(
      args: SelectSubset<T, promotion_codeCreateArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Create many Promotion_codes.
     *     @param {promotion_codeCreateManyArgs} args - Arguments to create many Promotion_codes.
     *     @example
     *     // Create many Promotion_codes
     *     const promotion_code = await prisma.promotion_code.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends promotion_codeCreateManyArgs>(
      args?: SelectSubset<T, promotion_codeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Promotion_code.
     * @param {promotion_codeDeleteArgs} args - Arguments to delete one Promotion_code.
     * @example
     * // Delete one Promotion_code
     * const Promotion_code = await prisma.promotion_code.delete({
     *   where: {
     *     // ... filter to delete one Promotion_code
     *   }
     * })
     * 
    **/
    delete<T extends promotion_codeDeleteArgs>(
      args: SelectSubset<T, promotion_codeDeleteArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Update one Promotion_code.
     * @param {promotion_codeUpdateArgs} args - Arguments to update one Promotion_code.
     * @example
     * // Update one Promotion_code
     * const promotion_code = await prisma.promotion_code.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends promotion_codeUpdateArgs>(
      args: SelectSubset<T, promotion_codeUpdateArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Delete zero or more Promotion_codes.
     * @param {promotion_codeDeleteManyArgs} args - Arguments to filter Promotion_codes to delete.
     * @example
     * // Delete a few Promotion_codes
     * const { count } = await prisma.promotion_code.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends promotion_codeDeleteManyArgs>(
      args?: SelectSubset<T, promotion_codeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotion_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_codeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotion_codes
     * const promotion_code = await prisma.promotion_code.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends promotion_codeUpdateManyArgs>(
      args: SelectSubset<T, promotion_codeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion_code.
     * @param {promotion_codeUpsertArgs} args - Arguments to update or create a Promotion_code.
     * @example
     * // Update or create a Promotion_code
     * const promotion_code = await prisma.promotion_code.upsert({
     *   create: {
     *     // ... data to create a Promotion_code
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion_code we want to update
     *   }
     * })
    **/
    upsert<T extends promotion_codeUpsertArgs>(
      args: SelectSubset<T, promotion_codeUpsertArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Find one Promotion_code that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {promotion_codeFindUniqueOrThrowArgs} args - Arguments to find a Promotion_code
     * @example
     * // Get one Promotion_code
     * const promotion_code = await prisma.promotion_code.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends promotion_codeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, promotion_codeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Find the first Promotion_code that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_codeFindFirstOrThrowArgs} args - Arguments to find a Promotion_code
     * @example
     * // Get one Promotion_code
     * const promotion_code = await prisma.promotion_code.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends promotion_codeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, promotion_codeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__promotion_codeClient<promotion_code>, Prisma__promotion_codeClient<promotion_codeGetPayload<T>>>

    /**
     * Count the number of Promotion_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {promotion_codeCountArgs} args - Arguments to filter Promotion_codes to count.
     * @example
     * // Count the number of Promotion_codes
     * const count = await prisma.promotion_code.count({
     *   where: {
     *     // ... the filter for the Promotion_codes we want to count
     *   }
     * })
    **/
    count<T extends promotion_codeCountArgs>(
      args?: Subset<T, promotion_codeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Promotion_codeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promotion_codeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Promotion_codeAggregateArgs>(args: Subset<T, Promotion_codeAggregateArgs>): PrismaPromise<GetPromotion_codeAggregateType<T>>

    /**
     * Group by Promotion_code.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Promotion_codeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Promotion_codeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Promotion_codeGroupByArgs['orderBy'] }
        : { orderBy?: Promotion_codeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Promotion_codeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotion_codeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for promotion_code.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__promotion_codeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * promotion_code base type for findUnique actions
   */
  export type promotion_codeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * Filter, which promotion_code to fetch.
     * 
    **/
    where: promotion_codeWhereUniqueInput
  }

  /**
   * promotion_code: findUnique
   */
  export interface promotion_codeFindUniqueArgs extends promotion_codeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * promotion_code base type for findFirst actions
   */
  export type promotion_codeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * Filter, which promotion_code to fetch.
     * 
    **/
    where?: promotion_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promotion_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<promotion_codeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for promotion_codes.
     * 
    **/
    cursor?: promotion_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promotion_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promotion_codes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of promotion_codes.
     * 
    **/
    distinct?: Enumerable<Promotion_codeScalarFieldEnum>
  }

  /**
   * promotion_code: findFirst
   */
  export interface promotion_codeFindFirstArgs extends promotion_codeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * promotion_code findMany
   */
  export type promotion_codeFindManyArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * Filter, which promotion_codes to fetch.
     * 
    **/
    where?: promotion_codeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of promotion_codes to fetch.
     * 
    **/
    orderBy?: Enumerable<promotion_codeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing promotion_codes.
     * 
    **/
    cursor?: promotion_codeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` promotion_codes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` promotion_codes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Promotion_codeScalarFieldEnum>
  }


  /**
   * promotion_code create
   */
  export type promotion_codeCreateArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * The data needed to create a promotion_code.
     * 
    **/
    data: XOR<promotion_codeCreateInput, promotion_codeUncheckedCreateInput>
  }


  /**
   * promotion_code createMany
   */
  export type promotion_codeCreateManyArgs = {
    /**
     * The data used to create many promotion_codes.
     * 
    **/
    data: Enumerable<promotion_codeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * promotion_code update
   */
  export type promotion_codeUpdateArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * The data needed to update a promotion_code.
     * 
    **/
    data: XOR<promotion_codeUpdateInput, promotion_codeUncheckedUpdateInput>
    /**
     * Choose, which promotion_code to update.
     * 
    **/
    where: promotion_codeWhereUniqueInput
  }


  /**
   * promotion_code updateMany
   */
  export type promotion_codeUpdateManyArgs = {
    /**
     * The data used to update promotion_codes.
     * 
    **/
    data: XOR<promotion_codeUpdateManyMutationInput, promotion_codeUncheckedUpdateManyInput>
    /**
     * Filter which promotion_codes to update
     * 
    **/
    where?: promotion_codeWhereInput
  }


  /**
   * promotion_code upsert
   */
  export type promotion_codeUpsertArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * The filter to search for the promotion_code to update in case it exists.
     * 
    **/
    where: promotion_codeWhereUniqueInput
    /**
     * In case the promotion_code found by the `where` argument doesn't exist, create a new promotion_code with this data.
     * 
    **/
    create: XOR<promotion_codeCreateInput, promotion_codeUncheckedCreateInput>
    /**
     * In case the promotion_code was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<promotion_codeUpdateInput, promotion_codeUncheckedUpdateInput>
  }


  /**
   * promotion_code delete
   */
  export type promotion_codeDeleteArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
    /**
     * Filter which promotion_code to delete.
     * 
    **/
    where: promotion_codeWhereUniqueInput
  }


  /**
   * promotion_code deleteMany
   */
  export type promotion_codeDeleteManyArgs = {
    /**
     * Filter which promotion_codes to delete
     * 
    **/
    where?: promotion_codeWhereInput
  }


  /**
   * promotion_code: findUniqueOrThrow
   */
  export type promotion_codeFindUniqueOrThrowArgs = promotion_codeFindUniqueArgsBase
      

  /**
   * promotion_code: findFirstOrThrow
   */
  export type promotion_codeFindFirstOrThrowArgs = promotion_codeFindFirstArgsBase
      

  /**
   * promotion_code without action
   */
  export type promotion_codeArgs = {
    /**
     * Select specific fields to fetch from the promotion_code
     * 
    **/
    select?: promotion_codeSelect | null
  }



  /**
   * Model faq
   */


  export type AggregateFaq = {
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  export type FaqAvgAggregateOutputType = {
    id: number | null
    sort_order: number | null
    subject_id: number | null
  }

  export type FaqSumAggregateOutputType = {
    id: number | null
    sort_order: number | null
    subject_id: number | null
  }

  export type FaqMinAggregateOutputType = {
    id: number | null
    question_kr: string | null
    question_us: string | null
    answer_kr: string | null
    answer_us: string | null
    status: string | null
    sort_order: number | null
    subject_id: number | null
  }

  export type FaqMaxAggregateOutputType = {
    id: number | null
    question_kr: string | null
    question_us: string | null
    answer_kr: string | null
    answer_us: string | null
    status: string | null
    sort_order: number | null
    subject_id: number | null
  }

  export type FaqCountAggregateOutputType = {
    id: number
    question_kr: number
    question_us: number
    answer_kr: number
    answer_us: number
    status: number
    sort_order: number
    subject_id: number
    _all: number
  }


  export type FaqAvgAggregateInputType = {
    id?: true
    sort_order?: true
    subject_id?: true
  }

  export type FaqSumAggregateInputType = {
    id?: true
    sort_order?: true
    subject_id?: true
  }

  export type FaqMinAggregateInputType = {
    id?: true
    question_kr?: true
    question_us?: true
    answer_kr?: true
    answer_us?: true
    status?: true
    sort_order?: true
    subject_id?: true
  }

  export type FaqMaxAggregateInputType = {
    id?: true
    question_kr?: true
    question_us?: true
    answer_kr?: true
    answer_us?: true
    status?: true
    sort_order?: true
    subject_id?: true
  }

  export type FaqCountAggregateInputType = {
    id?: true
    question_kr?: true
    question_us?: true
    answer_kr?: true
    answer_us?: true
    status?: true
    sort_order?: true
    subject_id?: true
    _all?: true
  }

  export type FaqAggregateArgs = {
    /**
     * Filter which faq to aggregate.
     * 
    **/
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faqs
    **/
    _count?: true | FaqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FaqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FaqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqMaxAggregateInputType
  }

  export type GetFaqAggregateType<T extends FaqAggregateArgs> = {
        [P in keyof T & keyof AggregateFaq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaq[P]>
      : GetScalarType<T[P], AggregateFaq[P]>
  }




  export type FaqGroupByArgs = {
    where?: faqWhereInput
    orderBy?: Enumerable<faqOrderByWithAggregationInput>
    by: Array<FaqScalarFieldEnum>
    having?: faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqCountAggregateInputType | true
    _avg?: FaqAvgAggregateInputType
    _sum?: FaqSumAggregateInputType
    _min?: FaqMinAggregateInputType
    _max?: FaqMaxAggregateInputType
  }


  export type FaqGroupByOutputType = {
    id: number
    question_kr: string
    question_us: string | null
    answer_kr: string
    answer_us: string | null
    status: string | null
    sort_order: number
    subject_id: number | null
    _count: FaqCountAggregateOutputType | null
    _avg: FaqAvgAggregateOutputType | null
    _sum: FaqSumAggregateOutputType | null
    _min: FaqMinAggregateOutputType | null
    _max: FaqMaxAggregateOutputType | null
  }

  type GetFaqGroupByPayload<T extends FaqGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FaqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqGroupByOutputType[P]>
            : GetScalarType<T[P], FaqGroupByOutputType[P]>
        }
      >
    >


  export type faqSelect = {
    id?: boolean
    question_kr?: boolean
    question_us?: boolean
    answer_kr?: boolean
    answer_us?: boolean
    status?: boolean
    sort_order?: boolean
    subject_id?: boolean
    subject_faq?: boolean | subject_faqArgs
    keyword_faq?: boolean | keyword_faqFindManyArgs
    _count?: boolean | FaqCountOutputTypeArgs
  }

  export type faqInclude = {
    subject_faq?: boolean | subject_faqArgs
    keyword_faq?: boolean | keyword_faqFindManyArgs
    _count?: boolean | FaqCountOutputTypeArgs
  }

  export type faqGetPayload<
    S extends boolean | null | undefined | faqArgs,
    U = keyof S
      > = S extends true
        ? faq
    : S extends undefined
    ? never
    : S extends faqArgs | faqFindManyArgs
    ?'include' extends U
    ? faq  & {
    [P in TrueKeys<S['include']>]:
        P extends 'subject_faq' ? subject_faqGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'keyword_faq' ? Array < keyword_faqGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? FaqCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'subject_faq' ? subject_faqGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'keyword_faq' ? Array < keyword_faqGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? FaqCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof faq ? faq[P] : never
  } 
    : faq
  : faq


  type faqCountArgs = Merge<
    Omit<faqFindManyArgs, 'select' | 'include'> & {
      select?: FaqCountAggregateInputType | true
    }
  >

  export interface faqDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Faq that matches the filter.
     * @param {faqFindUniqueArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends faqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, faqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'faq'> extends True ? CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>> : CheckSelect<T, Prisma__faqClient<faq | null, null>, Prisma__faqClient<faqGetPayload<T> | null, null>>

    /**
     * Find the first Faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends faqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, faqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'faq'> extends True ? CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>> : CheckSelect<T, Prisma__faqClient<faq | null, null>, Prisma__faqClient<faqGetPayload<T> | null, null>>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faq.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqWithIdOnly = await prisma.faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends faqFindManyArgs>(
      args?: SelectSubset<T, faqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<faq>>, PrismaPromise<Array<faqGetPayload<T>>>>

    /**
     * Create a Faq.
     * @param {faqCreateArgs} args - Arguments to create a Faq.
     * @example
     * // Create one Faq
     * const Faq = await prisma.faq.create({
     *   data: {
     *     // ... data to create a Faq
     *   }
     * })
     * 
    **/
    create<T extends faqCreateArgs>(
      args: SelectSubset<T, faqCreateArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Create many Faqs.
     *     @param {faqCreateManyArgs} args - Arguments to create many Faqs.
     *     @example
     *     // Create many Faqs
     *     const faq = await prisma.faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends faqCreateManyArgs>(
      args?: SelectSubset<T, faqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faq.
     * @param {faqDeleteArgs} args - Arguments to delete one Faq.
     * @example
     * // Delete one Faq
     * const Faq = await prisma.faq.delete({
     *   where: {
     *     // ... filter to delete one Faq
     *   }
     * })
     * 
    **/
    delete<T extends faqDeleteArgs>(
      args: SelectSubset<T, faqDeleteArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Update one Faq.
     * @param {faqUpdateArgs} args - Arguments to update one Faq.
     * @example
     * // Update one Faq
     * const faq = await prisma.faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends faqUpdateArgs>(
      args: SelectSubset<T, faqUpdateArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Delete zero or more Faqs.
     * @param {faqDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends faqDeleteManyArgs>(
      args?: SelectSubset<T, faqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faq = await prisma.faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends faqUpdateManyArgs>(
      args: SelectSubset<T, faqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faq.
     * @param {faqUpsertArgs} args - Arguments to update or create a Faq.
     * @example
     * // Update or create a Faq
     * const faq = await prisma.faq.upsert({
     *   create: {
     *     // ... data to create a Faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faq we want to update
     *   }
     * })
    **/
    upsert<T extends faqUpsertArgs>(
      args: SelectSubset<T, faqUpsertArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Find one Faq that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {faqFindUniqueOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends faqFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, faqFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Find the first Faq that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqFindFirstOrThrowArgs} args - Arguments to find a Faq
     * @example
     * // Get one Faq
     * const faq = await prisma.faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends faqFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faqFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__faqClient<faq>, Prisma__faqClient<faqGetPayload<T>>>

    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faqCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faq.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends faqCountArgs>(
      args?: Subset<T, faqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqAggregateArgs>(args: Subset<T, FaqAggregateArgs>): PrismaPromise<GetFaqAggregateType<T>>

    /**
     * Group by Faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqGroupByArgs['orderBy'] }
        : { orderBy?: FaqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__faqClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subject_faq<T extends subject_faqArgs = {}>(args?: Subset<T, subject_faqArgs>): CheckSelect<T, Prisma__subject_faqClient<subject_faq | Null>, Prisma__subject_faqClient<subject_faqGetPayload<T> | Null>>;

    keyword_faq<T extends keyword_faqFindManyArgs = {}>(args?: Subset<T, keyword_faqFindManyArgs>): CheckSelect<T, PrismaPromise<Array<keyword_faq>| Null>, PrismaPromise<Array<keyword_faqGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * faq base type for findUnique actions
   */
  export type faqFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * Filter, which faq to fetch.
     * 
    **/
    where: faqWhereUniqueInput
  }

  /**
   * faq: findUnique
   */
  export interface faqFindUniqueArgs extends faqFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faq base type for findFirst actions
   */
  export type faqFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * Filter, which faq to fetch.
     * 
    **/
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faqs.
     * 
    **/
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faqs.
     * 
    **/
    distinct?: Enumerable<FaqScalarFieldEnum>
  }

  /**
   * faq: findFirst
   */
  export interface faqFindFirstArgs extends faqFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faq findMany
   */
  export type faqFindManyArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * Filter, which faqs to fetch.
     * 
    **/
    where?: faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faqs.
     * 
    **/
    cursor?: faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FaqScalarFieldEnum>
  }


  /**
   * faq create
   */
  export type faqCreateArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * The data needed to create a faq.
     * 
    **/
    data: XOR<faqCreateInput, faqUncheckedCreateInput>
  }


  /**
   * faq createMany
   */
  export type faqCreateManyArgs = {
    /**
     * The data used to create many faqs.
     * 
    **/
    data: Enumerable<faqCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * faq update
   */
  export type faqUpdateArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * The data needed to update a faq.
     * 
    **/
    data: XOR<faqUpdateInput, faqUncheckedUpdateInput>
    /**
     * Choose, which faq to update.
     * 
    **/
    where: faqWhereUniqueInput
  }


  /**
   * faq updateMany
   */
  export type faqUpdateManyArgs = {
    /**
     * The data used to update faqs.
     * 
    **/
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyInput>
    /**
     * Filter which faqs to update
     * 
    **/
    where?: faqWhereInput
  }


  /**
   * faq upsert
   */
  export type faqUpsertArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * The filter to search for the faq to update in case it exists.
     * 
    **/
    where: faqWhereUniqueInput
    /**
     * In case the faq found by the `where` argument doesn't exist, create a new faq with this data.
     * 
    **/
    create: XOR<faqCreateInput, faqUncheckedCreateInput>
    /**
     * In case the faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<faqUpdateInput, faqUncheckedUpdateInput>
  }


  /**
   * faq delete
   */
  export type faqDeleteArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
    /**
     * Filter which faq to delete.
     * 
    **/
    where: faqWhereUniqueInput
  }


  /**
   * faq deleteMany
   */
  export type faqDeleteManyArgs = {
    /**
     * Filter which faqs to delete
     * 
    **/
    where?: faqWhereInput
  }


  /**
   * faq: findUniqueOrThrow
   */
  export type faqFindUniqueOrThrowArgs = faqFindUniqueArgsBase
      

  /**
   * faq: findFirstOrThrow
   */
  export type faqFindFirstOrThrowArgs = faqFindFirstArgsBase
      

  /**
   * faq without action
   */
  export type faqArgs = {
    /**
     * Select specific fields to fetch from the faq
     * 
    **/
    select?: faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: faqInclude | null
  }



  /**
   * Model error_messages
   */


  export type AggregateError_messages = {
    _count: Error_messagesCountAggregateOutputType | null
    _min: Error_messagesMinAggregateOutputType | null
    _max: Error_messagesMaxAggregateOutputType | null
  }

  export type Error_messagesMinAggregateOutputType = {
    error_code: string | null
    english_message: string | null
    korean_message: string | null
  }

  export type Error_messagesMaxAggregateOutputType = {
    error_code: string | null
    english_message: string | null
    korean_message: string | null
  }

  export type Error_messagesCountAggregateOutputType = {
    error_code: number
    english_message: number
    korean_message: number
    _all: number
  }


  export type Error_messagesMinAggregateInputType = {
    error_code?: true
    english_message?: true
    korean_message?: true
  }

  export type Error_messagesMaxAggregateInputType = {
    error_code?: true
    english_message?: true
    korean_message?: true
  }

  export type Error_messagesCountAggregateInputType = {
    error_code?: true
    english_message?: true
    korean_message?: true
    _all?: true
  }

  export type Error_messagesAggregateArgs = {
    /**
     * Filter which error_messages to aggregate.
     * 
    **/
    where?: error_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of error_messages to fetch.
     * 
    **/
    orderBy?: Enumerable<error_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: error_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` error_messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` error_messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned error_messages
    **/
    _count?: true | Error_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Error_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Error_messagesMaxAggregateInputType
  }

  export type GetError_messagesAggregateType<T extends Error_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateError_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateError_messages[P]>
      : GetScalarType<T[P], AggregateError_messages[P]>
  }




  export type Error_messagesGroupByArgs = {
    where?: error_messagesWhereInput
    orderBy?: Enumerable<error_messagesOrderByWithAggregationInput>
    by: Array<Error_messagesScalarFieldEnum>
    having?: error_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Error_messagesCountAggregateInputType | true
    _min?: Error_messagesMinAggregateInputType
    _max?: Error_messagesMaxAggregateInputType
  }


  export type Error_messagesGroupByOutputType = {
    error_code: string
    english_message: string
    korean_message: string
    _count: Error_messagesCountAggregateOutputType | null
    _min: Error_messagesMinAggregateOutputType | null
    _max: Error_messagesMaxAggregateOutputType | null
  }

  type GetError_messagesGroupByPayload<T extends Error_messagesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Error_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Error_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Error_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Error_messagesGroupByOutputType[P]>
        }
      >
    >


  export type error_messagesSelect = {
    error_code?: boolean
    english_message?: boolean
    korean_message?: boolean
  }

  export type error_messagesGetPayload<
    S extends boolean | null | undefined | error_messagesArgs,
    U = keyof S
      > = S extends true
        ? error_messages
    : S extends undefined
    ? never
    : S extends error_messagesArgs | error_messagesFindManyArgs
    ?'include' extends U
    ? error_messages 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof error_messages ? error_messages[P] : never
  } 
    : error_messages
  : error_messages


  type error_messagesCountArgs = Merge<
    Omit<error_messagesFindManyArgs, 'select' | 'include'> & {
      select?: Error_messagesCountAggregateInputType | true
    }
  >

  export interface error_messagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Error_messages that matches the filter.
     * @param {error_messagesFindUniqueArgs} args - Arguments to find a Error_messages
     * @example
     * // Get one Error_messages
     * const error_messages = await prisma.error_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends error_messagesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, error_messagesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'error_messages'> extends True ? CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>> : CheckSelect<T, Prisma__error_messagesClient<error_messages | null, null>, Prisma__error_messagesClient<error_messagesGetPayload<T> | null, null>>

    /**
     * Find the first Error_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {error_messagesFindFirstArgs} args - Arguments to find a Error_messages
     * @example
     * // Get one Error_messages
     * const error_messages = await prisma.error_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends error_messagesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, error_messagesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'error_messages'> extends True ? CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>> : CheckSelect<T, Prisma__error_messagesClient<error_messages | null, null>, Prisma__error_messagesClient<error_messagesGetPayload<T> | null, null>>

    /**
     * Find zero or more Error_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {error_messagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Error_messages
     * const error_messages = await prisma.error_messages.findMany()
     * 
     * // Get first 10 Error_messages
     * const error_messages = await prisma.error_messages.findMany({ take: 10 })
     * 
     * // Only select the `error_code`
     * const error_messagesWithError_codeOnly = await prisma.error_messages.findMany({ select: { error_code: true } })
     * 
    **/
    findMany<T extends error_messagesFindManyArgs>(
      args?: SelectSubset<T, error_messagesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<error_messages>>, PrismaPromise<Array<error_messagesGetPayload<T>>>>

    /**
     * Create a Error_messages.
     * @param {error_messagesCreateArgs} args - Arguments to create a Error_messages.
     * @example
     * // Create one Error_messages
     * const Error_messages = await prisma.error_messages.create({
     *   data: {
     *     // ... data to create a Error_messages
     *   }
     * })
     * 
    **/
    create<T extends error_messagesCreateArgs>(
      args: SelectSubset<T, error_messagesCreateArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Create many Error_messages.
     *     @param {error_messagesCreateManyArgs} args - Arguments to create many Error_messages.
     *     @example
     *     // Create many Error_messages
     *     const error_messages = await prisma.error_messages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends error_messagesCreateManyArgs>(
      args?: SelectSubset<T, error_messagesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Error_messages.
     * @param {error_messagesDeleteArgs} args - Arguments to delete one Error_messages.
     * @example
     * // Delete one Error_messages
     * const Error_messages = await prisma.error_messages.delete({
     *   where: {
     *     // ... filter to delete one Error_messages
     *   }
     * })
     * 
    **/
    delete<T extends error_messagesDeleteArgs>(
      args: SelectSubset<T, error_messagesDeleteArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Update one Error_messages.
     * @param {error_messagesUpdateArgs} args - Arguments to update one Error_messages.
     * @example
     * // Update one Error_messages
     * const error_messages = await prisma.error_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends error_messagesUpdateArgs>(
      args: SelectSubset<T, error_messagesUpdateArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Delete zero or more Error_messages.
     * @param {error_messagesDeleteManyArgs} args - Arguments to filter Error_messages to delete.
     * @example
     * // Delete a few Error_messages
     * const { count } = await prisma.error_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends error_messagesDeleteManyArgs>(
      args?: SelectSubset<T, error_messagesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Error_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {error_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Error_messages
     * const error_messages = await prisma.error_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends error_messagesUpdateManyArgs>(
      args: SelectSubset<T, error_messagesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Error_messages.
     * @param {error_messagesUpsertArgs} args - Arguments to update or create a Error_messages.
     * @example
     * // Update or create a Error_messages
     * const error_messages = await prisma.error_messages.upsert({
     *   create: {
     *     // ... data to create a Error_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Error_messages we want to update
     *   }
     * })
    **/
    upsert<T extends error_messagesUpsertArgs>(
      args: SelectSubset<T, error_messagesUpsertArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Find one Error_messages that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {error_messagesFindUniqueOrThrowArgs} args - Arguments to find a Error_messages
     * @example
     * // Get one Error_messages
     * const error_messages = await prisma.error_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends error_messagesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, error_messagesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Find the first Error_messages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {error_messagesFindFirstOrThrowArgs} args - Arguments to find a Error_messages
     * @example
     * // Get one Error_messages
     * const error_messages = await prisma.error_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends error_messagesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, error_messagesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__error_messagesClient<error_messages>, Prisma__error_messagesClient<error_messagesGetPayload<T>>>

    /**
     * Count the number of Error_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {error_messagesCountArgs} args - Arguments to filter Error_messages to count.
     * @example
     * // Count the number of Error_messages
     * const count = await prisma.error_messages.count({
     *   where: {
     *     // ... the filter for the Error_messages we want to count
     *   }
     * })
    **/
    count<T extends error_messagesCountArgs>(
      args?: Subset<T, error_messagesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Error_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Error_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Error_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Error_messagesAggregateArgs>(args: Subset<T, Error_messagesAggregateArgs>): PrismaPromise<GetError_messagesAggregateType<T>>

    /**
     * Group by Error_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Error_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Error_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Error_messagesGroupByArgs['orderBy'] }
        : { orderBy?: Error_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Error_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetError_messagesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for error_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__error_messagesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * error_messages base type for findUnique actions
   */
  export type error_messagesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * Filter, which error_messages to fetch.
     * 
    **/
    where: error_messagesWhereUniqueInput
  }

  /**
   * error_messages: findUnique
   */
  export interface error_messagesFindUniqueArgs extends error_messagesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * error_messages base type for findFirst actions
   */
  export type error_messagesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * Filter, which error_messages to fetch.
     * 
    **/
    where?: error_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of error_messages to fetch.
     * 
    **/
    orderBy?: Enumerable<error_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for error_messages.
     * 
    **/
    cursor?: error_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` error_messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` error_messages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of error_messages.
     * 
    **/
    distinct?: Enumerable<Error_messagesScalarFieldEnum>
  }

  /**
   * error_messages: findFirst
   */
  export interface error_messagesFindFirstArgs extends error_messagesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * error_messages findMany
   */
  export type error_messagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * Filter, which error_messages to fetch.
     * 
    **/
    where?: error_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of error_messages to fetch.
     * 
    **/
    orderBy?: Enumerable<error_messagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing error_messages.
     * 
    **/
    cursor?: error_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` error_messages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` error_messages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Error_messagesScalarFieldEnum>
  }


  /**
   * error_messages create
   */
  export type error_messagesCreateArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * The data needed to create a error_messages.
     * 
    **/
    data: XOR<error_messagesCreateInput, error_messagesUncheckedCreateInput>
  }


  /**
   * error_messages createMany
   */
  export type error_messagesCreateManyArgs = {
    /**
     * The data used to create many error_messages.
     * 
    **/
    data: Enumerable<error_messagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * error_messages update
   */
  export type error_messagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * The data needed to update a error_messages.
     * 
    **/
    data: XOR<error_messagesUpdateInput, error_messagesUncheckedUpdateInput>
    /**
     * Choose, which error_messages to update.
     * 
    **/
    where: error_messagesWhereUniqueInput
  }


  /**
   * error_messages updateMany
   */
  export type error_messagesUpdateManyArgs = {
    /**
     * The data used to update error_messages.
     * 
    **/
    data: XOR<error_messagesUpdateManyMutationInput, error_messagesUncheckedUpdateManyInput>
    /**
     * Filter which error_messages to update
     * 
    **/
    where?: error_messagesWhereInput
  }


  /**
   * error_messages upsert
   */
  export type error_messagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * The filter to search for the error_messages to update in case it exists.
     * 
    **/
    where: error_messagesWhereUniqueInput
    /**
     * In case the error_messages found by the `where` argument doesn't exist, create a new error_messages with this data.
     * 
    **/
    create: XOR<error_messagesCreateInput, error_messagesUncheckedCreateInput>
    /**
     * In case the error_messages was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<error_messagesUpdateInput, error_messagesUncheckedUpdateInput>
  }


  /**
   * error_messages delete
   */
  export type error_messagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
    /**
     * Filter which error_messages to delete.
     * 
    **/
    where: error_messagesWhereUniqueInput
  }


  /**
   * error_messages deleteMany
   */
  export type error_messagesDeleteManyArgs = {
    /**
     * Filter which error_messages to delete
     * 
    **/
    where?: error_messagesWhereInput
  }


  /**
   * error_messages: findUniqueOrThrow
   */
  export type error_messagesFindUniqueOrThrowArgs = error_messagesFindUniqueArgsBase
      

  /**
   * error_messages: findFirstOrThrow
   */
  export type error_messagesFindFirstOrThrowArgs = error_messagesFindFirstArgsBase
      

  /**
   * error_messages without action
   */
  export type error_messagesArgs = {
    /**
     * Select specific fields to fetch from the error_messages
     * 
    **/
    select?: error_messagesSelect | null
  }



  /**
   * Model exchange_rate_history
   */


  export type AggregateExchange_rate_history = {
    _count: Exchange_rate_historyCountAggregateOutputType | null
    _avg: Exchange_rate_historyAvgAggregateOutputType | null
    _sum: Exchange_rate_historySumAggregateOutputType | null
    _min: Exchange_rate_historyMinAggregateOutputType | null
    _max: Exchange_rate_historyMaxAggregateOutputType | null
  }

  export type Exchange_rate_historyAvgAggregateOutputType = {
    id: number | null
    exchange_rate_id: number | null
    rate: number | null
  }

  export type Exchange_rate_historySumAggregateOutputType = {
    id: number | null
    exchange_rate_id: number | null
    rate: number | null
  }

  export type Exchange_rate_historyMinAggregateOutputType = {
    id: number | null
    exchange_rate_id: number | null
    rate: number | null
    date: Date | null
  }

  export type Exchange_rate_historyMaxAggregateOutputType = {
    id: number | null
    exchange_rate_id: number | null
    rate: number | null
    date: Date | null
  }

  export type Exchange_rate_historyCountAggregateOutputType = {
    id: number
    exchange_rate_id: number
    rate: number
    date: number
    _all: number
  }


  export type Exchange_rate_historyAvgAggregateInputType = {
    id?: true
    exchange_rate_id?: true
    rate?: true
  }

  export type Exchange_rate_historySumAggregateInputType = {
    id?: true
    exchange_rate_id?: true
    rate?: true
  }

  export type Exchange_rate_historyMinAggregateInputType = {
    id?: true
    exchange_rate_id?: true
    rate?: true
    date?: true
  }

  export type Exchange_rate_historyMaxAggregateInputType = {
    id?: true
    exchange_rate_id?: true
    rate?: true
    date?: true
  }

  export type Exchange_rate_historyCountAggregateInputType = {
    id?: true
    exchange_rate_id?: true
    rate?: true
    date?: true
    _all?: true
  }

  export type Exchange_rate_historyAggregateArgs = {
    /**
     * Filter which exchange_rate_history to aggregate.
     * 
    **/
    where?: exchange_rate_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rate_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_rate_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: exchange_rate_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rate_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rate_histories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exchange_rate_histories
    **/
    _count?: true | Exchange_rate_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exchange_rate_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exchange_rate_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exchange_rate_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exchange_rate_historyMaxAggregateInputType
  }

  export type GetExchange_rate_historyAggregateType<T extends Exchange_rate_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateExchange_rate_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchange_rate_history[P]>
      : GetScalarType<T[P], AggregateExchange_rate_history[P]>
  }




  export type Exchange_rate_historyGroupByArgs = {
    where?: exchange_rate_historyWhereInput
    orderBy?: Enumerable<exchange_rate_historyOrderByWithAggregationInput>
    by: Array<Exchange_rate_historyScalarFieldEnum>
    having?: exchange_rate_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exchange_rate_historyCountAggregateInputType | true
    _avg?: Exchange_rate_historyAvgAggregateInputType
    _sum?: Exchange_rate_historySumAggregateInputType
    _min?: Exchange_rate_historyMinAggregateInputType
    _max?: Exchange_rate_historyMaxAggregateInputType
  }


  export type Exchange_rate_historyGroupByOutputType = {
    id: number
    exchange_rate_id: number
    rate: number
    date: Date
    _count: Exchange_rate_historyCountAggregateOutputType | null
    _avg: Exchange_rate_historyAvgAggregateOutputType | null
    _sum: Exchange_rate_historySumAggregateOutputType | null
    _min: Exchange_rate_historyMinAggregateOutputType | null
    _max: Exchange_rate_historyMaxAggregateOutputType | null
  }

  type GetExchange_rate_historyGroupByPayload<T extends Exchange_rate_historyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Exchange_rate_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exchange_rate_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exchange_rate_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Exchange_rate_historyGroupByOutputType[P]>
        }
      >
    >


  export type exchange_rate_historySelect = {
    id?: boolean
    exchange_rate_id?: boolean
    rate?: boolean
    date?: boolean
    exchange_rates?: boolean | exchange_ratesArgs
  }

  export type exchange_rate_historyInclude = {
    exchange_rates?: boolean | exchange_ratesArgs
  }

  export type exchange_rate_historyGetPayload<
    S extends boolean | null | undefined | exchange_rate_historyArgs,
    U = keyof S
      > = S extends true
        ? exchange_rate_history
    : S extends undefined
    ? never
    : S extends exchange_rate_historyArgs | exchange_rate_historyFindManyArgs
    ?'include' extends U
    ? exchange_rate_history  & {
    [P in TrueKeys<S['include']>]:
        P extends 'exchange_rates' ? exchange_ratesGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'exchange_rates' ? exchange_ratesGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof exchange_rate_history ? exchange_rate_history[P] : never
  } 
    : exchange_rate_history
  : exchange_rate_history


  type exchange_rate_historyCountArgs = Merge<
    Omit<exchange_rate_historyFindManyArgs, 'select' | 'include'> & {
      select?: Exchange_rate_historyCountAggregateInputType | true
    }
  >

  export interface exchange_rate_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Exchange_rate_history that matches the filter.
     * @param {exchange_rate_historyFindUniqueArgs} args - Arguments to find a Exchange_rate_history
     * @example
     * // Get one Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends exchange_rate_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, exchange_rate_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exchange_rate_history'> extends True ? CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>> : CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history | null, null>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T> | null, null>>

    /**
     * Find the first Exchange_rate_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_rate_historyFindFirstArgs} args - Arguments to find a Exchange_rate_history
     * @example
     * // Get one Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends exchange_rate_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, exchange_rate_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exchange_rate_history'> extends True ? CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>> : CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history | null, null>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T> | null, null>>

    /**
     * Find zero or more Exchange_rate_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_rate_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchange_rate_histories
     * const exchange_rate_histories = await prisma.exchange_rate_history.findMany()
     * 
     * // Get first 10 Exchange_rate_histories
     * const exchange_rate_histories = await prisma.exchange_rate_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchange_rate_historyWithIdOnly = await prisma.exchange_rate_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends exchange_rate_historyFindManyArgs>(
      args?: SelectSubset<T, exchange_rate_historyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exchange_rate_history>>, PrismaPromise<Array<exchange_rate_historyGetPayload<T>>>>

    /**
     * Create a Exchange_rate_history.
     * @param {exchange_rate_historyCreateArgs} args - Arguments to create a Exchange_rate_history.
     * @example
     * // Create one Exchange_rate_history
     * const Exchange_rate_history = await prisma.exchange_rate_history.create({
     *   data: {
     *     // ... data to create a Exchange_rate_history
     *   }
     * })
     * 
    **/
    create<T extends exchange_rate_historyCreateArgs>(
      args: SelectSubset<T, exchange_rate_historyCreateArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Create many Exchange_rate_histories.
     *     @param {exchange_rate_historyCreateManyArgs} args - Arguments to create many Exchange_rate_histories.
     *     @example
     *     // Create many Exchange_rate_histories
     *     const exchange_rate_history = await prisma.exchange_rate_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends exchange_rate_historyCreateManyArgs>(
      args?: SelectSubset<T, exchange_rate_historyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exchange_rate_history.
     * @param {exchange_rate_historyDeleteArgs} args - Arguments to delete one Exchange_rate_history.
     * @example
     * // Delete one Exchange_rate_history
     * const Exchange_rate_history = await prisma.exchange_rate_history.delete({
     *   where: {
     *     // ... filter to delete one Exchange_rate_history
     *   }
     * })
     * 
    **/
    delete<T extends exchange_rate_historyDeleteArgs>(
      args: SelectSubset<T, exchange_rate_historyDeleteArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Update one Exchange_rate_history.
     * @param {exchange_rate_historyUpdateArgs} args - Arguments to update one Exchange_rate_history.
     * @example
     * // Update one Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends exchange_rate_historyUpdateArgs>(
      args: SelectSubset<T, exchange_rate_historyUpdateArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Delete zero or more Exchange_rate_histories.
     * @param {exchange_rate_historyDeleteManyArgs} args - Arguments to filter Exchange_rate_histories to delete.
     * @example
     * // Delete a few Exchange_rate_histories
     * const { count } = await prisma.exchange_rate_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends exchange_rate_historyDeleteManyArgs>(
      args?: SelectSubset<T, exchange_rate_historyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchange_rate_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_rate_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchange_rate_histories
     * const exchange_rate_history = await prisma.exchange_rate_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends exchange_rate_historyUpdateManyArgs>(
      args: SelectSubset<T, exchange_rate_historyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exchange_rate_history.
     * @param {exchange_rate_historyUpsertArgs} args - Arguments to update or create a Exchange_rate_history.
     * @example
     * // Update or create a Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.upsert({
     *   create: {
     *     // ... data to create a Exchange_rate_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchange_rate_history we want to update
     *   }
     * })
    **/
    upsert<T extends exchange_rate_historyUpsertArgs>(
      args: SelectSubset<T, exchange_rate_historyUpsertArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Find one Exchange_rate_history that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {exchange_rate_historyFindUniqueOrThrowArgs} args - Arguments to find a Exchange_rate_history
     * @example
     * // Get one Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends exchange_rate_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, exchange_rate_historyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Find the first Exchange_rate_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_rate_historyFindFirstOrThrowArgs} args - Arguments to find a Exchange_rate_history
     * @example
     * // Get one Exchange_rate_history
     * const exchange_rate_history = await prisma.exchange_rate_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends exchange_rate_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exchange_rate_historyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__exchange_rate_historyClient<exchange_rate_history>, Prisma__exchange_rate_historyClient<exchange_rate_historyGetPayload<T>>>

    /**
     * Count the number of Exchange_rate_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_rate_historyCountArgs} args - Arguments to filter Exchange_rate_histories to count.
     * @example
     * // Count the number of Exchange_rate_histories
     * const count = await prisma.exchange_rate_history.count({
     *   where: {
     *     // ... the filter for the Exchange_rate_histories we want to count
     *   }
     * })
    **/
    count<T extends exchange_rate_historyCountArgs>(
      args?: Subset<T, exchange_rate_historyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exchange_rate_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchange_rate_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exchange_rate_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exchange_rate_historyAggregateArgs>(args: Subset<T, Exchange_rate_historyAggregateArgs>): PrismaPromise<GetExchange_rate_historyAggregateType<T>>

    /**
     * Group by Exchange_rate_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exchange_rate_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Exchange_rate_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Exchange_rate_historyGroupByArgs['orderBy'] }
        : { orderBy?: Exchange_rate_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Exchange_rate_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchange_rate_historyGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for exchange_rate_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__exchange_rate_historyClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    exchange_rates<T extends exchange_ratesArgs = {}>(args?: Subset<T, exchange_ratesArgs>): CheckSelect<T, Prisma__exchange_ratesClient<exchange_rates | Null>, Prisma__exchange_ratesClient<exchange_ratesGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * exchange_rate_history base type for findUnique actions
   */
  export type exchange_rate_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * Filter, which exchange_rate_history to fetch.
     * 
    **/
    where: exchange_rate_historyWhereUniqueInput
  }

  /**
   * exchange_rate_history: findUnique
   */
  export interface exchange_rate_historyFindUniqueArgs extends exchange_rate_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchange_rate_history base type for findFirst actions
   */
  export type exchange_rate_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * Filter, which exchange_rate_history to fetch.
     * 
    **/
    where?: exchange_rate_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rate_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_rate_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchange_rate_histories.
     * 
    **/
    cursor?: exchange_rate_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rate_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rate_histories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchange_rate_histories.
     * 
    **/
    distinct?: Enumerable<Exchange_rate_historyScalarFieldEnum>
  }

  /**
   * exchange_rate_history: findFirst
   */
  export interface exchange_rate_historyFindFirstArgs extends exchange_rate_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exchange_rate_history findMany
   */
  export type exchange_rate_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * Filter, which exchange_rate_histories to fetch.
     * 
    **/
    where?: exchange_rate_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rate_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<exchange_rate_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exchange_rate_histories.
     * 
    **/
    cursor?: exchange_rate_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rate_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rate_histories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Exchange_rate_historyScalarFieldEnum>
  }


  /**
   * exchange_rate_history create
   */
  export type exchange_rate_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * The data needed to create a exchange_rate_history.
     * 
    **/
    data: XOR<exchange_rate_historyCreateInput, exchange_rate_historyUncheckedCreateInput>
  }


  /**
   * exchange_rate_history createMany
   */
  export type exchange_rate_historyCreateManyArgs = {
    /**
     * The data used to create many exchange_rate_histories.
     * 
    **/
    data: Enumerable<exchange_rate_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exchange_rate_history update
   */
  export type exchange_rate_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * The data needed to update a exchange_rate_history.
     * 
    **/
    data: XOR<exchange_rate_historyUpdateInput, exchange_rate_historyUncheckedUpdateInput>
    /**
     * Choose, which exchange_rate_history to update.
     * 
    **/
    where: exchange_rate_historyWhereUniqueInput
  }


  /**
   * exchange_rate_history updateMany
   */
  export type exchange_rate_historyUpdateManyArgs = {
    /**
     * The data used to update exchange_rate_histories.
     * 
    **/
    data: XOR<exchange_rate_historyUpdateManyMutationInput, exchange_rate_historyUncheckedUpdateManyInput>
    /**
     * Filter which exchange_rate_histories to update
     * 
    **/
    where?: exchange_rate_historyWhereInput
  }


  /**
   * exchange_rate_history upsert
   */
  export type exchange_rate_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * The filter to search for the exchange_rate_history to update in case it exists.
     * 
    **/
    where: exchange_rate_historyWhereUniqueInput
    /**
     * In case the exchange_rate_history found by the `where` argument doesn't exist, create a new exchange_rate_history with this data.
     * 
    **/
    create: XOR<exchange_rate_historyCreateInput, exchange_rate_historyUncheckedCreateInput>
    /**
     * In case the exchange_rate_history was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<exchange_rate_historyUpdateInput, exchange_rate_historyUncheckedUpdateInput>
  }


  /**
   * exchange_rate_history delete
   */
  export type exchange_rate_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
    /**
     * Filter which exchange_rate_history to delete.
     * 
    **/
    where: exchange_rate_historyWhereUniqueInput
  }


  /**
   * exchange_rate_history deleteMany
   */
  export type exchange_rate_historyDeleteManyArgs = {
    /**
     * Filter which exchange_rate_histories to delete
     * 
    **/
    where?: exchange_rate_historyWhereInput
  }


  /**
   * exchange_rate_history: findUniqueOrThrow
   */
  export type exchange_rate_historyFindUniqueOrThrowArgs = exchange_rate_historyFindUniqueArgsBase
      

  /**
   * exchange_rate_history: findFirstOrThrow
   */
  export type exchange_rate_historyFindFirstOrThrowArgs = exchange_rate_historyFindFirstArgsBase
      

  /**
   * exchange_rate_history without action
   */
  export type exchange_rate_historyArgs = {
    /**
     * Select specific fields to fetch from the exchange_rate_history
     * 
    **/
    select?: exchange_rate_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: exchange_rate_historyInclude | null
  }



  /**
   * Model subject_faq
   */


  export type AggregateSubject_faq = {
    _count: Subject_faqCountAggregateOutputType | null
    _avg: Subject_faqAvgAggregateOutputType | null
    _sum: Subject_faqSumAggregateOutputType | null
    _min: Subject_faqMinAggregateOutputType | null
    _max: Subject_faqMaxAggregateOutputType | null
  }

  export type Subject_faqAvgAggregateOutputType = {
    id: number | null
  }

  export type Subject_faqSumAggregateOutputType = {
    id: number | null
  }

  export type Subject_faqMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Subject_faqMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Subject_faqCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Subject_faqAvgAggregateInputType = {
    id?: true
  }

  export type Subject_faqSumAggregateInputType = {
    id?: true
  }

  export type Subject_faqMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Subject_faqMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Subject_faqCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Subject_faqAggregateArgs = {
    /**
     * Filter which subject_faq to aggregate.
     * 
    **/
    where?: subject_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subject_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subject_faqs
    **/
    _count?: true | Subject_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Subject_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Subject_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Subject_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Subject_faqMaxAggregateInputType
  }

  export type GetSubject_faqAggregateType<T extends Subject_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject_faq[P]>
      : GetScalarType<T[P], AggregateSubject_faq[P]>
  }




  export type Subject_faqGroupByArgs = {
    where?: subject_faqWhereInput
    orderBy?: Enumerable<subject_faqOrderByWithAggregationInput>
    by: Array<Subject_faqScalarFieldEnum>
    having?: subject_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Subject_faqCountAggregateInputType | true
    _avg?: Subject_faqAvgAggregateInputType
    _sum?: Subject_faqSumAggregateInputType
    _min?: Subject_faqMinAggregateInputType
    _max?: Subject_faqMaxAggregateInputType
  }


  export type Subject_faqGroupByOutputType = {
    id: number
    name: string
    _count: Subject_faqCountAggregateOutputType | null
    _avg: Subject_faqAvgAggregateOutputType | null
    _sum: Subject_faqSumAggregateOutputType | null
    _min: Subject_faqMinAggregateOutputType | null
    _max: Subject_faqMaxAggregateOutputType | null
  }

  type GetSubject_faqGroupByPayload<T extends Subject_faqGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Subject_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Subject_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Subject_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Subject_faqGroupByOutputType[P]>
        }
      >
    >


  export type subject_faqSelect = {
    id?: boolean
    name?: boolean
    faq?: boolean | faqFindManyArgs
    _count?: boolean | Subject_faqCountOutputTypeArgs
  }

  export type subject_faqInclude = {
    faq?: boolean | faqFindManyArgs
    _count?: boolean | Subject_faqCountOutputTypeArgs
  }

  export type subject_faqGetPayload<
    S extends boolean | null | undefined | subject_faqArgs,
    U = keyof S
      > = S extends true
        ? subject_faq
    : S extends undefined
    ? never
    : S extends subject_faqArgs | subject_faqFindManyArgs
    ?'include' extends U
    ? subject_faq  & {
    [P in TrueKeys<S['include']>]:
        P extends 'faq' ? Array < faqGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Subject_faqCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'faq' ? Array < faqGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Subject_faqCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof subject_faq ? subject_faq[P] : never
  } 
    : subject_faq
  : subject_faq


  type subject_faqCountArgs = Merge<
    Omit<subject_faqFindManyArgs, 'select' | 'include'> & {
      select?: Subject_faqCountAggregateInputType | true
    }
  >

  export interface subject_faqDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subject_faq that matches the filter.
     * @param {subject_faqFindUniqueArgs} args - Arguments to find a Subject_faq
     * @example
     * // Get one Subject_faq
     * const subject_faq = await prisma.subject_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subject_faqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subject_faqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subject_faq'> extends True ? CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>> : CheckSelect<T, Prisma__subject_faqClient<subject_faq | null, null>, Prisma__subject_faqClient<subject_faqGetPayload<T> | null, null>>

    /**
     * Find the first Subject_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_faqFindFirstArgs} args - Arguments to find a Subject_faq
     * @example
     * // Get one Subject_faq
     * const subject_faq = await prisma.subject_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subject_faqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subject_faqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subject_faq'> extends True ? CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>> : CheckSelect<T, Prisma__subject_faqClient<subject_faq | null, null>, Prisma__subject_faqClient<subject_faqGetPayload<T> | null, null>>

    /**
     * Find zero or more Subject_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_faqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subject_faqs
     * const subject_faqs = await prisma.subject_faq.findMany()
     * 
     * // Get first 10 Subject_faqs
     * const subject_faqs = await prisma.subject_faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subject_faqWithIdOnly = await prisma.subject_faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subject_faqFindManyArgs>(
      args?: SelectSubset<T, subject_faqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subject_faq>>, PrismaPromise<Array<subject_faqGetPayload<T>>>>

    /**
     * Create a Subject_faq.
     * @param {subject_faqCreateArgs} args - Arguments to create a Subject_faq.
     * @example
     * // Create one Subject_faq
     * const Subject_faq = await prisma.subject_faq.create({
     *   data: {
     *     // ... data to create a Subject_faq
     *   }
     * })
     * 
    **/
    create<T extends subject_faqCreateArgs>(
      args: SelectSubset<T, subject_faqCreateArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Create many Subject_faqs.
     *     @param {subject_faqCreateManyArgs} args - Arguments to create many Subject_faqs.
     *     @example
     *     // Create many Subject_faqs
     *     const subject_faq = await prisma.subject_faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subject_faqCreateManyArgs>(
      args?: SelectSubset<T, subject_faqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subject_faq.
     * @param {subject_faqDeleteArgs} args - Arguments to delete one Subject_faq.
     * @example
     * // Delete one Subject_faq
     * const Subject_faq = await prisma.subject_faq.delete({
     *   where: {
     *     // ... filter to delete one Subject_faq
     *   }
     * })
     * 
    **/
    delete<T extends subject_faqDeleteArgs>(
      args: SelectSubset<T, subject_faqDeleteArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Update one Subject_faq.
     * @param {subject_faqUpdateArgs} args - Arguments to update one Subject_faq.
     * @example
     * // Update one Subject_faq
     * const subject_faq = await prisma.subject_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subject_faqUpdateArgs>(
      args: SelectSubset<T, subject_faqUpdateArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Delete zero or more Subject_faqs.
     * @param {subject_faqDeleteManyArgs} args - Arguments to filter Subject_faqs to delete.
     * @example
     * // Delete a few Subject_faqs
     * const { count } = await prisma.subject_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subject_faqDeleteManyArgs>(
      args?: SelectSubset<T, subject_faqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subject_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subject_faqs
     * const subject_faq = await prisma.subject_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subject_faqUpdateManyArgs>(
      args: SelectSubset<T, subject_faqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject_faq.
     * @param {subject_faqUpsertArgs} args - Arguments to update or create a Subject_faq.
     * @example
     * // Update or create a Subject_faq
     * const subject_faq = await prisma.subject_faq.upsert({
     *   create: {
     *     // ... data to create a Subject_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject_faq we want to update
     *   }
     * })
    **/
    upsert<T extends subject_faqUpsertArgs>(
      args: SelectSubset<T, subject_faqUpsertArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Find one Subject_faq that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subject_faqFindUniqueOrThrowArgs} args - Arguments to find a Subject_faq
     * @example
     * // Get one Subject_faq
     * const subject_faq = await prisma.subject_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subject_faqFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subject_faqFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Find the first Subject_faq that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_faqFindFirstOrThrowArgs} args - Arguments to find a Subject_faq
     * @example
     * // Get one Subject_faq
     * const subject_faq = await prisma.subject_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subject_faqFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subject_faqFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subject_faqClient<subject_faq>, Prisma__subject_faqClient<subject_faqGetPayload<T>>>

    /**
     * Count the number of Subject_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subject_faqCountArgs} args - Arguments to filter Subject_faqs to count.
     * @example
     * // Count the number of Subject_faqs
     * const count = await prisma.subject_faq.count({
     *   where: {
     *     // ... the filter for the Subject_faqs we want to count
     *   }
     * })
    **/
    count<T extends subject_faqCountArgs>(
      args?: Subset<T, subject_faqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Subject_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Subject_faqAggregateArgs>(args: Subset<T, Subject_faqAggregateArgs>): PrismaPromise<GetSubject_faqAggregateType<T>>

    /**
     * Group by Subject_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Subject_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Subject_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Subject_faqGroupByArgs['orderBy'] }
        : { orderBy?: Subject_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Subject_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubject_faqGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subject_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subject_faqClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    faq<T extends faqFindManyArgs = {}>(args?: Subset<T, faqFindManyArgs>): CheckSelect<T, PrismaPromise<Array<faq>| Null>, PrismaPromise<Array<faqGetPayload<T>>| Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subject_faq base type for findUnique actions
   */
  export type subject_faqFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * Filter, which subject_faq to fetch.
     * 
    **/
    where: subject_faqWhereUniqueInput
  }

  /**
   * subject_faq: findUnique
   */
  export interface subject_faqFindUniqueArgs extends subject_faqFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject_faq base type for findFirst actions
   */
  export type subject_faqFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * Filter, which subject_faq to fetch.
     * 
    **/
    where?: subject_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subject_faqs.
     * 
    **/
    cursor?: subject_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subject_faqs.
     * 
    **/
    distinct?: Enumerable<Subject_faqScalarFieldEnum>
  }

  /**
   * subject_faq: findFirst
   */
  export interface subject_faqFindFirstArgs extends subject_faqFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject_faq findMany
   */
  export type subject_faqFindManyArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * Filter, which subject_faqs to fetch.
     * 
    **/
    where?: subject_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subject_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<subject_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subject_faqs.
     * 
    **/
    cursor?: subject_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subject_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subject_faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Subject_faqScalarFieldEnum>
  }


  /**
   * subject_faq create
   */
  export type subject_faqCreateArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * The data needed to create a subject_faq.
     * 
    **/
    data: XOR<subject_faqCreateInput, subject_faqUncheckedCreateInput>
  }


  /**
   * subject_faq createMany
   */
  export type subject_faqCreateManyArgs = {
    /**
     * The data used to create many subject_faqs.
     * 
    **/
    data: Enumerable<subject_faqCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subject_faq update
   */
  export type subject_faqUpdateArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * The data needed to update a subject_faq.
     * 
    **/
    data: XOR<subject_faqUpdateInput, subject_faqUncheckedUpdateInput>
    /**
     * Choose, which subject_faq to update.
     * 
    **/
    where: subject_faqWhereUniqueInput
  }


  /**
   * subject_faq updateMany
   */
  export type subject_faqUpdateManyArgs = {
    /**
     * The data used to update subject_faqs.
     * 
    **/
    data: XOR<subject_faqUpdateManyMutationInput, subject_faqUncheckedUpdateManyInput>
    /**
     * Filter which subject_faqs to update
     * 
    **/
    where?: subject_faqWhereInput
  }


  /**
   * subject_faq upsert
   */
  export type subject_faqUpsertArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * The filter to search for the subject_faq to update in case it exists.
     * 
    **/
    where: subject_faqWhereUniqueInput
    /**
     * In case the subject_faq found by the `where` argument doesn't exist, create a new subject_faq with this data.
     * 
    **/
    create: XOR<subject_faqCreateInput, subject_faqUncheckedCreateInput>
    /**
     * In case the subject_faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subject_faqUpdateInput, subject_faqUncheckedUpdateInput>
  }


  /**
   * subject_faq delete
   */
  export type subject_faqDeleteArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
    /**
     * Filter which subject_faq to delete.
     * 
    **/
    where: subject_faqWhereUniqueInput
  }


  /**
   * subject_faq deleteMany
   */
  export type subject_faqDeleteManyArgs = {
    /**
     * Filter which subject_faqs to delete
     * 
    **/
    where?: subject_faqWhereInput
  }


  /**
   * subject_faq: findUniqueOrThrow
   */
  export type subject_faqFindUniqueOrThrowArgs = subject_faqFindUniqueArgsBase
      

  /**
   * subject_faq: findFirstOrThrow
   */
  export type subject_faqFindFirstOrThrowArgs = subject_faqFindFirstArgsBase
      

  /**
   * subject_faq without action
   */
  export type subject_faqArgs = {
    /**
     * Select specific fields to fetch from the subject_faq
     * 
    **/
    select?: subject_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subject_faqInclude | null
  }



  /**
   * Model keyword_faq
   */


  export type AggregateKeyword_faq = {
    _count: Keyword_faqCountAggregateOutputType | null
    _avg: Keyword_faqAvgAggregateOutputType | null
    _sum: Keyword_faqSumAggregateOutputType | null
    _min: Keyword_faqMinAggregateOutputType | null
    _max: Keyword_faqMaxAggregateOutputType | null
  }

  export type Keyword_faqAvgAggregateOutputType = {
    id: number | null
    faq_id: number | null
  }

  export type Keyword_faqSumAggregateOutputType = {
    id: number | null
    faq_id: number | null
  }

  export type Keyword_faqMinAggregateOutputType = {
    id: number | null
    name: string | null
    faq_id: number | null
  }

  export type Keyword_faqMaxAggregateOutputType = {
    id: number | null
    name: string | null
    faq_id: number | null
  }

  export type Keyword_faqCountAggregateOutputType = {
    id: number
    name: number
    faq_id: number
    _all: number
  }


  export type Keyword_faqAvgAggregateInputType = {
    id?: true
    faq_id?: true
  }

  export type Keyword_faqSumAggregateInputType = {
    id?: true
    faq_id?: true
  }

  export type Keyword_faqMinAggregateInputType = {
    id?: true
    name?: true
    faq_id?: true
  }

  export type Keyword_faqMaxAggregateInputType = {
    id?: true
    name?: true
    faq_id?: true
  }

  export type Keyword_faqCountAggregateInputType = {
    id?: true
    name?: true
    faq_id?: true
    _all?: true
  }

  export type Keyword_faqAggregateArgs = {
    /**
     * Filter which keyword_faq to aggregate.
     * 
    **/
    where?: keyword_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keyword_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<keyword_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: keyword_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keyword_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keyword_faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned keyword_faqs
    **/
    _count?: true | Keyword_faqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Keyword_faqAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Keyword_faqSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Keyword_faqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Keyword_faqMaxAggregateInputType
  }

  export type GetKeyword_faqAggregateType<T extends Keyword_faqAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyword_faq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyword_faq[P]>
      : GetScalarType<T[P], AggregateKeyword_faq[P]>
  }




  export type Keyword_faqGroupByArgs = {
    where?: keyword_faqWhereInput
    orderBy?: Enumerable<keyword_faqOrderByWithAggregationInput>
    by: Array<Keyword_faqScalarFieldEnum>
    having?: keyword_faqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Keyword_faqCountAggregateInputType | true
    _avg?: Keyword_faqAvgAggregateInputType
    _sum?: Keyword_faqSumAggregateInputType
    _min?: Keyword_faqMinAggregateInputType
    _max?: Keyword_faqMaxAggregateInputType
  }


  export type Keyword_faqGroupByOutputType = {
    id: number
    name: string
    faq_id: number
    _count: Keyword_faqCountAggregateOutputType | null
    _avg: Keyword_faqAvgAggregateOutputType | null
    _sum: Keyword_faqSumAggregateOutputType | null
    _min: Keyword_faqMinAggregateOutputType | null
    _max: Keyword_faqMaxAggregateOutputType | null
  }

  type GetKeyword_faqGroupByPayload<T extends Keyword_faqGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Keyword_faqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Keyword_faqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Keyword_faqGroupByOutputType[P]>
            : GetScalarType<T[P], Keyword_faqGroupByOutputType[P]>
        }
      >
    >


  export type keyword_faqSelect = {
    id?: boolean
    name?: boolean
    faq_id?: boolean
    faq?: boolean | faqArgs
  }

  export type keyword_faqInclude = {
    faq?: boolean | faqArgs
  }

  export type keyword_faqGetPayload<
    S extends boolean | null | undefined | keyword_faqArgs,
    U = keyof S
      > = S extends true
        ? keyword_faq
    : S extends undefined
    ? never
    : S extends keyword_faqArgs | keyword_faqFindManyArgs
    ?'include' extends U
    ? keyword_faq  & {
    [P in TrueKeys<S['include']>]:
        P extends 'faq' ? faqGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'faq' ? faqGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof keyword_faq ? keyword_faq[P] : never
  } 
    : keyword_faq
  : keyword_faq


  type keyword_faqCountArgs = Merge<
    Omit<keyword_faqFindManyArgs, 'select' | 'include'> & {
      select?: Keyword_faqCountAggregateInputType | true
    }
  >

  export interface keyword_faqDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Keyword_faq that matches the filter.
     * @param {keyword_faqFindUniqueArgs} args - Arguments to find a Keyword_faq
     * @example
     * // Get one Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends keyword_faqFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, keyword_faqFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'keyword_faq'> extends True ? CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>> : CheckSelect<T, Prisma__keyword_faqClient<keyword_faq | null, null>, Prisma__keyword_faqClient<keyword_faqGetPayload<T> | null, null>>

    /**
     * Find the first Keyword_faq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keyword_faqFindFirstArgs} args - Arguments to find a Keyword_faq
     * @example
     * // Get one Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends keyword_faqFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, keyword_faqFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'keyword_faq'> extends True ? CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>> : CheckSelect<T, Prisma__keyword_faqClient<keyword_faq | null, null>, Prisma__keyword_faqClient<keyword_faqGetPayload<T> | null, null>>

    /**
     * Find zero or more Keyword_faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keyword_faqFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keyword_faqs
     * const keyword_faqs = await prisma.keyword_faq.findMany()
     * 
     * // Get first 10 Keyword_faqs
     * const keyword_faqs = await prisma.keyword_faq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyword_faqWithIdOnly = await prisma.keyword_faq.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends keyword_faqFindManyArgs>(
      args?: SelectSubset<T, keyword_faqFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<keyword_faq>>, PrismaPromise<Array<keyword_faqGetPayload<T>>>>

    /**
     * Create a Keyword_faq.
     * @param {keyword_faqCreateArgs} args - Arguments to create a Keyword_faq.
     * @example
     * // Create one Keyword_faq
     * const Keyword_faq = await prisma.keyword_faq.create({
     *   data: {
     *     // ... data to create a Keyword_faq
     *   }
     * })
     * 
    **/
    create<T extends keyword_faqCreateArgs>(
      args: SelectSubset<T, keyword_faqCreateArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Create many Keyword_faqs.
     *     @param {keyword_faqCreateManyArgs} args - Arguments to create many Keyword_faqs.
     *     @example
     *     // Create many Keyword_faqs
     *     const keyword_faq = await prisma.keyword_faq.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends keyword_faqCreateManyArgs>(
      args?: SelectSubset<T, keyword_faqCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Keyword_faq.
     * @param {keyword_faqDeleteArgs} args - Arguments to delete one Keyword_faq.
     * @example
     * // Delete one Keyword_faq
     * const Keyword_faq = await prisma.keyword_faq.delete({
     *   where: {
     *     // ... filter to delete one Keyword_faq
     *   }
     * })
     * 
    **/
    delete<T extends keyword_faqDeleteArgs>(
      args: SelectSubset<T, keyword_faqDeleteArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Update one Keyword_faq.
     * @param {keyword_faqUpdateArgs} args - Arguments to update one Keyword_faq.
     * @example
     * // Update one Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends keyword_faqUpdateArgs>(
      args: SelectSubset<T, keyword_faqUpdateArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Delete zero or more Keyword_faqs.
     * @param {keyword_faqDeleteManyArgs} args - Arguments to filter Keyword_faqs to delete.
     * @example
     * // Delete a few Keyword_faqs
     * const { count } = await prisma.keyword_faq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends keyword_faqDeleteManyArgs>(
      args?: SelectSubset<T, keyword_faqDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keyword_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keyword_faqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keyword_faqs
     * const keyword_faq = await prisma.keyword_faq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends keyword_faqUpdateManyArgs>(
      args: SelectSubset<T, keyword_faqUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Keyword_faq.
     * @param {keyword_faqUpsertArgs} args - Arguments to update or create a Keyword_faq.
     * @example
     * // Update or create a Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.upsert({
     *   create: {
     *     // ... data to create a Keyword_faq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyword_faq we want to update
     *   }
     * })
    **/
    upsert<T extends keyword_faqUpsertArgs>(
      args: SelectSubset<T, keyword_faqUpsertArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Find one Keyword_faq that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {keyword_faqFindUniqueOrThrowArgs} args - Arguments to find a Keyword_faq
     * @example
     * // Get one Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends keyword_faqFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, keyword_faqFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Find the first Keyword_faq that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keyword_faqFindFirstOrThrowArgs} args - Arguments to find a Keyword_faq
     * @example
     * // Get one Keyword_faq
     * const keyword_faq = await prisma.keyword_faq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends keyword_faqFindFirstOrThrowArgs>(
      args?: SelectSubset<T, keyword_faqFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__keyword_faqClient<keyword_faq>, Prisma__keyword_faqClient<keyword_faqGetPayload<T>>>

    /**
     * Count the number of Keyword_faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keyword_faqCountArgs} args - Arguments to filter Keyword_faqs to count.
     * @example
     * // Count the number of Keyword_faqs
     * const count = await prisma.keyword_faq.count({
     *   where: {
     *     // ... the filter for the Keyword_faqs we want to count
     *   }
     * })
    **/
    count<T extends keyword_faqCountArgs>(
      args?: Subset<T, keyword_faqCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Keyword_faqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyword_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Keyword_faqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Keyword_faqAggregateArgs>(args: Subset<T, Keyword_faqAggregateArgs>): PrismaPromise<GetKeyword_faqAggregateType<T>>

    /**
     * Group by Keyword_faq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Keyword_faqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Keyword_faqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Keyword_faqGroupByArgs['orderBy'] }
        : { orderBy?: Keyword_faqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Keyword_faqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyword_faqGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for keyword_faq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__keyword_faqClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    faq<T extends faqArgs = {}>(args?: Subset<T, faqArgs>): CheckSelect<T, Prisma__faqClient<faq | Null>, Prisma__faqClient<faqGetPayload<T> | Null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * keyword_faq base type for findUnique actions
   */
  export type keyword_faqFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * Filter, which keyword_faq to fetch.
     * 
    **/
    where: keyword_faqWhereUniqueInput
  }

  /**
   * keyword_faq: findUnique
   */
  export interface keyword_faqFindUniqueArgs extends keyword_faqFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * keyword_faq base type for findFirst actions
   */
  export type keyword_faqFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * Filter, which keyword_faq to fetch.
     * 
    **/
    where?: keyword_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keyword_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<keyword_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keyword_faqs.
     * 
    **/
    cursor?: keyword_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keyword_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keyword_faqs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keyword_faqs.
     * 
    **/
    distinct?: Enumerable<Keyword_faqScalarFieldEnum>
  }

  /**
   * keyword_faq: findFirst
   */
  export interface keyword_faqFindFirstArgs extends keyword_faqFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * keyword_faq findMany
   */
  export type keyword_faqFindManyArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * Filter, which keyword_faqs to fetch.
     * 
    **/
    where?: keyword_faqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keyword_faqs to fetch.
     * 
    **/
    orderBy?: Enumerable<keyword_faqOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing keyword_faqs.
     * 
    **/
    cursor?: keyword_faqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keyword_faqs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keyword_faqs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Keyword_faqScalarFieldEnum>
  }


  /**
   * keyword_faq create
   */
  export type keyword_faqCreateArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * The data needed to create a keyword_faq.
     * 
    **/
    data: XOR<keyword_faqCreateInput, keyword_faqUncheckedCreateInput>
  }


  /**
   * keyword_faq createMany
   */
  export type keyword_faqCreateManyArgs = {
    /**
     * The data used to create many keyword_faqs.
     * 
    **/
    data: Enumerable<keyword_faqCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * keyword_faq update
   */
  export type keyword_faqUpdateArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * The data needed to update a keyword_faq.
     * 
    **/
    data: XOR<keyword_faqUpdateInput, keyword_faqUncheckedUpdateInput>
    /**
     * Choose, which keyword_faq to update.
     * 
    **/
    where: keyword_faqWhereUniqueInput
  }


  /**
   * keyword_faq updateMany
   */
  export type keyword_faqUpdateManyArgs = {
    /**
     * The data used to update keyword_faqs.
     * 
    **/
    data: XOR<keyword_faqUpdateManyMutationInput, keyword_faqUncheckedUpdateManyInput>
    /**
     * Filter which keyword_faqs to update
     * 
    **/
    where?: keyword_faqWhereInput
  }


  /**
   * keyword_faq upsert
   */
  export type keyword_faqUpsertArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * The filter to search for the keyword_faq to update in case it exists.
     * 
    **/
    where: keyword_faqWhereUniqueInput
    /**
     * In case the keyword_faq found by the `where` argument doesn't exist, create a new keyword_faq with this data.
     * 
    **/
    create: XOR<keyword_faqCreateInput, keyword_faqUncheckedCreateInput>
    /**
     * In case the keyword_faq was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<keyword_faqUpdateInput, keyword_faqUncheckedUpdateInput>
  }


  /**
   * keyword_faq delete
   */
  export type keyword_faqDeleteArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
    /**
     * Filter which keyword_faq to delete.
     * 
    **/
    where: keyword_faqWhereUniqueInput
  }


  /**
   * keyword_faq deleteMany
   */
  export type keyword_faqDeleteManyArgs = {
    /**
     * Filter which keyword_faqs to delete
     * 
    **/
    where?: keyword_faqWhereInput
  }


  /**
   * keyword_faq: findUniqueOrThrow
   */
  export type keyword_faqFindUniqueOrThrowArgs = keyword_faqFindUniqueArgsBase
      

  /**
   * keyword_faq: findFirstOrThrow
   */
  export type keyword_faqFindFirstOrThrowArgs = keyword_faqFindFirstArgsBase
      

  /**
   * keyword_faq without action
   */
  export type keyword_faqArgs = {
    /**
     * Select specific fields to fetch from the keyword_faq
     * 
    **/
    select?: keyword_faqSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: keyword_faqInclude | null
  }



  /**
   * Model cities_locations
   */


  export type AggregateCities_locations = {
    _count: Cities_locationsCountAggregateOutputType | null
    _min: Cities_locationsMinAggregateOutputType | null
    _max: Cities_locationsMaxAggregateOutputType | null
  }

  export type Cities_locationsMinAggregateOutputType = {
    city_code: string | null
    location_id: string | null
  }

  export type Cities_locationsMaxAggregateOutputType = {
    city_code: string | null
    location_id: string | null
  }

  export type Cities_locationsCountAggregateOutputType = {
    city_code: number
    location_id: number
    _all: number
  }


  export type Cities_locationsMinAggregateInputType = {
    city_code?: true
    location_id?: true
  }

  export type Cities_locationsMaxAggregateInputType = {
    city_code?: true
    location_id?: true
  }

  export type Cities_locationsCountAggregateInputType = {
    city_code?: true
    location_id?: true
    _all?: true
  }

  export type Cities_locationsAggregateArgs = {
    /**
     * Filter which cities_locations to aggregate.
     * 
    **/
    where?: cities_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_locations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cities_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities_locations
    **/
    _count?: true | Cities_locationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cities_locationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cities_locationsMaxAggregateInputType
  }

  export type GetCities_locationsAggregateType<T extends Cities_locationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCities_locations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities_locations[P]>
      : GetScalarType<T[P], AggregateCities_locations[P]>
  }




  export type Cities_locationsGroupByArgs = {
    where?: cities_locationsWhereInput
    orderBy?: Enumerable<cities_locationsOrderByWithAggregationInput>
    by: Array<Cities_locationsScalarFieldEnum>
    having?: cities_locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cities_locationsCountAggregateInputType | true
    _min?: Cities_locationsMinAggregateInputType
    _max?: Cities_locationsMaxAggregateInputType
  }


  export type Cities_locationsGroupByOutputType = {
    city_code: string
    location_id: string
    _count: Cities_locationsCountAggregateOutputType | null
    _min: Cities_locationsMinAggregateOutputType | null
    _max: Cities_locationsMaxAggregateOutputType | null
  }

  type GetCities_locationsGroupByPayload<T extends Cities_locationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cities_locationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cities_locationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cities_locationsGroupByOutputType[P]>
            : GetScalarType<T[P], Cities_locationsGroupByOutputType[P]>
        }
      >
    >


  export type cities_locationsSelect = {
    city_code?: boolean
    location_id?: boolean
  }

  export type cities_locationsGetPayload<
    S extends boolean | null | undefined | cities_locationsArgs,
    U = keyof S
      > = S extends true
        ? cities_locations
    : S extends undefined
    ? never
    : S extends cities_locationsArgs | cities_locationsFindManyArgs
    ?'include' extends U
    ? cities_locations 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof cities_locations ? cities_locations[P] : never
  } 
    : cities_locations
  : cities_locations


  type cities_locationsCountArgs = Merge<
    Omit<cities_locationsFindManyArgs, 'select' | 'include'> & {
      select?: Cities_locationsCountAggregateInputType | true
    }
  >

  export interface cities_locationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cities_locations that matches the filter.
     * @param {cities_locationsFindUniqueArgs} args - Arguments to find a Cities_locations
     * @example
     * // Get one Cities_locations
     * const cities_locations = await prisma.cities_locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cities_locationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cities_locationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cities_locations'> extends True ? CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>> : CheckSelect<T, Prisma__cities_locationsClient<cities_locations | null, null>, Prisma__cities_locationsClient<cities_locationsGetPayload<T> | null, null>>

    /**
     * Find the first Cities_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_locationsFindFirstArgs} args - Arguments to find a Cities_locations
     * @example
     * // Get one Cities_locations
     * const cities_locations = await prisma.cities_locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cities_locationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cities_locationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cities_locations'> extends True ? CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>> : CheckSelect<T, Prisma__cities_locationsClient<cities_locations | null, null>, Prisma__cities_locationsClient<cities_locationsGetPayload<T> | null, null>>

    /**
     * Find zero or more Cities_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_locationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities_locations
     * const cities_locations = await prisma.cities_locations.findMany()
     * 
     * // Get first 10 Cities_locations
     * const cities_locations = await prisma.cities_locations.findMany({ take: 10 })
     * 
     * // Only select the `city_code`
     * const cities_locationsWithCity_codeOnly = await prisma.cities_locations.findMany({ select: { city_code: true } })
     * 
    **/
    findMany<T extends cities_locationsFindManyArgs>(
      args?: SelectSubset<T, cities_locationsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<cities_locations>>, PrismaPromise<Array<cities_locationsGetPayload<T>>>>

    /**
     * Create a Cities_locations.
     * @param {cities_locationsCreateArgs} args - Arguments to create a Cities_locations.
     * @example
     * // Create one Cities_locations
     * const Cities_locations = await prisma.cities_locations.create({
     *   data: {
     *     // ... data to create a Cities_locations
     *   }
     * })
     * 
    **/
    create<T extends cities_locationsCreateArgs>(
      args: SelectSubset<T, cities_locationsCreateArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Create many Cities_locations.
     *     @param {cities_locationsCreateManyArgs} args - Arguments to create many Cities_locations.
     *     @example
     *     // Create many Cities_locations
     *     const cities_locations = await prisma.cities_locations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cities_locationsCreateManyArgs>(
      args?: SelectSubset<T, cities_locationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cities_locations.
     * @param {cities_locationsDeleteArgs} args - Arguments to delete one Cities_locations.
     * @example
     * // Delete one Cities_locations
     * const Cities_locations = await prisma.cities_locations.delete({
     *   where: {
     *     // ... filter to delete one Cities_locations
     *   }
     * })
     * 
    **/
    delete<T extends cities_locationsDeleteArgs>(
      args: SelectSubset<T, cities_locationsDeleteArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Update one Cities_locations.
     * @param {cities_locationsUpdateArgs} args - Arguments to update one Cities_locations.
     * @example
     * // Update one Cities_locations
     * const cities_locations = await prisma.cities_locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cities_locationsUpdateArgs>(
      args: SelectSubset<T, cities_locationsUpdateArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Delete zero or more Cities_locations.
     * @param {cities_locationsDeleteManyArgs} args - Arguments to filter Cities_locations to delete.
     * @example
     * // Delete a few Cities_locations
     * const { count } = await prisma.cities_locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cities_locationsDeleteManyArgs>(
      args?: SelectSubset<T, cities_locationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities_locations
     * const cities_locations = await prisma.cities_locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cities_locationsUpdateManyArgs>(
      args: SelectSubset<T, cities_locationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities_locations.
     * @param {cities_locationsUpsertArgs} args - Arguments to update or create a Cities_locations.
     * @example
     * // Update or create a Cities_locations
     * const cities_locations = await prisma.cities_locations.upsert({
     *   create: {
     *     // ... data to create a Cities_locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities_locations we want to update
     *   }
     * })
    **/
    upsert<T extends cities_locationsUpsertArgs>(
      args: SelectSubset<T, cities_locationsUpsertArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Find one Cities_locations that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cities_locationsFindUniqueOrThrowArgs} args - Arguments to find a Cities_locations
     * @example
     * // Get one Cities_locations
     * const cities_locations = await prisma.cities_locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cities_locationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cities_locationsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Find the first Cities_locations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_locationsFindFirstOrThrowArgs} args - Arguments to find a Cities_locations
     * @example
     * // Get one Cities_locations
     * const cities_locations = await prisma.cities_locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cities_locationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cities_locationsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__cities_locationsClient<cities_locations>, Prisma__cities_locationsClient<cities_locationsGetPayload<T>>>

    /**
     * Count the number of Cities_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cities_locationsCountArgs} args - Arguments to filter Cities_locations to count.
     * @example
     * // Count the number of Cities_locations
     * const count = await prisma.cities_locations.count({
     *   where: {
     *     // ... the filter for the Cities_locations we want to count
     *   }
     * })
    **/
    count<T extends cities_locationsCountArgs>(
      args?: Subset<T, cities_locationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cities_locationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cities_locationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cities_locationsAggregateArgs>(args: Subset<T, Cities_locationsAggregateArgs>): PrismaPromise<GetCities_locationsAggregateType<T>>

    /**
     * Group by Cities_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cities_locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cities_locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cities_locationsGroupByArgs['orderBy'] }
        : { orderBy?: Cities_locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cities_locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCities_locationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cities_locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cities_locationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cities_locations base type for findUnique actions
   */
  export type cities_locationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * Filter, which cities_locations to fetch.
     * 
    **/
    where: cities_locationsWhereUniqueInput
  }

  /**
   * cities_locations: findUnique
   */
  export interface cities_locationsFindUniqueArgs extends cities_locationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities_locations base type for findFirst actions
   */
  export type cities_locationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * Filter, which cities_locations to fetch.
     * 
    **/
    where?: cities_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_locations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities_locations.
     * 
    **/
    cursor?: cities_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_locations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities_locations.
     * 
    **/
    distinct?: Enumerable<Cities_locationsScalarFieldEnum>
  }

  /**
   * cities_locations: findFirst
   */
  export interface cities_locationsFindFirstArgs extends cities_locationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cities_locations findMany
   */
  export type cities_locationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * Filter, which cities_locations to fetch.
     * 
    **/
    where?: cities_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities_locations to fetch.
     * 
    **/
    orderBy?: Enumerable<cities_locationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities_locations.
     * 
    **/
    cursor?: cities_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities_locations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities_locations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cities_locationsScalarFieldEnum>
  }


  /**
   * cities_locations create
   */
  export type cities_locationsCreateArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * The data needed to create a cities_locations.
     * 
    **/
    data: XOR<cities_locationsCreateInput, cities_locationsUncheckedCreateInput>
  }


  /**
   * cities_locations createMany
   */
  export type cities_locationsCreateManyArgs = {
    /**
     * The data used to create many cities_locations.
     * 
    **/
    data: Enumerable<cities_locationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cities_locations update
   */
  export type cities_locationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * The data needed to update a cities_locations.
     * 
    **/
    data: XOR<cities_locationsUpdateInput, cities_locationsUncheckedUpdateInput>
    /**
     * Choose, which cities_locations to update.
     * 
    **/
    where: cities_locationsWhereUniqueInput
  }


  /**
   * cities_locations updateMany
   */
  export type cities_locationsUpdateManyArgs = {
    /**
     * The data used to update cities_locations.
     * 
    **/
    data: XOR<cities_locationsUpdateManyMutationInput, cities_locationsUncheckedUpdateManyInput>
    /**
     * Filter which cities_locations to update
     * 
    **/
    where?: cities_locationsWhereInput
  }


  /**
   * cities_locations upsert
   */
  export type cities_locationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * The filter to search for the cities_locations to update in case it exists.
     * 
    **/
    where: cities_locationsWhereUniqueInput
    /**
     * In case the cities_locations found by the `where` argument doesn't exist, create a new cities_locations with this data.
     * 
    **/
    create: XOR<cities_locationsCreateInput, cities_locationsUncheckedCreateInput>
    /**
     * In case the cities_locations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cities_locationsUpdateInput, cities_locationsUncheckedUpdateInput>
  }


  /**
   * cities_locations delete
   */
  export type cities_locationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
    /**
     * Filter which cities_locations to delete.
     * 
    **/
    where: cities_locationsWhereUniqueInput
  }


  /**
   * cities_locations deleteMany
   */
  export type cities_locationsDeleteManyArgs = {
    /**
     * Filter which cities_locations to delete
     * 
    **/
    where?: cities_locationsWhereInput
  }


  /**
   * cities_locations: findUniqueOrThrow
   */
  export type cities_locationsFindUniqueOrThrowArgs = cities_locationsFindUniqueArgsBase
      

  /**
   * cities_locations: findFirstOrThrow
   */
  export type cities_locationsFindFirstOrThrowArgs = cities_locationsFindFirstArgsBase
      

  /**
   * cities_locations without action
   */
  export type cities_locationsArgs = {
    /**
     * Select specific fields to fetch from the cities_locations
     * 
    **/
    select?: cities_locationsSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Admin_permissionsScalarFieldEnum: {
    id: 'id',
    action: 'action',
    description: 'description'
  };

  export type Admin_permissionsScalarFieldEnum = (typeof Admin_permissionsScalarFieldEnum)[keyof typeof Admin_permissionsScalarFieldEnum]


  export const Admin_rolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_date: 'created_date',
    modified_date: 'modified_date',
    created_by: 'created_by',
    modified_by: 'modified_by',
    deleted: 'deleted'
  };

  export type Admin_rolesScalarFieldEnum = (typeof Admin_rolesScalarFieldEnum)[keyof typeof Admin_rolesScalarFieldEnum]


  export const Admin_roles_permissionsScalarFieldEnum: {
    permission_id: 'permission_id',
    role_id: 'role_id'
  };

  export type Admin_roles_permissionsScalarFieldEnum = (typeof Admin_roles_permissionsScalarFieldEnum)[keyof typeof Admin_roles_permissionsScalarFieldEnum]


  export const Admin_usersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    hash_pass: 'hash_pass',
    first_name: 'first_name',
    last_name: 'last_name',
    phone_mobile: 'phone_mobile',
    address: 'address',
    created_date: 'created_date',
    modified_date: 'modified_date',
    created_by: 'created_by',
    deleted: 'deleted',
    hash_rt: 'hash_rt',
    modified_by: 'modified_by',
    status: 'status',
    agency_id: 'agency_id'
  };

  export type Admin_usersScalarFieldEnum = (typeof Admin_usersScalarFieldEnum)[keyof typeof Admin_usersScalarFieldEnum]


  export const Admin_users_rolesScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id'
  };

  export type Admin_users_rolesScalarFieldEnum = (typeof Admin_users_rolesScalarFieldEnum)[keyof typeof Admin_users_rolesScalarFieldEnum]


  export const AgenciesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    created_date: 'created_date'
  };

  export type AgenciesScalarFieldEnum = (typeof AgenciesScalarFieldEnum)[keyof typeof AgenciesScalarFieldEnum]


  export const AirportsScalarFieldEnum: {
    iata_code: 'iata_code',
    country_code: 'country_code',
    icao_code: 'icao_code',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    id: 'id'
  };

  export type AirportsScalarFieldEnum = (typeof AirportsScalarFieldEnum)[keyof typeof AirportsScalarFieldEnum]


  export const Api_keyScalarFieldEnum: {
    client_id: 'client_id',
    key: 'key'
  };

  export type Api_keyScalarFieldEnum = (typeof Api_keyScalarFieldEnum)[keyof typeof Api_keyScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    code: 'code',
    name: 'name',
    un_locode: 'un_locode',
    latitude: 'latitude',
    longitude: 'longitude',
    alt: 'alt',
    timezone: 'timezone',
    country_code: 'country_code'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const Cities_locationsScalarFieldEnum: {
    city_code: 'city_code',
    location_id: 'location_id'
  };

  export type Cities_locationsScalarFieldEnum = (typeof Cities_locationsScalarFieldEnum)[keyof typeof Cities_locationsScalarFieldEnum]


  export const Cities_translationScalarFieldEnum: {
    city_code: 'city_code',
    locale: 'locale',
    city_name: 'city_name'
  };

  export type Cities_translationScalarFieldEnum = (typeof Cities_translationScalarFieldEnum)[keyof typeof Cities_translationScalarFieldEnum]


  export const Commission_settingScalarFieldEnum: {
    id: 'id',
    vendor: 'vendor',
    agency: 'agency',
    payment_type: 'payment_type',
    tag: 'tag',
    calculation_type: 'calculation_type',
    amount: 'amount'
  };

  export type Commission_settingScalarFieldEnum = (typeof Commission_settingScalarFieldEnum)[keyof typeof Commission_settingScalarFieldEnum]


  export const CountriesScalarFieldEnum: {
    code: 'code',
    code_3: 'code_3',
    name: 'name',
    continent: 'continent',
    currency: 'currency'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const Countries_translationScalarFieldEnum: {
    country_code: 'country_code',
    locale: 'locale',
    country_name: 'country_name'
  };

  export type Countries_translationScalarFieldEnum = (typeof Countries_translationScalarFieldEnum)[keyof typeof Countries_translationScalarFieldEnum]


  export const CouponsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    coupon_name: 'coupon_name',
    brand: 'brand',
    destination: 'destination',
    offer_description: 'offer_description',
    corporate_discount_number: 'corporate_discount_number',
    promotion_code: 'promotion_code',
    min_days: 'min_days',
    car_group: 'car_group',
    pickup_start_time: 'pickup_start_time',
    pickup_end_time: 'pickup_end_time',
    order_start_time: 'order_start_time',
    order_end_time: 'order_end_time',
    issued_count: 'issued_count',
    used_count: 'used_count',
    status: 'status',
    remark: 'remark'
  };

  export type CouponsScalarFieldEnum = (typeof CouponsScalarFieldEnum)[keyof typeof CouponsScalarFieldEnum]


  export const Error_messagesScalarFieldEnum: {
    error_code: 'error_code',
    english_message: 'english_message',
    korean_message: 'korean_message'
  };

  export type Error_messagesScalarFieldEnum = (typeof Error_messagesScalarFieldEnum)[keyof typeof Error_messagesScalarFieldEnum]


  export const Exchange_rate_historyScalarFieldEnum: {
    id: 'id',
    exchange_rate_id: 'exchange_rate_id',
    rate: 'rate',
    date: 'date'
  };

  export type Exchange_rate_historyScalarFieldEnum = (typeof Exchange_rate_historyScalarFieldEnum)[keyof typeof Exchange_rate_historyScalarFieldEnum]


  export const Exchange_ratesScalarFieldEnum: {
    id: 'id',
    from_code: 'from_code',
    to_code: 'to_code',
    rate: 'rate'
  };

  export type Exchange_ratesScalarFieldEnum = (typeof Exchange_ratesScalarFieldEnum)[keyof typeof Exchange_ratesScalarFieldEnum]


  export const FaqScalarFieldEnum: {
    id: 'id',
    question_kr: 'question_kr',
    question_us: 'question_us',
    answer_kr: 'answer_kr',
    answer_us: 'answer_us',
    status: 'status',
    sort_order: 'sort_order',
    subject_id: 'subject_id'
  };

  export type FaqScalarFieldEnum = (typeof FaqScalarFieldEnum)[keyof typeof FaqScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    file_key: 'file_key',
    file_url: 'file_url'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const Keyword_faqScalarFieldEnum: {
    id: 'id',
    name: 'name',
    faq_id: 'faq_id'
  };

  export type Keyword_faqScalarFieldEnum = (typeof Keyword_faqScalarFieldEnum)[keyof typeof Keyword_faqScalarFieldEnum]


  export const LocalesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    default: 'default'
  };

  export type LocalesScalarFieldEnum = (typeof LocalesScalarFieldEnum)[keyof typeof LocalesScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    city_code: 'city_code',
    vendor_id: 'vendor_id',
    oag_code: 'oag_code',
    country_code: 'country_code',
    state: 'state',
    zip_code: 'zip_code',
    phone: 'phone',
    alt_phone: 'alt_phone',
    fax: 'fax',
    telex: 'telex',
    web_url: 'web_url',
    email: 'email',
    latitude: 'latitude',
    longitude: 'longitude',
    open_1_mon: 'open_1_mon',
    close_1_mon: 'close_1_mon',
    open_2_mon: 'open_2_mon',
    close_2_mon: 'close_2_mon',
    open_3_mon: 'open_3_mon',
    close_3_mon: 'close_3_mon',
    open_1_tue: 'open_1_tue',
    close_1_tue: 'close_1_tue',
    open_2_tue: 'open_2_tue',
    close_2_tue: 'close_2_tue',
    open_3_tue: 'open_3_tue',
    close_3_tue: 'close_3_tue',
    open_1_wed: 'open_1_wed',
    close_1_wed: 'close_1_wed',
    open_2_wed: 'open_2_wed',
    close_2_wed: 'close_2_wed',
    open_3_wed: 'open_3_wed',
    close_3_wed: 'close_3_wed',
    open_1_thu: 'open_1_thu',
    close_1_thu: 'close_1_thu',
    open_2_thu: 'open_2_thu',
    close_2_thu: 'close_2_thu',
    open_3_thu: 'open_3_thu',
    close_3_thu: 'close_3_thu',
    open_1_fri: 'open_1_fri',
    close_1_fri: 'close_1_fri',
    open_2_fri: 'open_2_fri',
    close_2_fri: 'close_2_fri',
    open_3_fri: 'open_3_fri',
    close_3_fri: 'close_3_fri',
    open_1_sat: 'open_1_sat',
    close_1_sat: 'close_1_sat',
    open_2_sat: 'open_2_sat',
    close_2_sat: 'close_2_sat',
    open_3_sat: 'open_3_sat',
    close_3_sat: 'close_3_sat',
    open_1_sun: 'open_1_sun',
    close_1_sun: 'close_1_sun',
    open_2_sun: 'open_2_sun',
    close_2_sun: 'close_2_sun',
    open_3_sun: 'open_3_sun',
    close_3_sun: 'close_3_sun',
    loc_type_1: 'loc_type_1',
    loc_type_2: 'loc_type_2',
    city_name: 'city_name',
    category_id: 'category_id'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const Location_descriptionScalarFieldEnum: {
    location_id: 'location_id',
    locale: 'locale',
    description: 'description',
    address_1: 'address_1',
    address_2: 'address_2',
    address_3: 'address_3'
  };

  export type Location_descriptionScalarFieldEnum = (typeof Location_descriptionScalarFieldEnum)[keyof typeof Location_descriptionScalarFieldEnum]


  export const Location_type_1ScalarFieldEnum: {
    type: 'type',
    description: 'description'
  };

  export type Location_type_1ScalarFieldEnum = (typeof Location_type_1ScalarFieldEnum)[keyof typeof Location_type_1ScalarFieldEnum]


  export const Location_type_2ScalarFieldEnum: {
    type: 'type',
    description: 'description'
  };

  export type Location_type_2ScalarFieldEnum = (typeof Location_type_2ScalarFieldEnum)[keyof typeof Location_type_2ScalarFieldEnum]


  export const PackagesScalarFieldEnum: {
    price_id: 'price_id',
    service_id: 'service_id'
  };

  export type PackagesScalarFieldEnum = (typeof PackagesScalarFieldEnum)[keyof typeof PackagesScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    order_id: 'order_id',
    user_id: 'user_id',
    IMS_commission: 'IMS_commission',
    agency_id: 'agency_id',
    agency_name: 'agency_name',
    pay_type: 'pay_type',
    exchange_rate: 'exchange_rate',
    first_name: 'first_name',
    korean_name: 'korean_name',
    last_name: 'last_name',
    paid_agency: 'paid_agency',
    paid_supplier_date: 'paid_supplier_date',
    paid_supplier: 'paid_supplier',
    basic_rate: 'basic_rate',
    net: 'net',
    commission: 'commission',
    currency: 'currency',
    service_total_amount: 'service_total_amount',
    service_rate: 'service_rate',
    reservation_id: 'reservation_id',
    supplier: 'supplier',
    imp_uid: 'imp_uid',
    merchant_uid: 'merchant_uid',
    etc_rate: 'etc_rate',
    total_amount: 'total_amount',
    pg_amount: 'pg_amount',
    paid_agency_date: 'paid_agency_date'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Price_codesScalarFieldEnum: {
    id: 'id',
    price_code: 'price_code',
    country_code: 'country_code',
    name: 'name',
    price_type: 'price_type',
    vendor_id: 'vendor_id',
    ITCode: 'ITCode',
    cdpNumber: 'cdpNumber',
    show: 'show',
    insurance: 'insurance',
    ko_name: 'ko_name'
  };

  export type Price_codesScalarFieldEnum = (typeof Price_codesScalarFieldEnum)[keyof typeof Price_codesScalarFieldEnum]


  export const Promotion_codeScalarFieldEnum: {
    cdp: 'cdp',
    pc: 'pc',
    vendor_id: 'vendor_id',
    country: 'country',
    name: 'name'
  };

  export type Promotion_codeScalarFieldEnum = (typeof Promotion_codeScalarFieldEnum)[keyof typeof Promotion_codeScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    supplier: 'supplier',
    agent_name: 'agent_name',
    agent: 'agent',
    date_request: 'date_request',
    res_status: 'res_status',
    invoice: 'invoice',
    res_id: 'res_id',
    korean_name: 'korean_name',
    first_name: 'first_name',
    last_name: 'last_name',
    pickup_loc: 'pickup_loc',
    return_loc: 'return_loc',
    pickup_datetime: 'pickup_datetime',
    return_datetime: 'return_datetime',
    pay_type: 'pay_type',
    currency: 'currency',
    exchange_rate: 'exchange_rate',
    user_id: 'user_id',
    car_model: 'car_model',
    extra_equipmens: 'extra_equipmens',
    insurance_info: 'insurance_info',
    office_address: 'office_address',
    office_name: 'office_name',
    office_time: 'office_time',
    phone_code: 'phone_code',
    phone_number: 'phone_number',
    services: 'services',
    size_car: 'size_car',
    type_car: 'type_car',
    date_cancel: 'date_cancel',
    email: 'email',
    flight_brand: 'flight_brand',
    flight_number: 'flight_number',
    frequent_flyer: 'frequent_flyer',
    hertz_membership: 'hertz_membership',
    office_second_address: 'office_second_address',
    office_second_name: 'office_second_name',
    office_second_time: 'office_second_time',
    dropFee: 'dropFee',
    rate_amount: 'rate_amount',
    rate_foreigner_amount: 'rate_foreigner_amount',
    tax: 'tax',
    total_amount: 'total_amount',
    total_foreigner_amount: 'total_foreigner_amount'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ServicesScalarFieldEnum: {
    id: 'id',
    description: 'description',
    ko_description: 'ko_description',
    details: 'details',
    order: 'order'
  };

  export type ServicesScalarFieldEnum = (typeof ServicesScalarFieldEnum)[keyof typeof ServicesScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    category: 'category',
    name: 'name',
    value: 'value',
    type: 'type'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const Subject_faqScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Subject_faqScalarFieldEnum = (typeof Subject_faqScalarFieldEnum)[keyof typeof Subject_faqScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TranslationScalarFieldEnum: {
    locale_id: 'locale_id',
    message: 'message',
    tag: 'tag'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    hash_pass: 'hash_pass',
    created_date: 'created_date',
    modified_date: 'modified_date',
    deleted: 'deleted',
    hash_rt: 'hash_rt',
    phone: 'phone',
    login_type: 'login_type',
    external_id: 'external_id',
    korean_name: 'korean_name',
    first_name: 'first_name',
    last_name: 'last_name',
    phone_prefix: 'phone_prefix',
    refund_bank: 'refund_bank',
    refund_account_number: 'refund_account_number',
    refund_account_holder: 'refund_account_holder',
    address: 'address',
    hertz_membership: 'hertz_membership',
    airline: 'airline',
    mileage_number: 'mileage_number',
    mailing_email: 'mailing_email',
    mailing_text_msg: 'mailing_text_msg',
    birthdate: 'birthdate'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VendorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    isActive: 'isActive'
  };

  export type VendorsScalarFieldEnum = (typeof VendorsScalarFieldEnum)[keyof typeof VendorsScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type api_keyWhereInput = {
    AND?: Enumerable<api_keyWhereInput>
    OR?: Enumerable<api_keyWhereInput>
    NOT?: Enumerable<api_keyWhereInput>
    client_id?: StringFilter | string
    key?: StringFilter | string
  }

  export type api_keyOrderByWithRelationInput = {
    client_id?: SortOrder
    key?: SortOrder
  }

  export type api_keyWhereUniqueInput = {
    client_id?: string
    key?: string
  }

  export type api_keyOrderByWithAggregationInput = {
    client_id?: SortOrder
    key?: SortOrder
    _count?: api_keyCountOrderByAggregateInput
    _max?: api_keyMaxOrderByAggregateInput
    _min?: api_keyMinOrderByAggregateInput
  }

  export type api_keyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<api_keyScalarWhereWithAggregatesInput>
    OR?: Enumerable<api_keyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<api_keyScalarWhereWithAggregatesInput>
    client_id?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
  }

  export type citiesWhereInput = {
    AND?: Enumerable<citiesWhereInput>
    OR?: Enumerable<citiesWhereInput>
    NOT?: Enumerable<citiesWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    un_locode?: StringNullableFilter | string | null
    latitude?: IntNullableFilter | number | null
    longitude?: IntNullableFilter | number | null
    alt?: IntNullableFilter | number | null
    timezone?: StringNullableFilter | string | null
    country_code?: StringNullableFilter | string | null
    countries?: XOR<CountriesRelationFilter, countriesWhereInput> | null
    cities_translation?: Cities_translationListRelationFilter
  }

  export type citiesOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    un_locode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
    timezone?: SortOrder
    country_code?: SortOrder
    countries?: countriesOrderByWithRelationInput
    cities_translation?: cities_translationOrderByRelationAggregateInput
  }

  export type citiesWhereUniqueInput = {
    code?: string
  }

  export type citiesOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    un_locode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
    timezone?: SortOrder
    country_code?: SortOrder
    _count?: citiesCountOrderByAggregateInput
    _avg?: citiesAvgOrderByAggregateInput
    _max?: citiesMaxOrderByAggregateInput
    _min?: citiesMinOrderByAggregateInput
    _sum?: citiesSumOrderByAggregateInput
  }

  export type citiesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<citiesScalarWhereWithAggregatesInput>
    OR?: Enumerable<citiesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<citiesScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    un_locode?: StringNullableWithAggregatesFilter | string | null
    latitude?: IntNullableWithAggregatesFilter | number | null
    longitude?: IntNullableWithAggregatesFilter | number | null
    alt?: IntNullableWithAggregatesFilter | number | null
    timezone?: StringNullableWithAggregatesFilter | string | null
    country_code?: StringNullableWithAggregatesFilter | string | null
  }

  export type cities_translationWhereInput = {
    AND?: Enumerable<cities_translationWhereInput>
    OR?: Enumerable<cities_translationWhereInput>
    NOT?: Enumerable<cities_translationWhereInput>
    city_code?: StringFilter | string
    locale?: StringFilter | string
    city_name?: StringFilter | string
    cities?: XOR<CitiesRelationFilter, citiesWhereInput>
  }

  export type cities_translationOrderByWithRelationInput = {
    city_code?: SortOrder
    locale?: SortOrder
    city_name?: SortOrder
    cities?: citiesOrderByWithRelationInput
  }

  export type cities_translationWhereUniqueInput = {
    city_code_locale?: cities_translationCity_codeLocaleCompoundUniqueInput
  }

  export type cities_translationOrderByWithAggregationInput = {
    city_code?: SortOrder
    locale?: SortOrder
    city_name?: SortOrder
    _count?: cities_translationCountOrderByAggregateInput
    _max?: cities_translationMaxOrderByAggregateInput
    _min?: cities_translationMinOrderByAggregateInput
  }

  export type cities_translationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cities_translationScalarWhereWithAggregatesInput>
    OR?: Enumerable<cities_translationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cities_translationScalarWhereWithAggregatesInput>
    city_code?: StringWithAggregatesFilter | string
    locale?: StringWithAggregatesFilter | string
    city_name?: StringWithAggregatesFilter | string
  }

  export type localesWhereInput = {
    AND?: Enumerable<localesWhereInput>
    OR?: Enumerable<localesWhereInput>
    NOT?: Enumerable<localesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    code?: StringFilter | string
    default?: BoolFilter | boolean
    translation?: TranslationListRelationFilter
  }

  export type localesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    default?: SortOrder
    translation?: translationOrderByRelationAggregateInput
  }

  export type localesWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type localesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    default?: SortOrder
    _count?: localesCountOrderByAggregateInput
    _avg?: localesAvgOrderByAggregateInput
    _max?: localesMaxOrderByAggregateInput
    _min?: localesMinOrderByAggregateInput
    _sum?: localesSumOrderByAggregateInput
  }

  export type localesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<localesScalarWhereWithAggregatesInput>
    OR?: Enumerable<localesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<localesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    default?: BoolWithAggregatesFilter | boolean
  }

  export type locationWhereInput = {
    AND?: Enumerable<locationWhereInput>
    OR?: Enumerable<locationWhereInput>
    NOT?: Enumerable<locationWhereInput>
    id?: StringFilter | string
    city_code?: StringNullableFilter | string | null
    vendor_id?: StringFilter | string
    oag_code?: StringNullableFilter | string | null
    country_code?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    zip_code?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    alt_phone?: StringNullableFilter | string | null
    fax?: StringNullableFilter | string | null
    telex?: StringNullableFilter | string | null
    web_url?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    latitude?: StringNullableFilter | string | null
    longitude?: StringNullableFilter | string | null
    open_1_mon?: StringNullableFilter | string | null
    close_1_mon?: StringNullableFilter | string | null
    open_2_mon?: StringNullableFilter | string | null
    close_2_mon?: StringNullableFilter | string | null
    open_3_mon?: StringNullableFilter | string | null
    close_3_mon?: StringNullableFilter | string | null
    open_1_tue?: StringNullableFilter | string | null
    close_1_tue?: StringNullableFilter | string | null
    open_2_tue?: StringNullableFilter | string | null
    close_2_tue?: StringNullableFilter | string | null
    open_3_tue?: StringNullableFilter | string | null
    close_3_tue?: StringNullableFilter | string | null
    open_1_wed?: StringNullableFilter | string | null
    close_1_wed?: StringNullableFilter | string | null
    open_2_wed?: StringNullableFilter | string | null
    close_2_wed?: StringNullableFilter | string | null
    open_3_wed?: StringNullableFilter | string | null
    close_3_wed?: StringNullableFilter | string | null
    open_1_thu?: StringNullableFilter | string | null
    close_1_thu?: StringNullableFilter | string | null
    open_2_thu?: StringNullableFilter | string | null
    close_2_thu?: StringNullableFilter | string | null
    open_3_thu?: StringNullableFilter | string | null
    close_3_thu?: StringNullableFilter | string | null
    open_1_fri?: StringNullableFilter | string | null
    close_1_fri?: StringNullableFilter | string | null
    open_2_fri?: StringNullableFilter | string | null
    close_2_fri?: StringNullableFilter | string | null
    open_3_fri?: StringNullableFilter | string | null
    close_3_fri?: StringNullableFilter | string | null
    open_1_sat?: StringNullableFilter | string | null
    close_1_sat?: StringNullableFilter | string | null
    open_2_sat?: StringNullableFilter | string | null
    close_2_sat?: StringNullableFilter | string | null
    open_3_sat?: StringNullableFilter | string | null
    close_3_sat?: StringNullableFilter | string | null
    open_1_sun?: StringNullableFilter | string | null
    close_1_sun?: StringNullableFilter | string | null
    open_2_sun?: StringNullableFilter | string | null
    close_2_sun?: StringNullableFilter | string | null
    open_3_sun?: StringNullableFilter | string | null
    close_3_sun?: StringNullableFilter | string | null
    loc_type_1?: StringNullableFilter | string | null
    loc_type_2?: StringNullableFilter | string | null
    city_name?: StringNullableFilter | string | null
    category_id?: StringNullableFilter | string | null
    categories?: XOR<CategoriesRelationFilter, categoriesWhereInput> | null
    location_type_1?: XOR<Location_type_1RelationFilter, location_type_1WhereInput> | null
    location_type_2?: XOR<Location_type_2RelationFilter, location_type_2WhereInput> | null
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
    location_description?: Location_descriptionListRelationFilter
  }

  export type locationOrderByWithRelationInput = {
    id?: SortOrder
    city_code?: SortOrder
    vendor_id?: SortOrder
    oag_code?: SortOrder
    country_code?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    phone?: SortOrder
    alt_phone?: SortOrder
    fax?: SortOrder
    telex?: SortOrder
    web_url?: SortOrder
    email?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    open_1_mon?: SortOrder
    close_1_mon?: SortOrder
    open_2_mon?: SortOrder
    close_2_mon?: SortOrder
    open_3_mon?: SortOrder
    close_3_mon?: SortOrder
    open_1_tue?: SortOrder
    close_1_tue?: SortOrder
    open_2_tue?: SortOrder
    close_2_tue?: SortOrder
    open_3_tue?: SortOrder
    close_3_tue?: SortOrder
    open_1_wed?: SortOrder
    close_1_wed?: SortOrder
    open_2_wed?: SortOrder
    close_2_wed?: SortOrder
    open_3_wed?: SortOrder
    close_3_wed?: SortOrder
    open_1_thu?: SortOrder
    close_1_thu?: SortOrder
    open_2_thu?: SortOrder
    close_2_thu?: SortOrder
    open_3_thu?: SortOrder
    close_3_thu?: SortOrder
    open_1_fri?: SortOrder
    close_1_fri?: SortOrder
    open_2_fri?: SortOrder
    close_2_fri?: SortOrder
    open_3_fri?: SortOrder
    close_3_fri?: SortOrder
    open_1_sat?: SortOrder
    close_1_sat?: SortOrder
    open_2_sat?: SortOrder
    close_2_sat?: SortOrder
    open_3_sat?: SortOrder
    close_3_sat?: SortOrder
    open_1_sun?: SortOrder
    close_1_sun?: SortOrder
    open_2_sun?: SortOrder
    close_2_sun?: SortOrder
    open_3_sun?: SortOrder
    close_3_sun?: SortOrder
    loc_type_1?: SortOrder
    loc_type_2?: SortOrder
    city_name?: SortOrder
    category_id?: SortOrder
    categories?: categoriesOrderByWithRelationInput
    location_type_1?: location_type_1OrderByWithRelationInput
    location_type_2?: location_type_2OrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
    location_description?: location_descriptionOrderByRelationAggregateInput
  }

  export type locationWhereUniqueInput = {
    id?: string
    vendor_id_oag_code?: locationVendor_idOag_codeCompoundUniqueInput
  }

  export type locationOrderByWithAggregationInput = {
    id?: SortOrder
    city_code?: SortOrder
    vendor_id?: SortOrder
    oag_code?: SortOrder
    country_code?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    phone?: SortOrder
    alt_phone?: SortOrder
    fax?: SortOrder
    telex?: SortOrder
    web_url?: SortOrder
    email?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    open_1_mon?: SortOrder
    close_1_mon?: SortOrder
    open_2_mon?: SortOrder
    close_2_mon?: SortOrder
    open_3_mon?: SortOrder
    close_3_mon?: SortOrder
    open_1_tue?: SortOrder
    close_1_tue?: SortOrder
    open_2_tue?: SortOrder
    close_2_tue?: SortOrder
    open_3_tue?: SortOrder
    close_3_tue?: SortOrder
    open_1_wed?: SortOrder
    close_1_wed?: SortOrder
    open_2_wed?: SortOrder
    close_2_wed?: SortOrder
    open_3_wed?: SortOrder
    close_3_wed?: SortOrder
    open_1_thu?: SortOrder
    close_1_thu?: SortOrder
    open_2_thu?: SortOrder
    close_2_thu?: SortOrder
    open_3_thu?: SortOrder
    close_3_thu?: SortOrder
    open_1_fri?: SortOrder
    close_1_fri?: SortOrder
    open_2_fri?: SortOrder
    close_2_fri?: SortOrder
    open_3_fri?: SortOrder
    close_3_fri?: SortOrder
    open_1_sat?: SortOrder
    close_1_sat?: SortOrder
    open_2_sat?: SortOrder
    close_2_sat?: SortOrder
    open_3_sat?: SortOrder
    close_3_sat?: SortOrder
    open_1_sun?: SortOrder
    close_1_sun?: SortOrder
    open_2_sun?: SortOrder
    close_2_sun?: SortOrder
    open_3_sun?: SortOrder
    close_3_sun?: SortOrder
    loc_type_1?: SortOrder
    loc_type_2?: SortOrder
    city_name?: SortOrder
    category_id?: SortOrder
    _count?: locationCountOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    city_code?: StringNullableWithAggregatesFilter | string | null
    vendor_id?: StringWithAggregatesFilter | string
    oag_code?: StringNullableWithAggregatesFilter | string | null
    country_code?: StringNullableWithAggregatesFilter | string | null
    state?: StringNullableWithAggregatesFilter | string | null
    zip_code?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    alt_phone?: StringNullableWithAggregatesFilter | string | null
    fax?: StringNullableWithAggregatesFilter | string | null
    telex?: StringNullableWithAggregatesFilter | string | null
    web_url?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    latitude?: StringNullableWithAggregatesFilter | string | null
    longitude?: StringNullableWithAggregatesFilter | string | null
    open_1_mon?: StringNullableWithAggregatesFilter | string | null
    close_1_mon?: StringNullableWithAggregatesFilter | string | null
    open_2_mon?: StringNullableWithAggregatesFilter | string | null
    close_2_mon?: StringNullableWithAggregatesFilter | string | null
    open_3_mon?: StringNullableWithAggregatesFilter | string | null
    close_3_mon?: StringNullableWithAggregatesFilter | string | null
    open_1_tue?: StringNullableWithAggregatesFilter | string | null
    close_1_tue?: StringNullableWithAggregatesFilter | string | null
    open_2_tue?: StringNullableWithAggregatesFilter | string | null
    close_2_tue?: StringNullableWithAggregatesFilter | string | null
    open_3_tue?: StringNullableWithAggregatesFilter | string | null
    close_3_tue?: StringNullableWithAggregatesFilter | string | null
    open_1_wed?: StringNullableWithAggregatesFilter | string | null
    close_1_wed?: StringNullableWithAggregatesFilter | string | null
    open_2_wed?: StringNullableWithAggregatesFilter | string | null
    close_2_wed?: StringNullableWithAggregatesFilter | string | null
    open_3_wed?: StringNullableWithAggregatesFilter | string | null
    close_3_wed?: StringNullableWithAggregatesFilter | string | null
    open_1_thu?: StringNullableWithAggregatesFilter | string | null
    close_1_thu?: StringNullableWithAggregatesFilter | string | null
    open_2_thu?: StringNullableWithAggregatesFilter | string | null
    close_2_thu?: StringNullableWithAggregatesFilter | string | null
    open_3_thu?: StringNullableWithAggregatesFilter | string | null
    close_3_thu?: StringNullableWithAggregatesFilter | string | null
    open_1_fri?: StringNullableWithAggregatesFilter | string | null
    close_1_fri?: StringNullableWithAggregatesFilter | string | null
    open_2_fri?: StringNullableWithAggregatesFilter | string | null
    close_2_fri?: StringNullableWithAggregatesFilter | string | null
    open_3_fri?: StringNullableWithAggregatesFilter | string | null
    close_3_fri?: StringNullableWithAggregatesFilter | string | null
    open_1_sat?: StringNullableWithAggregatesFilter | string | null
    close_1_sat?: StringNullableWithAggregatesFilter | string | null
    open_2_sat?: StringNullableWithAggregatesFilter | string | null
    close_2_sat?: StringNullableWithAggregatesFilter | string | null
    open_3_sat?: StringNullableWithAggregatesFilter | string | null
    close_3_sat?: StringNullableWithAggregatesFilter | string | null
    open_1_sun?: StringNullableWithAggregatesFilter | string | null
    close_1_sun?: StringNullableWithAggregatesFilter | string | null
    open_2_sun?: StringNullableWithAggregatesFilter | string | null
    close_2_sun?: StringNullableWithAggregatesFilter | string | null
    open_3_sun?: StringNullableWithAggregatesFilter | string | null
    close_3_sun?: StringNullableWithAggregatesFilter | string | null
    loc_type_1?: StringNullableWithAggregatesFilter | string | null
    loc_type_2?: StringNullableWithAggregatesFilter | string | null
    city_name?: StringNullableWithAggregatesFilter | string | null
    category_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type location_descriptionWhereInput = {
    AND?: Enumerable<location_descriptionWhereInput>
    OR?: Enumerable<location_descriptionWhereInput>
    NOT?: Enumerable<location_descriptionWhereInput>
    location_id?: StringFilter | string
    locale?: StringFilter | string
    description?: StringNullableFilter | string | null
    address_1?: StringNullableFilter | string | null
    address_2?: StringNullableFilter | string | null
    address_3?: StringNullableFilter | string | null
    location?: XOR<LocationRelationFilter, locationWhereInput>
  }

  export type location_descriptionOrderByWithRelationInput = {
    location_id?: SortOrder
    locale?: SortOrder
    description?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    address_3?: SortOrder
    location?: locationOrderByWithRelationInput
  }

  export type location_descriptionWhereUniqueInput = {
    location_id_locale?: location_descriptionLocation_idLocaleCompoundUniqueInput
  }

  export type location_descriptionOrderByWithAggregationInput = {
    location_id?: SortOrder
    locale?: SortOrder
    description?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    address_3?: SortOrder
    _count?: location_descriptionCountOrderByAggregateInput
    _max?: location_descriptionMaxOrderByAggregateInput
    _min?: location_descriptionMinOrderByAggregateInput
  }

  export type location_descriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<location_descriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<location_descriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<location_descriptionScalarWhereWithAggregatesInput>
    location_id?: StringWithAggregatesFilter | string
    locale?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    address_1?: StringNullableWithAggregatesFilter | string | null
    address_2?: StringNullableWithAggregatesFilter | string | null
    address_3?: StringNullableWithAggregatesFilter | string | null
  }

  export type translationWhereInput = {
    AND?: Enumerable<translationWhereInput>
    OR?: Enumerable<translationWhereInput>
    NOT?: Enumerable<translationWhereInput>
    locale_id?: IntFilter | number
    message?: StringFilter | string
    tag?: StringFilter | string
    locales?: XOR<LocalesRelationFilter, localesWhereInput>
  }

  export type translationOrderByWithRelationInput = {
    locale_id?: SortOrder
    message?: SortOrder
    tag?: SortOrder
    locales?: localesOrderByWithRelationInput
  }

  export type translationWhereUniqueInput = {
    locale_id_tag?: translationLocale_idTagCompoundUniqueInput
  }

  export type translationOrderByWithAggregationInput = {
    locale_id?: SortOrder
    message?: SortOrder
    tag?: SortOrder
    _count?: translationCountOrderByAggregateInput
    _avg?: translationAvgOrderByAggregateInput
    _max?: translationMaxOrderByAggregateInput
    _min?: translationMinOrderByAggregateInput
    _sum?: translationSumOrderByAggregateInput
  }

  export type translationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<translationScalarWhereWithAggregatesInput>
    OR?: Enumerable<translationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<translationScalarWhereWithAggregatesInput>
    locale_id?: IntWithAggregatesFilter | number
    message?: StringWithAggregatesFilter | string
    tag?: StringWithAggregatesFilter | string
  }

  export type countriesWhereInput = {
    AND?: Enumerable<countriesWhereInput>
    OR?: Enumerable<countriesWhereInput>
    NOT?: Enumerable<countriesWhereInput>
    code?: StringFilter | string
    code_3?: StringFilter | string
    name?: StringFilter | string
    continent?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    airports?: AirportsListRelationFilter
    cities?: CitiesListRelationFilter
    countries_translation?: Countries_translationListRelationFilter
  }

  export type countriesOrderByWithRelationInput = {
    code?: SortOrder
    code_3?: SortOrder
    name?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    airports?: airportsOrderByRelationAggregateInput
    cities?: citiesOrderByRelationAggregateInput
    countries_translation?: countries_translationOrderByRelationAggregateInput
  }

  export type countriesWhereUniqueInput = {
    code?: string
  }

  export type countriesOrderByWithAggregationInput = {
    code?: SortOrder
    code_3?: SortOrder
    name?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
    _count?: countriesCountOrderByAggregateInput
    _max?: countriesMaxOrderByAggregateInput
    _min?: countriesMinOrderByAggregateInput
  }

  export type countriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<countriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<countriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<countriesScalarWhereWithAggregatesInput>
    code?: StringWithAggregatesFilter | string
    code_3?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    continent?: StringNullableWithAggregatesFilter | string | null
    currency?: StringNullableWithAggregatesFilter | string | null
  }

  export type countries_translationWhereInput = {
    AND?: Enumerable<countries_translationWhereInput>
    OR?: Enumerable<countries_translationWhereInput>
    NOT?: Enumerable<countries_translationWhereInput>
    country_code?: StringFilter | string
    locale?: StringFilter | string
    country_name?: StringFilter | string
    countries?: XOR<CountriesRelationFilter, countriesWhereInput>
  }

  export type countries_translationOrderByWithRelationInput = {
    country_code?: SortOrder
    locale?: SortOrder
    country_name?: SortOrder
    countries?: countriesOrderByWithRelationInput
  }

  export type countries_translationWhereUniqueInput = {
    country_code_locale?: countries_translationCountry_codeLocaleCompoundUniqueInput
  }

  export type countries_translationOrderByWithAggregationInput = {
    country_code?: SortOrder
    locale?: SortOrder
    country_name?: SortOrder
    _count?: countries_translationCountOrderByAggregateInput
    _max?: countries_translationMaxOrderByAggregateInput
    _min?: countries_translationMinOrderByAggregateInput
  }

  export type countries_translationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<countries_translationScalarWhereWithAggregatesInput>
    OR?: Enumerable<countries_translationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<countries_translationScalarWhereWithAggregatesInput>
    country_code?: StringWithAggregatesFilter | string
    locale?: StringWithAggregatesFilter | string
    country_name?: StringWithAggregatesFilter | string
  }

  export type location_type_1WhereInput = {
    AND?: Enumerable<location_type_1WhereInput>
    OR?: Enumerable<location_type_1WhereInput>
    NOT?: Enumerable<location_type_1WhereInput>
    type?: StringFilter | string
    description?: StringFilter | string
    location?: LocationListRelationFilter
  }

  export type location_type_1OrderByWithRelationInput = {
    type?: SortOrder
    description?: SortOrder
    location?: locationOrderByRelationAggregateInput
  }

  export type location_type_1WhereUniqueInput = {
    type?: string
  }

  export type location_type_1OrderByWithAggregationInput = {
    type?: SortOrder
    description?: SortOrder
    _count?: location_type_1CountOrderByAggregateInput
    _max?: location_type_1MaxOrderByAggregateInput
    _min?: location_type_1MinOrderByAggregateInput
  }

  export type location_type_1ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<location_type_1ScalarWhereWithAggregatesInput>
    OR?: Enumerable<location_type_1ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<location_type_1ScalarWhereWithAggregatesInput>
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type location_type_2WhereInput = {
    AND?: Enumerable<location_type_2WhereInput>
    OR?: Enumerable<location_type_2WhereInput>
    NOT?: Enumerable<location_type_2WhereInput>
    type?: StringFilter | string
    description?: StringFilter | string
    location?: LocationListRelationFilter
  }

  export type location_type_2OrderByWithRelationInput = {
    type?: SortOrder
    description?: SortOrder
    location?: locationOrderByRelationAggregateInput
  }

  export type location_type_2WhereUniqueInput = {
    type?: string
  }

  export type location_type_2OrderByWithAggregationInput = {
    type?: SortOrder
    description?: SortOrder
    _count?: location_type_2CountOrderByAggregateInput
    _max?: location_type_2MaxOrderByAggregateInput
    _min?: location_type_2MinOrderByAggregateInput
  }

  export type location_type_2ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<location_type_2ScalarWhereWithAggregatesInput>
    OR?: Enumerable<location_type_2ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<location_type_2ScalarWhereWithAggregatesInput>
    type?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
  }

  export type vendorsWhereInput = {
    AND?: Enumerable<vendorsWhereInput>
    OR?: Enumerable<vendorsWhereInput>
    NOT?: Enumerable<vendorsWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    logo?: StringNullableFilter | string | null
    isActive?: BoolNullableFilter | boolean | null
    commission_setting?: Commission_settingListRelationFilter
    location?: LocationListRelationFilter
    reservation?: ReservationListRelationFilter
  }

  export type vendorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    commission_setting?: commission_settingOrderByRelationAggregateInput
    location?: locationOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
  }

  export type vendorsWhereUniqueInput = {
    id?: string
  }

  export type vendorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    _count?: vendorsCountOrderByAggregateInput
    _max?: vendorsMaxOrderByAggregateInput
    _min?: vendorsMinOrderByAggregateInput
  }

  export type vendorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    logo?: StringNullableWithAggregatesFilter | string | null
    isActive?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type airportsWhereInput = {
    AND?: Enumerable<airportsWhereInput>
    OR?: Enumerable<airportsWhereInput>
    NOT?: Enumerable<airportsWhereInput>
    iata_code?: StringFilter | string
    country_code?: StringNullableFilter | string | null
    icao_code?: StringFilter | string
    name?: StringFilter | string
    latitude?: IntFilter | number
    longitude?: IntFilter | number
    id?: IntFilter | number
    countries?: XOR<CountriesRelationFilter, countriesWhereInput> | null
  }

  export type airportsOrderByWithRelationInput = {
    iata_code?: SortOrder
    country_code?: SortOrder
    icao_code?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
    countries?: countriesOrderByWithRelationInput
  }

  export type airportsWhereUniqueInput = {
    id?: number
  }

  export type airportsOrderByWithAggregationInput = {
    iata_code?: SortOrder
    country_code?: SortOrder
    icao_code?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
    _count?: airportsCountOrderByAggregateInput
    _avg?: airportsAvgOrderByAggregateInput
    _max?: airportsMaxOrderByAggregateInput
    _min?: airportsMinOrderByAggregateInput
    _sum?: airportsSumOrderByAggregateInput
  }

  export type airportsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<airportsScalarWhereWithAggregatesInput>
    OR?: Enumerable<airportsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<airportsScalarWhereWithAggregatesInput>
    iata_code?: StringWithAggregatesFilter | string
    country_code?: StringNullableWithAggregatesFilter | string | null
    icao_code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    latitude?: IntWithAggregatesFilter | number
    longitude?: IntWithAggregatesFilter | number
    id?: IntWithAggregatesFilter | number
  }

  export type categoriesWhereInput = {
    AND?: Enumerable<categoriesWhereInput>
    OR?: Enumerable<categoriesWhereInput>
    NOT?: Enumerable<categoriesWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    icon?: StringNullableFilter | string | null
    location?: LocationListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    location?: locationOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = {
    id?: string
  }

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoriesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    icon?: StringNullableWithAggregatesFilter | string | null
  }

  export type paymentWhereInput = {
    AND?: Enumerable<paymentWhereInput>
    OR?: Enumerable<paymentWhereInput>
    NOT?: Enumerable<paymentWhereInput>
    order_id?: StringFilter | string
    user_id?: IntNullableFilter | number | null
    IMS_commission?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    agency_id?: StringNullableFilter | string | null
    agency_name?: StringNullableFilter | string | null
    pay_type?: StringNullableFilter | string | null
    exchange_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    first_name?: StringNullableFilter | string | null
    korean_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    paid_agency?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: DateTimeNullableFilter | Date | string | null
    paid_supplier?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    basic_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    net?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter | string | null
    service_total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    service_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    reservation_id?: StringNullableFilter | string | null
    supplier?: StringNullableFilter | string | null
    imp_uid?: StringNullableFilter | string | null
    merchant_uid?: StringNullableFilter | string | null
    etc_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pg_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: DateTimeNullableFilter | Date | string | null
    reservation?: XOR<ReservationRelationFilter, reservationWhereInput> | null
    users?: XOR<UsersRelationFilter, usersWhereInput> | null
  }

  export type paymentOrderByWithRelationInput = {
    order_id?: SortOrder
    user_id?: SortOrder
    IMS_commission?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    pay_type?: SortOrder
    exchange_rate?: SortOrder
    first_name?: SortOrder
    korean_name?: SortOrder
    last_name?: SortOrder
    paid_agency?: SortOrder
    paid_supplier_date?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    reservation_id?: SortOrder
    supplier?: SortOrder
    imp_uid?: SortOrder
    merchant_uid?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
    paid_agency_date?: SortOrder
    reservation?: reservationOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = {
    order_id?: string
  }

  export type paymentOrderByWithAggregationInput = {
    order_id?: SortOrder
    user_id?: SortOrder
    IMS_commission?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    pay_type?: SortOrder
    exchange_rate?: SortOrder
    first_name?: SortOrder
    korean_name?: SortOrder
    last_name?: SortOrder
    paid_agency?: SortOrder
    paid_supplier_date?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    reservation_id?: SortOrder
    supplier?: SortOrder
    imp_uid?: SortOrder
    merchant_uid?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
    paid_agency_date?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paymentScalarWhereWithAggregatesInput>
    order_id?: StringWithAggregatesFilter | string
    user_id?: IntNullableWithAggregatesFilter | number | null
    IMS_commission?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    agency_id?: StringNullableWithAggregatesFilter | string | null
    agency_name?: StringNullableWithAggregatesFilter | string | null
    pay_type?: StringNullableWithAggregatesFilter | string | null
    exchange_rate?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    korean_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    paid_agency?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    paid_supplier?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    basic_rate?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    net?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter | string | null
    service_total_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    service_rate?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    reservation_id?: StringNullableWithAggregatesFilter | string | null
    supplier?: StringNullableWithAggregatesFilter | string | null
    imp_uid?: StringNullableWithAggregatesFilter | string | null
    merchant_uid?: StringNullableWithAggregatesFilter | string | null
    etc_rate?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    pg_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type exchange_ratesWhereInput = {
    AND?: Enumerable<exchange_ratesWhereInput>
    OR?: Enumerable<exchange_ratesWhereInput>
    NOT?: Enumerable<exchange_ratesWhereInput>
    id?: IntFilter | number
    from_code?: StringFilter | string
    to_code?: StringFilter | string
    rate?: FloatFilter | number
    exchange_rate_history?: Exchange_rate_historyListRelationFilter
  }

  export type exchange_ratesOrderByWithRelationInput = {
    id?: SortOrder
    from_code?: SortOrder
    to_code?: SortOrder
    rate?: SortOrder
    exchange_rate_history?: exchange_rate_historyOrderByRelationAggregateInput
  }

  export type exchange_ratesWhereUniqueInput = {
    id?: number
    from_code_to_code?: exchange_ratesFrom_codeTo_codeCompoundUniqueInput
  }

  export type exchange_ratesOrderByWithAggregationInput = {
    id?: SortOrder
    from_code?: SortOrder
    to_code?: SortOrder
    rate?: SortOrder
    _count?: exchange_ratesCountOrderByAggregateInput
    _avg?: exchange_ratesAvgOrderByAggregateInput
    _max?: exchange_ratesMaxOrderByAggregateInput
    _min?: exchange_ratesMinOrderByAggregateInput
    _sum?: exchange_ratesSumOrderByAggregateInput
  }

  export type exchange_ratesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<exchange_ratesScalarWhereWithAggregatesInput>
    OR?: Enumerable<exchange_ratesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<exchange_ratesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    from_code?: StringWithAggregatesFilter | string
    to_code?: StringWithAggregatesFilter | string
    rate?: FloatWithAggregatesFilter | number
  }

  export type admin_permissionsWhereInput = {
    AND?: Enumerable<admin_permissionsWhereInput>
    OR?: Enumerable<admin_permissionsWhereInput>
    NOT?: Enumerable<admin_permissionsWhereInput>
    id?: IntFilter | number
    action?: StringFilter | string
    description?: StringNullableFilter | string | null
    admin_roles_permissions?: Admin_roles_permissionsListRelationFilter
  }

  export type admin_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    admin_roles_permissions?: admin_roles_permissionsOrderByRelationAggregateInput
  }

  export type admin_permissionsWhereUniqueInput = {
    id?: number
    action?: string
  }

  export type admin_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    _count?: admin_permissionsCountOrderByAggregateInput
    _avg?: admin_permissionsAvgOrderByAggregateInput
    _max?: admin_permissionsMaxOrderByAggregateInput
    _min?: admin_permissionsMinOrderByAggregateInput
    _sum?: admin_permissionsSumOrderByAggregateInput
  }

  export type admin_permissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admin_permissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<admin_permissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admin_permissionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    action?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type admin_rolesWhereInput = {
    AND?: Enumerable<admin_rolesWhereInput>
    OR?: Enumerable<admin_rolesWhereInput>
    NOT?: Enumerable<admin_rolesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    modified_date?: DateTimeNullableFilter | Date | string | null
    created_by?: IntNullableFilter | number | null
    modified_by?: IntNullableFilter | number | null
    deleted?: IntNullableFilter | number | null
    admin_users_admin_roles_created_byToadmin_users?: XOR<Admin_usersRelationFilter, admin_usersWhereInput> | null
    admin_users_admin_roles_modified_byToadmin_users?: XOR<Admin_usersRelationFilter, admin_usersWhereInput> | null
    admin_roles_permissions?: Admin_roles_permissionsListRelationFilter
    admin_users_roles?: Admin_users_rolesListRelationFilter
  }

  export type admin_rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    admin_users_admin_roles_created_byToadmin_users?: admin_usersOrderByWithRelationInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersOrderByWithRelationInput
    admin_roles_permissions?: admin_roles_permissionsOrderByRelationAggregateInput
    admin_users_roles?: admin_users_rolesOrderByRelationAggregateInput
  }

  export type admin_rolesWhereUniqueInput = {
    id?: number
  }

  export type admin_rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
    _count?: admin_rolesCountOrderByAggregateInput
    _avg?: admin_rolesAvgOrderByAggregateInput
    _max?: admin_rolesMaxOrderByAggregateInput
    _min?: admin_rolesMinOrderByAggregateInput
    _sum?: admin_rolesSumOrderByAggregateInput
  }

  export type admin_rolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admin_rolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<admin_rolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admin_rolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    created_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modified_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: IntNullableWithAggregatesFilter | number | null
    modified_by?: IntNullableWithAggregatesFilter | number | null
    deleted?: IntNullableWithAggregatesFilter | number | null
  }

  export type admin_roles_permissionsWhereInput = {
    AND?: Enumerable<admin_roles_permissionsWhereInput>
    OR?: Enumerable<admin_roles_permissionsWhereInput>
    NOT?: Enumerable<admin_roles_permissionsWhereInput>
    permission_id?: IntFilter | number
    role_id?: IntFilter | number
    admin_permissions?: XOR<Admin_permissionsRelationFilter, admin_permissionsWhereInput>
    admin_roles?: XOR<Admin_rolesRelationFilter, admin_rolesWhereInput>
  }

  export type admin_roles_permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    admin_permissions?: admin_permissionsOrderByWithRelationInput
    admin_roles?: admin_rolesOrderByWithRelationInput
  }

  export type admin_roles_permissionsWhereUniqueInput = {
    permission_id_role_id?: admin_roles_permissionsPermission_idRole_idCompoundUniqueInput
  }

  export type admin_roles_permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    _count?: admin_roles_permissionsCountOrderByAggregateInput
    _avg?: admin_roles_permissionsAvgOrderByAggregateInput
    _max?: admin_roles_permissionsMaxOrderByAggregateInput
    _min?: admin_roles_permissionsMinOrderByAggregateInput
    _sum?: admin_roles_permissionsSumOrderByAggregateInput
  }

  export type admin_roles_permissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admin_roles_permissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<admin_roles_permissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admin_roles_permissionsScalarWhereWithAggregatesInput>
    permission_id?: IntWithAggregatesFilter | number
    role_id?: IntWithAggregatesFilter | number
  }

  export type admin_usersWhereInput = {
    AND?: Enumerable<admin_usersWhereInput>
    OR?: Enumerable<admin_usersWhereInput>
    NOT?: Enumerable<admin_usersWhereInput>
    id?: IntFilter | number
    username?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    hash_pass?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringFilter | string
    phone_mobile?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    modified_date?: DateTimeNullableFilter | Date | string | null
    created_by?: IntNullableFilter | number | null
    deleted?: IntNullableFilter | number | null
    hash_rt?: StringNullableFilter | string | null
    modified_by?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    agency_id?: StringNullableFilter | string | null
    agencies?: XOR<AgenciesRelationFilter, agenciesWhereInput> | null
    admin_users_admin_usersToadmin_users_created_by?: XOR<Admin_usersRelationFilter, admin_usersWhereInput> | null
    admin_users_admin_usersToadmin_users_modified_by?: XOR<Admin_usersRelationFilter, admin_usersWhereInput> | null
    admin_roles_admin_roles_created_byToadmin_users?: Admin_rolesListRelationFilter
    admin_roles_admin_roles_modified_byToadmin_users?: Admin_rolesListRelationFilter
    other_admin_users_admin_usersToadmin_users_created_by?: Admin_usersListRelationFilter
    other_admin_users_admin_usersToadmin_users_modified_by?: Admin_usersListRelationFilter
    admin_users_roles?: Admin_users_rolesListRelationFilter
  }

  export type admin_usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_mobile?: SortOrder
    address?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    modified_by?: SortOrder
    status?: SortOrder
    agency_id?: SortOrder
    agencies?: agenciesOrderByWithRelationInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersOrderByWithRelationInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersOrderByWithRelationInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesOrderByRelationAggregateInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesOrderByRelationAggregateInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersOrderByRelationAggregateInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersOrderByRelationAggregateInput
    admin_users_roles?: admin_users_rolesOrderByRelationAggregateInput
  }

  export type admin_usersWhereUniqueInput = {
    id?: number
    username?: string
    email?: string
  }

  export type admin_usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_mobile?: SortOrder
    address?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    modified_by?: SortOrder
    status?: SortOrder
    agency_id?: SortOrder
    _count?: admin_usersCountOrderByAggregateInput
    _avg?: admin_usersAvgOrderByAggregateInput
    _max?: admin_usersMaxOrderByAggregateInput
    _min?: admin_usersMinOrderByAggregateInput
    _sum?: admin_usersSumOrderByAggregateInput
  }

  export type admin_usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admin_usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<admin_usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admin_usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    hash_pass?: StringNullableWithAggregatesFilter | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringWithAggregatesFilter | string
    phone_mobile?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    created_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modified_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_by?: IntNullableWithAggregatesFilter | number | null
    deleted?: IntNullableWithAggregatesFilter | number | null
    hash_rt?: StringNullableWithAggregatesFilter | string | null
    modified_by?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
    agency_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type admin_users_rolesWhereInput = {
    AND?: Enumerable<admin_users_rolesWhereInput>
    OR?: Enumerable<admin_users_rolesWhereInput>
    NOT?: Enumerable<admin_users_rolesWhereInput>
    user_id?: IntFilter | number
    role_id?: IntFilter | number
    admin_roles?: XOR<Admin_rolesRelationFilter, admin_rolesWhereInput>
    admin_users?: XOR<Admin_usersRelationFilter, admin_usersWhereInput>
  }

  export type admin_users_rolesOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    admin_roles?: admin_rolesOrderByWithRelationInput
    admin_users?: admin_usersOrderByWithRelationInput
  }

  export type admin_users_rolesWhereUniqueInput = {
    user_id_role_id?: admin_users_rolesUser_idRole_idCompoundUniqueInput
  }

  export type admin_users_rolesOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    _count?: admin_users_rolesCountOrderByAggregateInput
    _avg?: admin_users_rolesAvgOrderByAggregateInput
    _max?: admin_users_rolesMaxOrderByAggregateInput
    _min?: admin_users_rolesMinOrderByAggregateInput
    _sum?: admin_users_rolesSumOrderByAggregateInput
  }

  export type admin_users_rolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<admin_users_rolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<admin_users_rolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<admin_users_rolesScalarWhereWithAggregatesInput>
    user_id?: IntWithAggregatesFilter | number
    role_id?: IntWithAggregatesFilter | number
  }

  export type filesWhereInput = {
    AND?: Enumerable<filesWhereInput>
    OR?: Enumerable<filesWhereInput>
    NOT?: Enumerable<filesWhereInput>
    id?: IntFilter | number
    file_key?: StringNullableFilter | string | null
    file_url?: StringNullableFilter | string | null
  }

  export type filesOrderByWithRelationInput = {
    id?: SortOrder
    file_key?: SortOrder
    file_url?: SortOrder
  }

  export type filesWhereUniqueInput = {
    id?: number
  }

  export type filesOrderByWithAggregationInput = {
    id?: SortOrder
    file_key?: SortOrder
    file_url?: SortOrder
    _count?: filesCountOrderByAggregateInput
    _avg?: filesAvgOrderByAggregateInput
    _max?: filesMaxOrderByAggregateInput
    _min?: filesMinOrderByAggregateInput
    _sum?: filesSumOrderByAggregateInput
  }

  export type filesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<filesScalarWhereWithAggregatesInput>
    OR?: Enumerable<filesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<filesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    file_key?: StringNullableWithAggregatesFilter | string | null
    file_url?: StringNullableWithAggregatesFilter | string | null
  }

  export type settingsWhereInput = {
    AND?: Enumerable<settingsWhereInput>
    OR?: Enumerable<settingsWhereInput>
    NOT?: Enumerable<settingsWhereInput>
    category?: StringFilter | string
    name?: StringFilter | string
    value?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
  }

  export type settingsOrderByWithRelationInput = {
    category?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type settingsWhereUniqueInput = {
    category_name?: settingsCategoryNameCompoundUniqueInput
  }

  export type settingsOrderByWithAggregationInput = {
    category?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<settingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<settingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<settingsScalarWhereWithAggregatesInput>
    category?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    value?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    hash_pass?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    modified_date?: DateTimeNullableFilter | Date | string | null
    deleted?: IntNullableFilter | number | null
    hash_rt?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    login_type?: StringNullableFilter | string | null
    external_id?: StringNullableFilter | string | null
    korean_name?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    phone_prefix?: StringNullableFilter | string | null
    refund_bank?: StringNullableFilter | string | null
    refund_account_number?: StringNullableFilter | string | null
    refund_account_holder?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    hertz_membership?: StringNullableFilter | string | null
    airline?: StringNullableFilter | string | null
    mileage_number?: StringNullableFilter | string | null
    mailing_email?: IntNullableFilter | number | null
    mailing_text_msg?: IntNullableFilter | number | null
    birthdate?: StringNullableFilter | string | null
    payment?: PaymentListRelationFilter
    reservation?: ReservationListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    phone?: SortOrder
    login_type?: SortOrder
    external_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_prefix?: SortOrder
    refund_bank?: SortOrder
    refund_account_number?: SortOrder
    refund_account_holder?: SortOrder
    address?: SortOrder
    hertz_membership?: SortOrder
    airline?: SortOrder
    mileage_number?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
    birthdate?: SortOrder
    payment?: paymentOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: number
    email?: string
    phone_phone_prefix?: usersPhonePhone_prefixCompoundUniqueInput
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    phone?: SortOrder
    login_type?: SortOrder
    external_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_prefix?: SortOrder
    refund_bank?: SortOrder
    refund_account_number?: SortOrder
    refund_account_holder?: SortOrder
    address?: SortOrder
    hertz_membership?: SortOrder
    airline?: SortOrder
    mileage_number?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
    birthdate?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    hash_pass?: StringNullableWithAggregatesFilter | string | null
    created_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modified_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deleted?: IntNullableWithAggregatesFilter | number | null
    hash_rt?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    login_type?: StringNullableWithAggregatesFilter | string | null
    external_id?: StringNullableWithAggregatesFilter | string | null
    korean_name?: StringNullableWithAggregatesFilter | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    phone_prefix?: StringNullableWithAggregatesFilter | string | null
    refund_bank?: StringNullableWithAggregatesFilter | string | null
    refund_account_number?: StringNullableWithAggregatesFilter | string | null
    refund_account_holder?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    hertz_membership?: StringNullableWithAggregatesFilter | string | null
    airline?: StringNullableWithAggregatesFilter | string | null
    mileage_number?: StringNullableWithAggregatesFilter | string | null
    mailing_email?: IntNullableWithAggregatesFilter | number | null
    mailing_text_msg?: IntNullableWithAggregatesFilter | number | null
    birthdate?: StringNullableWithAggregatesFilter | string | null
  }

  export type packagesWhereInput = {
    AND?: Enumerable<packagesWhereInput>
    OR?: Enumerable<packagesWhereInput>
    NOT?: Enumerable<packagesWhereInput>
    price_id?: StringFilter | string
    service_id?: StringFilter | string
    price_codes?: XOR<Price_codesRelationFilter, price_codesWhereInput>
    services?: XOR<ServicesRelationFilter, servicesWhereInput>
  }

  export type packagesOrderByWithRelationInput = {
    price_id?: SortOrder
    service_id?: SortOrder
    price_codes?: price_codesOrderByWithRelationInput
    services?: servicesOrderByWithRelationInput
  }

  export type packagesWhereUniqueInput = {
    price_id_service_id?: packagesPrice_idService_idCompoundUniqueInput
  }

  export type packagesOrderByWithAggregationInput = {
    price_id?: SortOrder
    service_id?: SortOrder
    _count?: packagesCountOrderByAggregateInput
    _max?: packagesMaxOrderByAggregateInput
    _min?: packagesMinOrderByAggregateInput
  }

  export type packagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<packagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<packagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<packagesScalarWhereWithAggregatesInput>
    price_id?: StringWithAggregatesFilter | string
    service_id?: StringWithAggregatesFilter | string
  }

  export type price_codesWhereInput = {
    AND?: Enumerable<price_codesWhereInput>
    OR?: Enumerable<price_codesWhereInput>
    NOT?: Enumerable<price_codesWhereInput>
    id?: StringFilter | string
    price_code?: StringFilter | string
    country_code?: StringFilter | string
    name?: StringNullableFilter | string | null
    price_type?: StringNullableFilter | string | null
    vendor_id?: StringNullableFilter | string | null
    ITCode?: StringNullableFilter | string | null
    cdpNumber?: StringNullableFilter | string | null
    show?: BoolNullableFilter | boolean | null
    insurance?: BoolNullableFilter | boolean | null
    ko_name?: StringNullableFilter | string | null
    packages?: PackagesListRelationFilter
  }

  export type price_codesOrderByWithRelationInput = {
    id?: SortOrder
    price_code?: SortOrder
    country_code?: SortOrder
    name?: SortOrder
    price_type?: SortOrder
    vendor_id?: SortOrder
    ITCode?: SortOrder
    cdpNumber?: SortOrder
    show?: SortOrder
    insurance?: SortOrder
    ko_name?: SortOrder
    packages?: packagesOrderByRelationAggregateInput
  }

  export type price_codesWhereUniqueInput = {
    id?: string
    price_code_country_code?: price_codesPrice_codeCountry_codeCompoundUniqueInput
  }

  export type price_codesOrderByWithAggregationInput = {
    id?: SortOrder
    price_code?: SortOrder
    country_code?: SortOrder
    name?: SortOrder
    price_type?: SortOrder
    vendor_id?: SortOrder
    ITCode?: SortOrder
    cdpNumber?: SortOrder
    show?: SortOrder
    insurance?: SortOrder
    ko_name?: SortOrder
    _count?: price_codesCountOrderByAggregateInput
    _max?: price_codesMaxOrderByAggregateInput
    _min?: price_codesMinOrderByAggregateInput
  }

  export type price_codesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<price_codesScalarWhereWithAggregatesInput>
    OR?: Enumerable<price_codesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<price_codesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    price_code?: StringWithAggregatesFilter | string
    country_code?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    price_type?: StringNullableWithAggregatesFilter | string | null
    vendor_id?: StringNullableWithAggregatesFilter | string | null
    ITCode?: StringNullableWithAggregatesFilter | string | null
    cdpNumber?: StringNullableWithAggregatesFilter | string | null
    show?: BoolNullableWithAggregatesFilter | boolean | null
    insurance?: BoolNullableWithAggregatesFilter | boolean | null
    ko_name?: StringNullableWithAggregatesFilter | string | null
  }

  export type reservationWhereInput = {
    AND?: Enumerable<reservationWhereInput>
    OR?: Enumerable<reservationWhereInput>
    NOT?: Enumerable<reservationWhereInput>
    supplier?: StringNullableFilter | string | null
    agent_name?: StringNullableFilter | string | null
    agent?: StringNullableFilter | string | null
    date_request?: DateTimeNullableFilter | Date | string | null
    res_status?: StringNullableFilter | string | null
    invoice?: StringNullableFilter | string | null
    res_id?: StringFilter | string
    korean_name?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    pickup_loc?: StringNullableFilter | string | null
    return_loc?: StringNullableFilter | string | null
    pickup_datetime?: StringNullableFilter | string | null
    return_datetime?: StringNullableFilter | string | null
    pay_type?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    exchange_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    user_id?: IntNullableFilter | number | null
    car_model?: StringNullableFilter | string | null
    extra_equipmens?: StringNullableFilter | string | null
    insurance_info?: StringNullableFilter | string | null
    office_address?: StringNullableFilter | string | null
    office_name?: StringNullableFilter | string | null
    office_time?: StringNullableFilter | string | null
    phone_code?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    services?: StringNullableFilter | string | null
    size_car?: StringNullableFilter | string | null
    type_car?: StringNullableFilter | string | null
    date_cancel?: DateTimeNullableFilter | Date | string | null
    email?: StringNullableFilter | string | null
    flight_brand?: StringNullableFilter | string | null
    flight_number?: StringNullableFilter | string | null
    frequent_flyer?: StringNullableFilter | string | null
    hertz_membership?: StringNullableFilter | string | null
    office_second_address?: StringNullableFilter | string | null
    office_second_name?: StringNullableFilter | string | null
    office_second_time?: StringNullableFilter | string | null
    dropFee?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rate_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    tax?: StringNullableFilter | string | null
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    agencies?: XOR<AgenciesRelationFilter, agenciesWhereInput> | null
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput> | null
    users?: XOR<UsersRelationFilter, usersWhereInput> | null
    payment?: PaymentListRelationFilter
  }

  export type reservationOrderByWithRelationInput = {
    supplier?: SortOrder
    agent_name?: SortOrder
    agent?: SortOrder
    date_request?: SortOrder
    res_status?: SortOrder
    invoice?: SortOrder
    res_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    pickup_loc?: SortOrder
    return_loc?: SortOrder
    pickup_datetime?: SortOrder
    return_datetime?: SortOrder
    pay_type?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    user_id?: SortOrder
    car_model?: SortOrder
    extra_equipmens?: SortOrder
    insurance_info?: SortOrder
    office_address?: SortOrder
    office_name?: SortOrder
    office_time?: SortOrder
    phone_code?: SortOrder
    phone_number?: SortOrder
    services?: SortOrder
    size_car?: SortOrder
    type_car?: SortOrder
    date_cancel?: SortOrder
    email?: SortOrder
    flight_brand?: SortOrder
    flight_number?: SortOrder
    frequent_flyer?: SortOrder
    hertz_membership?: SortOrder
    office_second_address?: SortOrder
    office_second_name?: SortOrder
    office_second_time?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    tax?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
    agencies?: agenciesOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    payment?: paymentOrderByRelationAggregateInput
  }

  export type reservationWhereUniqueInput = {
    res_id?: string
  }

  export type reservationOrderByWithAggregationInput = {
    supplier?: SortOrder
    agent_name?: SortOrder
    agent?: SortOrder
    date_request?: SortOrder
    res_status?: SortOrder
    invoice?: SortOrder
    res_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    pickup_loc?: SortOrder
    return_loc?: SortOrder
    pickup_datetime?: SortOrder
    return_datetime?: SortOrder
    pay_type?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    user_id?: SortOrder
    car_model?: SortOrder
    extra_equipmens?: SortOrder
    insurance_info?: SortOrder
    office_address?: SortOrder
    office_name?: SortOrder
    office_time?: SortOrder
    phone_code?: SortOrder
    phone_number?: SortOrder
    services?: SortOrder
    size_car?: SortOrder
    type_car?: SortOrder
    date_cancel?: SortOrder
    email?: SortOrder
    flight_brand?: SortOrder
    flight_number?: SortOrder
    frequent_flyer?: SortOrder
    hertz_membership?: SortOrder
    office_second_address?: SortOrder
    office_second_name?: SortOrder
    office_second_time?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    tax?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
    _count?: reservationCountOrderByAggregateInput
    _avg?: reservationAvgOrderByAggregateInput
    _max?: reservationMaxOrderByAggregateInput
    _min?: reservationMinOrderByAggregateInput
    _sum?: reservationSumOrderByAggregateInput
  }

  export type reservationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reservationScalarWhereWithAggregatesInput>
    OR?: Enumerable<reservationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reservationScalarWhereWithAggregatesInput>
    supplier?: StringNullableWithAggregatesFilter | string | null
    agent_name?: StringNullableWithAggregatesFilter | string | null
    agent?: StringNullableWithAggregatesFilter | string | null
    date_request?: DateTimeNullableWithAggregatesFilter | Date | string | null
    res_status?: StringNullableWithAggregatesFilter | string | null
    invoice?: StringNullableWithAggregatesFilter | string | null
    res_id?: StringWithAggregatesFilter | string
    korean_name?: StringNullableWithAggregatesFilter | string | null
    first_name?: StringNullableWithAggregatesFilter | string | null
    last_name?: StringNullableWithAggregatesFilter | string | null
    pickup_loc?: StringNullableWithAggregatesFilter | string | null
    return_loc?: StringNullableWithAggregatesFilter | string | null
    pickup_datetime?: StringNullableWithAggregatesFilter | string | null
    return_datetime?: StringNullableWithAggregatesFilter | string | null
    pay_type?: StringNullableWithAggregatesFilter | string | null
    currency?: StringNullableWithAggregatesFilter | string | null
    exchange_rate?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    user_id?: IntNullableWithAggregatesFilter | number | null
    car_model?: StringNullableWithAggregatesFilter | string | null
    extra_equipmens?: StringNullableWithAggregatesFilter | string | null
    insurance_info?: StringNullableWithAggregatesFilter | string | null
    office_address?: StringNullableWithAggregatesFilter | string | null
    office_name?: StringNullableWithAggregatesFilter | string | null
    office_time?: StringNullableWithAggregatesFilter | string | null
    phone_code?: StringNullableWithAggregatesFilter | string | null
    phone_number?: StringNullableWithAggregatesFilter | string | null
    services?: StringNullableWithAggregatesFilter | string | null
    size_car?: StringNullableWithAggregatesFilter | string | null
    type_car?: StringNullableWithAggregatesFilter | string | null
    date_cancel?: DateTimeNullableWithAggregatesFilter | Date | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    flight_brand?: StringNullableWithAggregatesFilter | string | null
    flight_number?: StringNullableWithAggregatesFilter | string | null
    frequent_flyer?: StringNullableWithAggregatesFilter | string | null
    hertz_membership?: StringNullableWithAggregatesFilter | string | null
    office_second_address?: StringNullableWithAggregatesFilter | string | null
    office_second_name?: StringNullableWithAggregatesFilter | string | null
    office_second_time?: StringNullableWithAggregatesFilter | string | null
    dropFee?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rate_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    tax?: StringNullableWithAggregatesFilter | string | null
    total_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type servicesWhereInput = {
    AND?: Enumerable<servicesWhereInput>
    OR?: Enumerable<servicesWhereInput>
    NOT?: Enumerable<servicesWhereInput>
    id?: StringFilter | string
    description?: StringNullableFilter | string | null
    ko_description?: StringNullableFilter | string | null
    details?: StringNullableFilter | string | null
    order?: IntNullableFilter | number | null
    packages?: PackagesListRelationFilter
  }

  export type servicesOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    ko_description?: SortOrder
    details?: SortOrder
    order?: SortOrder
    packages?: packagesOrderByRelationAggregateInput
  }

  export type servicesWhereUniqueInput = {
    id?: string
  }

  export type servicesOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    ko_description?: SortOrder
    details?: SortOrder
    order?: SortOrder
    _count?: servicesCountOrderByAggregateInput
    _avg?: servicesAvgOrderByAggregateInput
    _max?: servicesMaxOrderByAggregateInput
    _min?: servicesMinOrderByAggregateInput
    _sum?: servicesSumOrderByAggregateInput
  }

  export type servicesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<servicesScalarWhereWithAggregatesInput>
    OR?: Enumerable<servicesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<servicesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    ko_description?: StringNullableWithAggregatesFilter | string | null
    details?: StringNullableWithAggregatesFilter | string | null
    order?: IntNullableWithAggregatesFilter | number | null
  }

  export type agenciesWhereInput = {
    AND?: Enumerable<agenciesWhereInput>
    OR?: Enumerable<agenciesWhereInput>
    NOT?: Enumerable<agenciesWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    logo?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    admin_users?: Admin_usersListRelationFilter
    commission_setting?: Commission_settingListRelationFilter
    reservation?: ReservationListRelationFilter
  }

  export type agenciesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    created_date?: SortOrder
    admin_users?: admin_usersOrderByRelationAggregateInput
    commission_setting?: commission_settingOrderByRelationAggregateInput
    reservation?: reservationOrderByRelationAggregateInput
  }

  export type agenciesWhereUniqueInput = {
    id?: string
  }

  export type agenciesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    created_date?: SortOrder
    _count?: agenciesCountOrderByAggregateInput
    _max?: agenciesMaxOrderByAggregateInput
    _min?: agenciesMinOrderByAggregateInput
  }

  export type agenciesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<agenciesScalarWhereWithAggregatesInput>
    OR?: Enumerable<agenciesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<agenciesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    logo?: StringNullableWithAggregatesFilter | string | null
    created_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type commission_settingWhereInput = {
    AND?: Enumerable<commission_settingWhereInput>
    OR?: Enumerable<commission_settingWhereInput>
    NOT?: Enumerable<commission_settingWhereInput>
    id?: IntFilter | number
    vendor?: StringFilter | string
    agency?: StringFilter | string
    payment_type?: StringFilter | string
    tag?: StringFilter | string
    calculation_type?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    agencies?: XOR<AgenciesRelationFilter, agenciesWhereInput>
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
  }

  export type commission_settingOrderByWithRelationInput = {
    id?: SortOrder
    vendor?: SortOrder
    agency?: SortOrder
    payment_type?: SortOrder
    tag?: SortOrder
    calculation_type?: SortOrder
    amount?: SortOrder
    agencies?: agenciesOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
  }

  export type commission_settingWhereUniqueInput = {
    id?: number
  }

  export type commission_settingOrderByWithAggregationInput = {
    id?: SortOrder
    vendor?: SortOrder
    agency?: SortOrder
    payment_type?: SortOrder
    tag?: SortOrder
    calculation_type?: SortOrder
    amount?: SortOrder
    _count?: commission_settingCountOrderByAggregateInput
    _avg?: commission_settingAvgOrderByAggregateInput
    _max?: commission_settingMaxOrderByAggregateInput
    _min?: commission_settingMinOrderByAggregateInput
    _sum?: commission_settingSumOrderByAggregateInput
  }

  export type commission_settingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<commission_settingScalarWhereWithAggregatesInput>
    OR?: Enumerable<commission_settingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<commission_settingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vendor?: StringWithAggregatesFilter | string
    agency?: StringWithAggregatesFilter | string
    payment_type?: StringWithAggregatesFilter | string
    tag?: StringWithAggregatesFilter | string
    calculation_type?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type couponsWhereInput = {
    AND?: Enumerable<couponsWhereInput>
    OR?: Enumerable<couponsWhereInput>
    NOT?: Enumerable<couponsWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    coupon_name?: StringFilter | string
    brand?: StringFilter | string
    destination?: StringFilter | string
    offer_description?: StringNullableFilter | string | null
    corporate_discount_number?: StringFilter | string
    promotion_code?: StringFilter | string
    min_days?: IntFilter | number
    car_group?: StringFilter | string
    pickup_start_time?: DateTimeFilter | Date | string
    pickup_end_time?: DateTimeFilter | Date | string
    order_start_time?: DateTimeFilter | Date | string
    order_end_time?: DateTimeFilter | Date | string
    issued_count?: IntFilter | number
    used_count?: IntNullableFilter | number | null
    status?: StringFilter | string
    remark?: StringFilter | string
  }

  export type couponsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    coupon_name?: SortOrder
    brand?: SortOrder
    destination?: SortOrder
    offer_description?: SortOrder
    corporate_discount_number?: SortOrder
    promotion_code?: SortOrder
    min_days?: SortOrder
    car_group?: SortOrder
    pickup_start_time?: SortOrder
    pickup_end_time?: SortOrder
    order_start_time?: SortOrder
    order_end_time?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type couponsWhereUniqueInput = {
    id?: number
  }

  export type couponsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    coupon_name?: SortOrder
    brand?: SortOrder
    destination?: SortOrder
    offer_description?: SortOrder
    corporate_discount_number?: SortOrder
    promotion_code?: SortOrder
    min_days?: SortOrder
    car_group?: SortOrder
    pickup_start_time?: SortOrder
    pickup_end_time?: SortOrder
    order_start_time?: SortOrder
    order_end_time?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    remark?: SortOrder
    _count?: couponsCountOrderByAggregateInput
    _avg?: couponsAvgOrderByAggregateInput
    _max?: couponsMaxOrderByAggregateInput
    _min?: couponsMinOrderByAggregateInput
    _sum?: couponsSumOrderByAggregateInput
  }

  export type couponsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<couponsScalarWhereWithAggregatesInput>
    OR?: Enumerable<couponsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<couponsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    coupon_name?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    destination?: StringWithAggregatesFilter | string
    offer_description?: StringNullableWithAggregatesFilter | string | null
    corporate_discount_number?: StringWithAggregatesFilter | string
    promotion_code?: StringWithAggregatesFilter | string
    min_days?: IntWithAggregatesFilter | number
    car_group?: StringWithAggregatesFilter | string
    pickup_start_time?: DateTimeWithAggregatesFilter | Date | string
    pickup_end_time?: DateTimeWithAggregatesFilter | Date | string
    order_start_time?: DateTimeWithAggregatesFilter | Date | string
    order_end_time?: DateTimeWithAggregatesFilter | Date | string
    issued_count?: IntWithAggregatesFilter | number
    used_count?: IntNullableWithAggregatesFilter | number | null
    status?: StringWithAggregatesFilter | string
    remark?: StringWithAggregatesFilter | string
  }

  export type promotion_codeWhereInput = {
    AND?: Enumerable<promotion_codeWhereInput>
    OR?: Enumerable<promotion_codeWhereInput>
    NOT?: Enumerable<promotion_codeWhereInput>
    cdp?: StringFilter | string
    pc?: StringFilter | string
    vendor_id?: StringFilter | string
    country?: StringFilter | string
    name?: StringNullableFilter | string | null
  }

  export type promotion_codeOrderByWithRelationInput = {
    cdp?: SortOrder
    pc?: SortOrder
    vendor_id?: SortOrder
    country?: SortOrder
    name?: SortOrder
  }

  export type promotion_codeWhereUniqueInput = {
    country_vendor_id?: promotion_codeCountryVendor_idCompoundUniqueInput
  }

  export type promotion_codeOrderByWithAggregationInput = {
    cdp?: SortOrder
    pc?: SortOrder
    vendor_id?: SortOrder
    country?: SortOrder
    name?: SortOrder
    _count?: promotion_codeCountOrderByAggregateInput
    _max?: promotion_codeMaxOrderByAggregateInput
    _min?: promotion_codeMinOrderByAggregateInput
  }

  export type promotion_codeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<promotion_codeScalarWhereWithAggregatesInput>
    OR?: Enumerable<promotion_codeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<promotion_codeScalarWhereWithAggregatesInput>
    cdp?: StringWithAggregatesFilter | string
    pc?: StringWithAggregatesFilter | string
    vendor_id?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
  }

  export type faqWhereInput = {
    AND?: Enumerable<faqWhereInput>
    OR?: Enumerable<faqWhereInput>
    NOT?: Enumerable<faqWhereInput>
    id?: IntFilter | number
    question_kr?: StringFilter | string
    question_us?: StringNullableFilter | string | null
    answer_kr?: StringFilter | string
    answer_us?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    sort_order?: IntFilter | number
    subject_id?: IntNullableFilter | number | null
    subject_faq?: XOR<Subject_faqRelationFilter, subject_faqWhereInput> | null
    keyword_faq?: Keyword_faqListRelationFilter
  }

  export type faqOrderByWithRelationInput = {
    id?: SortOrder
    question_kr?: SortOrder
    question_us?: SortOrder
    answer_kr?: SortOrder
    answer_us?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
    subject_faq?: subject_faqOrderByWithRelationInput
    keyword_faq?: keyword_faqOrderByRelationAggregateInput
  }

  export type faqWhereUniqueInput = {
    id?: number
  }

  export type faqOrderByWithAggregationInput = {
    id?: SortOrder
    question_kr?: SortOrder
    question_us?: SortOrder
    answer_kr?: SortOrder
    answer_us?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
    _count?: faqCountOrderByAggregateInput
    _avg?: faqAvgOrderByAggregateInput
    _max?: faqMaxOrderByAggregateInput
    _min?: faqMinOrderByAggregateInput
    _sum?: faqSumOrderByAggregateInput
  }

  export type faqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<faqScalarWhereWithAggregatesInput>
    OR?: Enumerable<faqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<faqScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    question_kr?: StringWithAggregatesFilter | string
    question_us?: StringNullableWithAggregatesFilter | string | null
    answer_kr?: StringWithAggregatesFilter | string
    answer_us?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    sort_order?: IntWithAggregatesFilter | number
    subject_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type error_messagesWhereInput = {
    AND?: Enumerable<error_messagesWhereInput>
    OR?: Enumerable<error_messagesWhereInput>
    NOT?: Enumerable<error_messagesWhereInput>
    error_code?: StringFilter | string
    english_message?: StringFilter | string
    korean_message?: StringFilter | string
  }

  export type error_messagesOrderByWithRelationInput = {
    error_code?: SortOrder
    english_message?: SortOrder
    korean_message?: SortOrder
  }

  export type error_messagesWhereUniqueInput = {
    error_code?: string
  }

  export type error_messagesOrderByWithAggregationInput = {
    error_code?: SortOrder
    english_message?: SortOrder
    korean_message?: SortOrder
    _count?: error_messagesCountOrderByAggregateInput
    _max?: error_messagesMaxOrderByAggregateInput
    _min?: error_messagesMinOrderByAggregateInput
  }

  export type error_messagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<error_messagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<error_messagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<error_messagesScalarWhereWithAggregatesInput>
    error_code?: StringWithAggregatesFilter | string
    english_message?: StringWithAggregatesFilter | string
    korean_message?: StringWithAggregatesFilter | string
  }

  export type exchange_rate_historyWhereInput = {
    AND?: Enumerable<exchange_rate_historyWhereInput>
    OR?: Enumerable<exchange_rate_historyWhereInput>
    NOT?: Enumerable<exchange_rate_historyWhereInput>
    id?: IntFilter | number
    exchange_rate_id?: IntFilter | number
    rate?: FloatFilter | number
    date?: DateTimeFilter | Date | string
    exchange_rates?: XOR<Exchange_ratesRelationFilter, exchange_ratesWhereInput>
  }

  export type exchange_rate_historyOrderByWithRelationInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    exchange_rates?: exchange_ratesOrderByWithRelationInput
  }

  export type exchange_rate_historyWhereUniqueInput = {
    id?: number
    exchange_rate_id_date?: exchange_rate_historyExchange_rate_idDateCompoundUniqueInput
  }

  export type exchange_rate_historyOrderByWithAggregationInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    _count?: exchange_rate_historyCountOrderByAggregateInput
    _avg?: exchange_rate_historyAvgOrderByAggregateInput
    _max?: exchange_rate_historyMaxOrderByAggregateInput
    _min?: exchange_rate_historyMinOrderByAggregateInput
    _sum?: exchange_rate_historySumOrderByAggregateInput
  }

  export type exchange_rate_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<exchange_rate_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<exchange_rate_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<exchange_rate_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    exchange_rate_id?: IntWithAggregatesFilter | number
    rate?: FloatWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
  }

  export type subject_faqWhereInput = {
    AND?: Enumerable<subject_faqWhereInput>
    OR?: Enumerable<subject_faqWhereInput>
    NOT?: Enumerable<subject_faqWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    faq?: FaqListRelationFilter
  }

  export type subject_faqOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    faq?: faqOrderByRelationAggregateInput
  }

  export type subject_faqWhereUniqueInput = {
    id?: number
  }

  export type subject_faqOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: subject_faqCountOrderByAggregateInput
    _avg?: subject_faqAvgOrderByAggregateInput
    _max?: subject_faqMaxOrderByAggregateInput
    _min?: subject_faqMinOrderByAggregateInput
    _sum?: subject_faqSumOrderByAggregateInput
  }

  export type subject_faqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subject_faqScalarWhereWithAggregatesInput>
    OR?: Enumerable<subject_faqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subject_faqScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type keyword_faqWhereInput = {
    AND?: Enumerable<keyword_faqWhereInput>
    OR?: Enumerable<keyword_faqWhereInput>
    NOT?: Enumerable<keyword_faqWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    faq_id?: IntFilter | number
    faq?: XOR<FaqRelationFilter, faqWhereInput>
  }

  export type keyword_faqOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    faq_id?: SortOrder
    faq?: faqOrderByWithRelationInput
  }

  export type keyword_faqWhereUniqueInput = {
    id?: number
  }

  export type keyword_faqOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    faq_id?: SortOrder
    _count?: keyword_faqCountOrderByAggregateInput
    _avg?: keyword_faqAvgOrderByAggregateInput
    _max?: keyword_faqMaxOrderByAggregateInput
    _min?: keyword_faqMinOrderByAggregateInput
    _sum?: keyword_faqSumOrderByAggregateInput
  }

  export type keyword_faqScalarWhereWithAggregatesInput = {
    AND?: Enumerable<keyword_faqScalarWhereWithAggregatesInput>
    OR?: Enumerable<keyword_faqScalarWhereWithAggregatesInput>
    NOT?: Enumerable<keyword_faqScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    faq_id?: IntWithAggregatesFilter | number
  }

  export type cities_locationsWhereInput = {
    AND?: Enumerable<cities_locationsWhereInput>
    OR?: Enumerable<cities_locationsWhereInput>
    NOT?: Enumerable<cities_locationsWhereInput>
    city_code?: StringFilter | string
    location_id?: StringFilter | string
  }

  export type cities_locationsOrderByWithRelationInput = {
    city_code?: SortOrder
    location_id?: SortOrder
  }

  export type cities_locationsWhereUniqueInput = {
    city_code_location_id?: cities_locationsCity_codeLocation_idCompoundUniqueInput
  }

  export type cities_locationsOrderByWithAggregationInput = {
    city_code?: SortOrder
    location_id?: SortOrder
    _count?: cities_locationsCountOrderByAggregateInput
    _max?: cities_locationsMaxOrderByAggregateInput
    _min?: cities_locationsMinOrderByAggregateInput
  }

  export type cities_locationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cities_locationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<cities_locationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cities_locationsScalarWhereWithAggregatesInput>
    city_code?: StringWithAggregatesFilter | string
    location_id?: StringWithAggregatesFilter | string
  }

  export type api_keyCreateInput = {
    client_id: string
    key: string
  }

  export type api_keyUncheckedCreateInput = {
    client_id: string
    key: string
  }

  export type api_keyUpdateInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type api_keyUncheckedUpdateInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type api_keyCreateManyInput = {
    client_id: string
    key: string
  }

  export type api_keyUpdateManyMutationInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type api_keyUncheckedUpdateManyInput = {
    client_id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type citiesCreateInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    countries?: countriesCreateNestedOneWithoutCitiesInput
    cities_translation?: cities_translationCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    country_code?: string | null
    cities_translation?: cities_translationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: countriesUpdateOneWithoutCitiesNestedInput
    cities_translation?: cities_translationUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    cities_translation?: cities_translationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type citiesCreateManyInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    country_code?: string | null
  }

  export type citiesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type citiesUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cities_translationCreateInput = {
    locale: string
    city_name: string
    cities: citiesCreateNestedOneWithoutCities_translationInput
  }

  export type cities_translationUncheckedCreateInput = {
    city_code: string
    locale: string
    city_name: string
  }

  export type cities_translationUpdateInput = {
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
    cities?: citiesUpdateOneRequiredWithoutCities_translationNestedInput
  }

  export type cities_translationUncheckedUpdateInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_translationCreateManyInput = {
    city_code: string
    locale: string
    city_name: string
  }

  export type cities_translationUpdateManyMutationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_translationUncheckedUpdateManyInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type localesCreateInput = {
    name: string
    code: string
    default?: boolean
    translation?: translationCreateNestedManyWithoutLocalesInput
  }

  export type localesUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    default?: boolean
    translation?: translationUncheckedCreateNestedManyWithoutLocalesInput
  }

  export type localesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    translation?: translationUpdateManyWithoutLocalesNestedInput
  }

  export type localesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    translation?: translationUncheckedUpdateManyWithoutLocalesNestedInput
  }

  export type localesCreateManyInput = {
    id?: number
    name: string
    code: string
    default?: boolean
  }

  export type localesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type localesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type locationCreateInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    categories?: categoriesCreateNestedOneWithoutLocationInput
    location_type_1?: location_type_1CreateNestedOneWithoutLocationInput
    location_type_2?: location_type_2CreateNestedOneWithoutLocationInput
    vendors: vendorsCreateNestedOneWithoutLocationInput
    location_description?: location_descriptionCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
    location_description?: location_descriptionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateOneWithoutLocationNestedInput
    location_type_1?: location_type_1UpdateOneWithoutLocationNestedInput
    location_type_2?: location_type_2UpdateOneWithoutLocationNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutLocationNestedInput
    location_description?: location_descriptionUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_description?: location_descriptionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
  }

  export type locationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_descriptionCreateInput = {
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
    location: locationCreateNestedOneWithoutLocation_descriptionInput
  }

  export type location_descriptionUncheckedCreateInput = {
    location_id: string
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
  }

  export type location_descriptionUpdateInput = {
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
    location?: locationUpdateOneRequiredWithoutLocation_descriptionNestedInput
  }

  export type location_descriptionUncheckedUpdateInput = {
    location_id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_descriptionCreateManyInput = {
    location_id: string
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
  }

  export type location_descriptionUpdateManyMutationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_descriptionUncheckedUpdateManyInput = {
    location_id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type translationCreateInput = {
    message: string
    tag: string
    locales: localesCreateNestedOneWithoutTranslationInput
  }

  export type translationUncheckedCreateInput = {
    locale_id: number
    message: string
    tag: string
  }

  export type translationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    locales?: localesUpdateOneRequiredWithoutTranslationNestedInput
  }

  export type translationUncheckedUpdateInput = {
    locale_id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type translationCreateManyInput = {
    locale_id: number
    message: string
    tag: string
  }

  export type translationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateManyInput = {
    locale_id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type countriesCreateInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsCreateNestedManyWithoutCountriesInput
    cities?: citiesCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsUncheckedCreateNestedManyWithoutCountriesInput
    cities?: citiesUncheckedCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUpdateManyWithoutCountriesNestedInput
    cities?: citiesUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUpdateManyWithoutCountriesNestedInput
  }

  export type countriesUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUncheckedUpdateManyWithoutCountriesNestedInput
    cities?: citiesUncheckedUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUncheckedUpdateManyWithoutCountriesNestedInput
  }

  export type countriesCreateManyInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
  }

  export type countriesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countriesUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countries_translationCreateInput = {
    locale: string
    country_name: string
    countries: countriesCreateNestedOneWithoutCountries_translationInput
  }

  export type countries_translationUncheckedCreateInput = {
    country_code: string
    locale: string
    country_name: string
  }

  export type countries_translationUpdateInput = {
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
    countries?: countriesUpdateOneRequiredWithoutCountries_translationNestedInput
  }

  export type countries_translationUncheckedUpdateInput = {
    country_code?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type countries_translationCreateManyInput = {
    country_code: string
    locale: string
    country_name: string
  }

  export type countries_translationUpdateManyMutationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type countries_translationUncheckedUpdateManyInput = {
    country_code?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_1CreateInput = {
    type: string
    description: string
    location?: locationCreateNestedManyWithoutLocation_type_1Input
  }

  export type location_type_1UncheckedCreateInput = {
    type: string
    description: string
    location?: locationUncheckedCreateNestedManyWithoutLocation_type_1Input
  }

  export type location_type_1UpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateManyWithoutLocation_type_1NestedInput
  }

  export type location_type_1UncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: locationUncheckedUpdateManyWithoutLocation_type_1NestedInput
  }

  export type location_type_1CreateManyInput = {
    type: string
    description: string
  }

  export type location_type_1UpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_1UncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_2CreateInput = {
    type: string
    description: string
    location?: locationCreateNestedManyWithoutLocation_type_2Input
  }

  export type location_type_2UncheckedCreateInput = {
    type: string
    description: string
    location?: locationUncheckedCreateNestedManyWithoutLocation_type_2Input
  }

  export type location_type_2UpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateManyWithoutLocation_type_2NestedInput
  }

  export type location_type_2UncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: locationUncheckedUpdateManyWithoutLocation_type_2NestedInput
  }

  export type location_type_2CreateManyInput = {
    type: string
    description: string
  }

  export type location_type_2UpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_2UncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type vendorsCreateInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingCreateNestedManyWithoutVendorsInput
    location?: locationCreateNestedManyWithoutVendorsInput
    reservation?: reservationCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUncheckedCreateInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutVendorsInput
    location?: locationUncheckedCreateNestedManyWithoutVendorsInput
    reservation?: reservationUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUpdateManyWithoutVendorsNestedInput
    location?: locationUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUncheckedUpdateManyWithoutVendorsNestedInput
    location?: locationUncheckedUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsCreateManyInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
  }

  export type vendorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type vendorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type airportsCreateInput = {
    iata_code: string
    icao_code: string
    name: string
    latitude: number
    longitude: number
    countries?: countriesCreateNestedOneWithoutAirportsInput
  }

  export type airportsUncheckedCreateInput = {
    iata_code: string
    country_code?: string | null
    icao_code: string
    name: string
    latitude: number
    longitude: number
    id?: number
  }

  export type airportsUpdateInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
    countries?: countriesUpdateOneWithoutAirportsNestedInput
  }

  export type airportsUncheckedUpdateInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type airportsCreateManyInput = {
    iata_code: string
    country_code?: string | null
    icao_code: string
    name: string
    latitude: number
    longitude: number
    id?: number
  }

  export type airportsUpdateManyMutationInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
  }

  export type airportsUncheckedUpdateManyInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type categoriesCreateInput = {
    id: string
    name: string
    icon?: string | null
    location?: locationCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id: string
    name: string
    icon?: string | null
    location?: locationUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    location?: locationUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    location?: locationUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id: string
    name: string
    icon?: string | null
  }

  export type categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateInput = {
    order_id: string
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
    reservation?: reservationCreateNestedOneWithoutPaymentInput
    users?: usersCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    order_id: string
    user_id?: number | null
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    reservation_id?: string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type paymentUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservation?: reservationUpdateOneWithoutPaymentNestedInput
    users?: usersUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentCreateManyInput = {
    order_id: string
    user_id?: number | null
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    reservation_id?: string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type paymentUpdateManyMutationInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type exchange_ratesCreateInput = {
    from_code: string
    to_code: string
    rate: number
    exchange_rate_history?: exchange_rate_historyCreateNestedManyWithoutExchange_ratesInput
  }

  export type exchange_ratesUncheckedCreateInput = {
    id?: number
    from_code: string
    to_code: string
    rate: number
    exchange_rate_history?: exchange_rate_historyUncheckedCreateNestedManyWithoutExchange_ratesInput
  }

  export type exchange_ratesUpdateInput = {
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    exchange_rate_history?: exchange_rate_historyUpdateManyWithoutExchange_ratesNestedInput
  }

  export type exchange_ratesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    exchange_rate_history?: exchange_rate_historyUncheckedUpdateManyWithoutExchange_ratesNestedInput
  }

  export type exchange_ratesCreateManyInput = {
    id?: number
    from_code: string
    to_code: string
    rate: number
  }

  export type exchange_ratesUpdateManyMutationInput = {
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type exchange_ratesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type admin_permissionsCreateInput = {
    action: string
    description?: string | null
    admin_roles_permissions?: admin_roles_permissionsCreateNestedManyWithoutAdmin_permissionsInput
  }

  export type admin_permissionsUncheckedCreateInput = {
    id?: number
    action: string
    description?: string | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_permissionsInput
  }

  export type admin_permissionsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_permissions?: admin_roles_permissionsUpdateManyWithoutAdmin_permissionsNestedInput
  }

  export type admin_permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_permissionsNestedInput
  }

  export type admin_permissionsCreateManyInput = {
    id?: number
    action: string
    description?: string | null
  }

  export type admin_permissionsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_rolesCreateInput = {
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    admin_roles_permissions?: admin_roles_permissionsCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    modified_by?: number | null
    deleted?: number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersNestedInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersNestedInput
    admin_roles_permissions?: admin_roles_permissionsUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    modified_by?: number | null
    deleted?: number | null
  }

  export type admin_rolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type admin_rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type admin_roles_permissionsCreateInput = {
    admin_permissions: admin_permissionsCreateNestedOneWithoutAdmin_roles_permissionsInput
    admin_roles: admin_rolesCreateNestedOneWithoutAdmin_roles_permissionsInput
  }

  export type admin_roles_permissionsUncheckedCreateInput = {
    permission_id: number
    role_id: number
  }

  export type admin_roles_permissionsUpdateInput = {
    admin_permissions?: admin_permissionsUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput
    admin_roles?: admin_rolesUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput
  }

  export type admin_roles_permissionsUncheckedUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_roles_permissionsCreateManyInput = {
    permission_id: number
    role_id: number
  }

  export type admin_roles_permissionsUpdateManyMutationInput = {

  }

  export type admin_roles_permissionsUncheckedUpdateManyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_usersCreateInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersCreateManyInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
  }

  export type admin_usersUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_users_rolesCreateInput = {
    admin_roles: admin_rolesCreateNestedOneWithoutAdmin_users_rolesInput
    admin_users: admin_usersCreateNestedOneWithoutAdmin_users_rolesInput
  }

  export type admin_users_rolesUncheckedCreateInput = {
    user_id: number
    role_id: number
  }

  export type admin_users_rolesUpdateInput = {
    admin_roles?: admin_rolesUpdateOneRequiredWithoutAdmin_users_rolesNestedInput
    admin_users?: admin_usersUpdateOneRequiredWithoutAdmin_users_rolesNestedInput
  }

  export type admin_users_rolesUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_users_rolesCreateManyInput = {
    user_id: number
    role_id: number
  }

  export type admin_users_rolesUpdateManyMutationInput = {

  }

  export type admin_users_rolesUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type filesCreateInput = {
    file_key?: string | null
    file_url?: string | null
  }

  export type filesUncheckedCreateInput = {
    id?: number
    file_key?: string | null
    file_url?: string | null
  }

  export type filesUpdateInput = {
    file_key?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_key?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filesCreateManyInput = {
    id?: number
    file_key?: string | null
    file_url?: string | null
  }

  export type filesUpdateManyMutationInput = {
    file_key?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type filesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_key?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsCreateInput = {
    category: string
    name: string
    value?: string | null
    type?: string | null
  }

  export type settingsUncheckedCreateInput = {
    category: string
    name: string
    value?: string | null
    type?: string | null
  }

  export type settingsUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsUncheckedUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsCreateManyInput = {
    category: string
    name: string
    value?: string | null
    type?: string | null
  }

  export type settingsUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsUncheckedUpdateManyInput = {
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateInput = {
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    payment?: paymentCreateNestedManyWithoutUsersInput
    reservation?: reservationCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    reservation?: reservationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutUsersNestedInput
    reservation?: reservationUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type packagesCreateInput = {
    price_codes: price_codesCreateNestedOneWithoutPackagesInput
    services: servicesCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateInput = {
    price_id: string
    service_id: string
  }

  export type packagesUpdateInput = {
    price_codes?: price_codesUpdateOneRequiredWithoutPackagesNestedInput
    services?: servicesUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateInput = {
    price_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type packagesCreateManyInput = {
    price_id: string
    service_id: string
  }

  export type packagesUpdateManyMutationInput = {

  }

  export type packagesUncheckedUpdateManyInput = {
    price_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type price_codesCreateInput = {
    id: string
    price_code: string
    country_code: string
    name?: string | null
    price_type?: string | null
    vendor_id?: string | null
    ITCode?: string | null
    cdpNumber?: string | null
    show?: boolean | null
    insurance?: boolean | null
    ko_name?: string | null
    packages?: packagesCreateNestedManyWithoutPrice_codesInput
  }

  export type price_codesUncheckedCreateInput = {
    id: string
    price_code: string
    country_code: string
    name?: string | null
    price_type?: string | null
    vendor_id?: string | null
    ITCode?: string | null
    cdpNumber?: string | null
    show?: boolean | null
    insurance?: boolean | null
    ko_name?: string | null
    packages?: packagesUncheckedCreateNestedManyWithoutPrice_codesInput
  }

  export type price_codesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: packagesUpdateManyWithoutPrice_codesNestedInput
  }

  export type price_codesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: packagesUncheckedUpdateManyWithoutPrice_codesNestedInput
  }

  export type price_codesCreateManyInput = {
    id: string
    price_code: string
    country_code: string
    name?: string | null
    price_type?: string | null
    vendor_id?: string | null
    ITCode?: string | null
    cdpNumber?: string | null
    show?: boolean | null
    insurance?: boolean | null
    ko_name?: string | null
  }

  export type price_codesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_codesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reservationCreateInput = {
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesCreateNestedOneWithoutReservationInput
    vendors?: vendorsCreateNestedOneWithoutReservationInput
    users?: usersCreateNestedOneWithoutReservationInput
    payment?: paymentCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateInput = {
    supplier?: string | null
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationUpdateInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesUpdateOneWithoutReservationNestedInput
    vendors?: vendorsUpdateOneWithoutReservationNestedInput
    users?: usersUpdateOneWithoutReservationNestedInput
    payment?: paymentUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationCreateManyInput = {
    supplier?: string | null
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type reservationUpdateManyMutationInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type reservationUncheckedUpdateManyInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type servicesCreateInput = {
    id: string
    description?: string | null
    ko_description?: string | null
    details?: string | null
    order?: number | null
    packages?: packagesCreateNestedManyWithoutServicesInput
  }

  export type servicesUncheckedCreateInput = {
    id: string
    description?: string | null
    ko_description?: string | null
    details?: string | null
    order?: number | null
    packages?: packagesUncheckedCreateNestedManyWithoutServicesInput
  }

  export type servicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: packagesUpdateManyWithoutServicesNestedInput
  }

  export type servicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    packages?: packagesUncheckedUpdateManyWithoutServicesNestedInput
  }

  export type servicesCreateManyInput = {
    id: string
    description?: string | null
    ko_description?: string | null
    details?: string | null
    order?: number | null
  }

  export type servicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agenciesCreateInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersCreateNestedManyWithoutAgenciesInput
    commission_setting?: commission_settingCreateNestedManyWithoutAgenciesInput
    reservation?: reservationCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesUncheckedCreateInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersUncheckedCreateNestedManyWithoutAgenciesInput
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutAgenciesInput
    reservation?: reservationUncheckedCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUpdateManyWithoutAgenciesNestedInput
    commission_setting?: commission_settingUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUpdateManyWithoutAgenciesNestedInput
  }

  export type agenciesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUncheckedUpdateManyWithoutAgenciesNestedInput
    commission_setting?: commission_settingUncheckedUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutAgenciesNestedInput
  }

  export type agenciesCreateManyInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
  }

  export type agenciesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type agenciesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commission_settingCreateInput = {
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
    agencies: agenciesCreateNestedOneWithoutCommission_settingInput
    vendors: vendorsCreateNestedOneWithoutCommission_settingInput
  }

  export type commission_settingUncheckedCreateInput = {
    id?: number
    vendor: string
    agency: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type commission_settingUpdateInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    agencies?: agenciesUpdateOneRequiredWithoutCommission_settingNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutCommission_settingNestedInput
  }

  export type commission_settingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendor?: StringFieldUpdateOperationsInput | string
    agency?: StringFieldUpdateOperationsInput | string
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type commission_settingCreateManyInput = {
    id?: number
    vendor: string
    agency: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type commission_settingUpdateManyMutationInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type commission_settingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendor?: StringFieldUpdateOperationsInput | string
    agency?: StringFieldUpdateOperationsInput | string
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type couponsCreateInput = {
    type: string
    coupon_name: string
    brand: string
    destination: string
    offer_description?: string | null
    corporate_discount_number: string
    promotion_code: string
    min_days: number
    car_group: string
    pickup_start_time: Date | string
    pickup_end_time: Date | string
    order_start_time: Date | string
    order_end_time: Date | string
    issued_count: number
    used_count?: number | null
    status: string
    remark: string
  }

  export type couponsUncheckedCreateInput = {
    id?: number
    type: string
    coupon_name: string
    brand: string
    destination: string
    offer_description?: string | null
    corporate_discount_number: string
    promotion_code: string
    min_days: number
    car_group: string
    pickup_start_time: Date | string
    pickup_end_time: Date | string
    order_start_time: Date | string
    order_end_time: Date | string
    issued_count: number
    used_count?: number | null
    status: string
    remark: string
  }

  export type couponsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    coupon_name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    offer_description?: NullableStringFieldUpdateOperationsInput | string | null
    corporate_discount_number?: StringFieldUpdateOperationsInput | string
    promotion_code?: StringFieldUpdateOperationsInput | string
    min_days?: IntFieldUpdateOperationsInput | number
    car_group?: StringFieldUpdateOperationsInput | string
    pickup_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    issued_count?: IntFieldUpdateOperationsInput | number
    used_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type couponsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    coupon_name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    offer_description?: NullableStringFieldUpdateOperationsInput | string | null
    corporate_discount_number?: StringFieldUpdateOperationsInput | string
    promotion_code?: StringFieldUpdateOperationsInput | string
    min_days?: IntFieldUpdateOperationsInput | number
    car_group?: StringFieldUpdateOperationsInput | string
    pickup_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    issued_count?: IntFieldUpdateOperationsInput | number
    used_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type couponsCreateManyInput = {
    id?: number
    type: string
    coupon_name: string
    brand: string
    destination: string
    offer_description?: string | null
    corporate_discount_number: string
    promotion_code: string
    min_days: number
    car_group: string
    pickup_start_time: Date | string
    pickup_end_time: Date | string
    order_start_time: Date | string
    order_end_time: Date | string
    issued_count: number
    used_count?: number | null
    status: string
    remark: string
  }

  export type couponsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    coupon_name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    offer_description?: NullableStringFieldUpdateOperationsInput | string | null
    corporate_discount_number?: StringFieldUpdateOperationsInput | string
    promotion_code?: StringFieldUpdateOperationsInput | string
    min_days?: IntFieldUpdateOperationsInput | number
    car_group?: StringFieldUpdateOperationsInput | string
    pickup_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    issued_count?: IntFieldUpdateOperationsInput | number
    used_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type couponsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    coupon_name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    offer_description?: NullableStringFieldUpdateOperationsInput | string | null
    corporate_discount_number?: StringFieldUpdateOperationsInput | string
    promotion_code?: StringFieldUpdateOperationsInput | string
    min_days?: IntFieldUpdateOperationsInput | number
    car_group?: StringFieldUpdateOperationsInput | string
    pickup_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pickup_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    issued_count?: IntFieldUpdateOperationsInput | number
    used_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    remark?: StringFieldUpdateOperationsInput | string
  }

  export type promotion_codeCreateInput = {
    cdp: string
    pc: string
    vendor_id: string
    country: string
    name?: string | null
  }

  export type promotion_codeUncheckedCreateInput = {
    cdp: string
    pc: string
    vendor_id: string
    country: string
    name?: string | null
  }

  export type promotion_codeUpdateInput = {
    cdp?: StringFieldUpdateOperationsInput | string
    pc?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type promotion_codeUncheckedUpdateInput = {
    cdp?: StringFieldUpdateOperationsInput | string
    pc?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type promotion_codeCreateManyInput = {
    cdp: string
    pc: string
    vendor_id: string
    country: string
    name?: string | null
  }

  export type promotion_codeUpdateManyMutationInput = {
    cdp?: StringFieldUpdateOperationsInput | string
    pc?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type promotion_codeUncheckedUpdateManyInput = {
    cdp?: StringFieldUpdateOperationsInput | string
    pc?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type faqCreateInput = {
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    subject_faq?: subject_faqCreateNestedOneWithoutFaqInput
    keyword_faq?: keyword_faqCreateNestedManyWithoutFaqInput
  }

  export type faqUncheckedCreateInput = {
    id?: number
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    subject_id?: number | null
    keyword_faq?: keyword_faqUncheckedCreateNestedManyWithoutFaqInput
  }

  export type faqUpdateInput = {
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    subject_faq?: subject_faqUpdateOneWithoutFaqNestedInput
    keyword_faq?: keyword_faqUpdateManyWithoutFaqNestedInput
  }

  export type faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
    keyword_faq?: keyword_faqUncheckedUpdateManyWithoutFaqNestedInput
  }

  export type faqCreateManyInput = {
    id?: number
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    subject_id?: number | null
  }

  export type faqUpdateManyMutationInput = {
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }

  export type faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type error_messagesCreateInput = {
    error_code: string
    english_message: string
    korean_message: string
  }

  export type error_messagesUncheckedCreateInput = {
    error_code: string
    english_message: string
    korean_message: string
  }

  export type error_messagesUpdateInput = {
    error_code?: StringFieldUpdateOperationsInput | string
    english_message?: StringFieldUpdateOperationsInput | string
    korean_message?: StringFieldUpdateOperationsInput | string
  }

  export type error_messagesUncheckedUpdateInput = {
    error_code?: StringFieldUpdateOperationsInput | string
    english_message?: StringFieldUpdateOperationsInput | string
    korean_message?: StringFieldUpdateOperationsInput | string
  }

  export type error_messagesCreateManyInput = {
    error_code: string
    english_message: string
    korean_message: string
  }

  export type error_messagesUpdateManyMutationInput = {
    error_code?: StringFieldUpdateOperationsInput | string
    english_message?: StringFieldUpdateOperationsInput | string
    korean_message?: StringFieldUpdateOperationsInput | string
  }

  export type error_messagesUncheckedUpdateManyInput = {
    error_code?: StringFieldUpdateOperationsInput | string
    english_message?: StringFieldUpdateOperationsInput | string
    korean_message?: StringFieldUpdateOperationsInput | string
  }

  export type exchange_rate_historyCreateInput = {
    rate: number
    date: Date | string
    exchange_rates: exchange_ratesCreateNestedOneWithoutExchange_rate_historyInput
  }

  export type exchange_rate_historyUncheckedCreateInput = {
    id?: number
    exchange_rate_id: number
    rate: number
    date: Date | string
  }

  export type exchange_rate_historyUpdateInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_rates?: exchange_ratesUpdateOneRequiredWithoutExchange_rate_historyNestedInput
  }

  export type exchange_rate_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchange_rate_id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_rate_historyCreateManyInput = {
    id?: number
    exchange_rate_id: number
    rate: number
    date: Date | string
  }

  export type exchange_rate_historyUpdateManyMutationInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_rate_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exchange_rate_id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subject_faqCreateInput = {
    name: string
    faq?: faqCreateNestedManyWithoutSubject_faqInput
  }

  export type subject_faqUncheckedCreateInput = {
    id?: number
    name: string
    faq?: faqUncheckedCreateNestedManyWithoutSubject_faqInput
  }

  export type subject_faqUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    faq?: faqUpdateManyWithoutSubject_faqNestedInput
  }

  export type subject_faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    faq?: faqUncheckedUpdateManyWithoutSubject_faqNestedInput
  }

  export type subject_faqCreateManyInput = {
    id?: number
    name: string
  }

  export type subject_faqUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type subject_faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type keyword_faqCreateInput = {
    name: string
    faq: faqCreateNestedOneWithoutKeyword_faqInput
  }

  export type keyword_faqUncheckedCreateInput = {
    id?: number
    name: string
    faq_id: number
  }

  export type keyword_faqUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    faq?: faqUpdateOneRequiredWithoutKeyword_faqNestedInput
  }

  export type keyword_faqUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    faq_id?: IntFieldUpdateOperationsInput | number
  }

  export type keyword_faqCreateManyInput = {
    id?: number
    name: string
    faq_id: number
  }

  export type keyword_faqUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type keyword_faqUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    faq_id?: IntFieldUpdateOperationsInput | number
  }

  export type cities_locationsCreateInput = {
    city_code: string
    location_id: string
  }

  export type cities_locationsUncheckedCreateInput = {
    city_code: string
    location_id: string
  }

  export type cities_locationsUpdateInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
  }

  export type cities_locationsUncheckedUpdateInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
  }

  export type cities_locationsCreateManyInput = {
    city_code: string
    location_id: string
  }

  export type cities_locationsUpdateManyMutationInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
  }

  export type cities_locationsUncheckedUpdateManyInput = {
    city_code?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type api_keyCountOrderByAggregateInput = {
    client_id?: SortOrder
    key?: SortOrder
  }

  export type api_keyMaxOrderByAggregateInput = {
    client_id?: SortOrder
    key?: SortOrder
  }

  export type api_keyMinOrderByAggregateInput = {
    client_id?: SortOrder
    key?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CountriesRelationFilter = {
    is?: countriesWhereInput | null
    isNot?: countriesWhereInput | null
  }

  export type Cities_translationListRelationFilter = {
    every?: cities_translationWhereInput
    some?: cities_translationWhereInput
    none?: cities_translationWhereInput
  }

  export type cities_translationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citiesCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    un_locode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
    timezone?: SortOrder
    country_code?: SortOrder
  }

  export type citiesAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
  }

  export type citiesMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    un_locode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
    timezone?: SortOrder
    country_code?: SortOrder
  }

  export type citiesMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    un_locode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
    timezone?: SortOrder
    country_code?: SortOrder
  }

  export type citiesSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    alt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type CitiesRelationFilter = {
    is?: citiesWhereInput
    isNot?: citiesWhereInput
  }

  export type cities_translationCity_codeLocaleCompoundUniqueInput = {
    city_code: string
    locale: string
  }

  export type cities_translationCountOrderByAggregateInput = {
    city_code?: SortOrder
    locale?: SortOrder
    city_name?: SortOrder
  }

  export type cities_translationMaxOrderByAggregateInput = {
    city_code?: SortOrder
    locale?: SortOrder
    city_name?: SortOrder
  }

  export type cities_translationMinOrderByAggregateInput = {
    city_code?: SortOrder
    locale?: SortOrder
    city_name?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type TranslationListRelationFilter = {
    every?: translationWhereInput
    some?: translationWhereInput
    none?: translationWhereInput
  }

  export type translationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type localesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    default?: SortOrder
  }

  export type localesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type localesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    default?: SortOrder
  }

  export type localesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    default?: SortOrder
  }

  export type localesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type CategoriesRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type Location_type_1RelationFilter = {
    is?: location_type_1WhereInput | null
    isNot?: location_type_1WhereInput | null
  }

  export type Location_type_2RelationFilter = {
    is?: location_type_2WhereInput | null
    isNot?: location_type_2WhereInput | null
  }

  export type VendorsRelationFilter = {
    is?: vendorsWhereInput | null
    isNot?: vendorsWhereInput | null
  }

  export type Location_descriptionListRelationFilter = {
    every?: location_descriptionWhereInput
    some?: location_descriptionWhereInput
    none?: location_descriptionWhereInput
  }

  export type location_descriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationVendor_idOag_codeCompoundUniqueInput = {
    vendor_id: string
    oag_code: string
  }

  export type locationCountOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    vendor_id?: SortOrder
    oag_code?: SortOrder
    country_code?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    phone?: SortOrder
    alt_phone?: SortOrder
    fax?: SortOrder
    telex?: SortOrder
    web_url?: SortOrder
    email?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    open_1_mon?: SortOrder
    close_1_mon?: SortOrder
    open_2_mon?: SortOrder
    close_2_mon?: SortOrder
    open_3_mon?: SortOrder
    close_3_mon?: SortOrder
    open_1_tue?: SortOrder
    close_1_tue?: SortOrder
    open_2_tue?: SortOrder
    close_2_tue?: SortOrder
    open_3_tue?: SortOrder
    close_3_tue?: SortOrder
    open_1_wed?: SortOrder
    close_1_wed?: SortOrder
    open_2_wed?: SortOrder
    close_2_wed?: SortOrder
    open_3_wed?: SortOrder
    close_3_wed?: SortOrder
    open_1_thu?: SortOrder
    close_1_thu?: SortOrder
    open_2_thu?: SortOrder
    close_2_thu?: SortOrder
    open_3_thu?: SortOrder
    close_3_thu?: SortOrder
    open_1_fri?: SortOrder
    close_1_fri?: SortOrder
    open_2_fri?: SortOrder
    close_2_fri?: SortOrder
    open_3_fri?: SortOrder
    close_3_fri?: SortOrder
    open_1_sat?: SortOrder
    close_1_sat?: SortOrder
    open_2_sat?: SortOrder
    close_2_sat?: SortOrder
    open_3_sat?: SortOrder
    close_3_sat?: SortOrder
    open_1_sun?: SortOrder
    close_1_sun?: SortOrder
    open_2_sun?: SortOrder
    close_2_sun?: SortOrder
    open_3_sun?: SortOrder
    close_3_sun?: SortOrder
    loc_type_1?: SortOrder
    loc_type_2?: SortOrder
    city_name?: SortOrder
    category_id?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    vendor_id?: SortOrder
    oag_code?: SortOrder
    country_code?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    phone?: SortOrder
    alt_phone?: SortOrder
    fax?: SortOrder
    telex?: SortOrder
    web_url?: SortOrder
    email?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    open_1_mon?: SortOrder
    close_1_mon?: SortOrder
    open_2_mon?: SortOrder
    close_2_mon?: SortOrder
    open_3_mon?: SortOrder
    close_3_mon?: SortOrder
    open_1_tue?: SortOrder
    close_1_tue?: SortOrder
    open_2_tue?: SortOrder
    close_2_tue?: SortOrder
    open_3_tue?: SortOrder
    close_3_tue?: SortOrder
    open_1_wed?: SortOrder
    close_1_wed?: SortOrder
    open_2_wed?: SortOrder
    close_2_wed?: SortOrder
    open_3_wed?: SortOrder
    close_3_wed?: SortOrder
    open_1_thu?: SortOrder
    close_1_thu?: SortOrder
    open_2_thu?: SortOrder
    close_2_thu?: SortOrder
    open_3_thu?: SortOrder
    close_3_thu?: SortOrder
    open_1_fri?: SortOrder
    close_1_fri?: SortOrder
    open_2_fri?: SortOrder
    close_2_fri?: SortOrder
    open_3_fri?: SortOrder
    close_3_fri?: SortOrder
    open_1_sat?: SortOrder
    close_1_sat?: SortOrder
    open_2_sat?: SortOrder
    close_2_sat?: SortOrder
    open_3_sat?: SortOrder
    close_3_sat?: SortOrder
    open_1_sun?: SortOrder
    close_1_sun?: SortOrder
    open_2_sun?: SortOrder
    close_2_sun?: SortOrder
    open_3_sun?: SortOrder
    close_3_sun?: SortOrder
    loc_type_1?: SortOrder
    loc_type_2?: SortOrder
    city_name?: SortOrder
    category_id?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id?: SortOrder
    city_code?: SortOrder
    vendor_id?: SortOrder
    oag_code?: SortOrder
    country_code?: SortOrder
    state?: SortOrder
    zip_code?: SortOrder
    phone?: SortOrder
    alt_phone?: SortOrder
    fax?: SortOrder
    telex?: SortOrder
    web_url?: SortOrder
    email?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    open_1_mon?: SortOrder
    close_1_mon?: SortOrder
    open_2_mon?: SortOrder
    close_2_mon?: SortOrder
    open_3_mon?: SortOrder
    close_3_mon?: SortOrder
    open_1_tue?: SortOrder
    close_1_tue?: SortOrder
    open_2_tue?: SortOrder
    close_2_tue?: SortOrder
    open_3_tue?: SortOrder
    close_3_tue?: SortOrder
    open_1_wed?: SortOrder
    close_1_wed?: SortOrder
    open_2_wed?: SortOrder
    close_2_wed?: SortOrder
    open_3_wed?: SortOrder
    close_3_wed?: SortOrder
    open_1_thu?: SortOrder
    close_1_thu?: SortOrder
    open_2_thu?: SortOrder
    close_2_thu?: SortOrder
    open_3_thu?: SortOrder
    close_3_thu?: SortOrder
    open_1_fri?: SortOrder
    close_1_fri?: SortOrder
    open_2_fri?: SortOrder
    close_2_fri?: SortOrder
    open_3_fri?: SortOrder
    close_3_fri?: SortOrder
    open_1_sat?: SortOrder
    close_1_sat?: SortOrder
    open_2_sat?: SortOrder
    close_2_sat?: SortOrder
    open_3_sat?: SortOrder
    close_3_sat?: SortOrder
    open_1_sun?: SortOrder
    close_1_sun?: SortOrder
    open_2_sun?: SortOrder
    close_2_sun?: SortOrder
    open_3_sun?: SortOrder
    close_3_sun?: SortOrder
    loc_type_1?: SortOrder
    loc_type_2?: SortOrder
    city_name?: SortOrder
    category_id?: SortOrder
  }

  export type LocationRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type location_descriptionLocation_idLocaleCompoundUniqueInput = {
    location_id: string
    locale: string
  }

  export type location_descriptionCountOrderByAggregateInput = {
    location_id?: SortOrder
    locale?: SortOrder
    description?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    address_3?: SortOrder
  }

  export type location_descriptionMaxOrderByAggregateInput = {
    location_id?: SortOrder
    locale?: SortOrder
    description?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    address_3?: SortOrder
  }

  export type location_descriptionMinOrderByAggregateInput = {
    location_id?: SortOrder
    locale?: SortOrder
    description?: SortOrder
    address_1?: SortOrder
    address_2?: SortOrder
    address_3?: SortOrder
  }

  export type LocalesRelationFilter = {
    is?: localesWhereInput
    isNot?: localesWhereInput
  }

  export type translationLocale_idTagCompoundUniqueInput = {
    locale_id: number
    tag: string
  }

  export type translationCountOrderByAggregateInput = {
    locale_id?: SortOrder
    message?: SortOrder
    tag?: SortOrder
  }

  export type translationAvgOrderByAggregateInput = {
    locale_id?: SortOrder
  }

  export type translationMaxOrderByAggregateInput = {
    locale_id?: SortOrder
    message?: SortOrder
    tag?: SortOrder
  }

  export type translationMinOrderByAggregateInput = {
    locale_id?: SortOrder
    message?: SortOrder
    tag?: SortOrder
  }

  export type translationSumOrderByAggregateInput = {
    locale_id?: SortOrder
  }

  export type AirportsListRelationFilter = {
    every?: airportsWhereInput
    some?: airportsWhereInput
    none?: airportsWhereInput
  }

  export type CitiesListRelationFilter = {
    every?: citiesWhereInput
    some?: citiesWhereInput
    none?: citiesWhereInput
  }

  export type Countries_translationListRelationFilter = {
    every?: countries_translationWhereInput
    some?: countries_translationWhereInput
    none?: countries_translationWhereInput
  }

  export type airportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type countries_translationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type countriesCountOrderByAggregateInput = {
    code?: SortOrder
    code_3?: SortOrder
    name?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
  }

  export type countriesMaxOrderByAggregateInput = {
    code?: SortOrder
    code_3?: SortOrder
    name?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
  }

  export type countriesMinOrderByAggregateInput = {
    code?: SortOrder
    code_3?: SortOrder
    name?: SortOrder
    continent?: SortOrder
    currency?: SortOrder
  }

  export type countries_translationCountry_codeLocaleCompoundUniqueInput = {
    country_code: string
    locale: string
  }

  export type countries_translationCountOrderByAggregateInput = {
    country_code?: SortOrder
    locale?: SortOrder
    country_name?: SortOrder
  }

  export type countries_translationMaxOrderByAggregateInput = {
    country_code?: SortOrder
    locale?: SortOrder
    country_name?: SortOrder
  }

  export type countries_translationMinOrderByAggregateInput = {
    country_code?: SortOrder
    locale?: SortOrder
    country_name?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: locationWhereInput
    some?: locationWhereInput
    none?: locationWhereInput
  }

  export type locationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type location_type_1CountOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type location_type_1MaxOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type location_type_1MinOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type location_type_2CountOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type location_type_2MaxOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type location_type_2MinOrderByAggregateInput = {
    type?: SortOrder
    description?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type Commission_settingListRelationFilter = {
    every?: commission_settingWhereInput
    some?: commission_settingWhereInput
    none?: commission_settingWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: reservationWhereInput
    some?: reservationWhereInput
    none?: reservationWhereInput
  }

  export type commission_settingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vendorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
  }

  export type vendorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
  }

  export type vendorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type airportsCountOrderByAggregateInput = {
    iata_code?: SortOrder
    country_code?: SortOrder
    icao_code?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
  }

  export type airportsAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
  }

  export type airportsMaxOrderByAggregateInput = {
    iata_code?: SortOrder
    country_code?: SortOrder
    icao_code?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
  }

  export type airportsMinOrderByAggregateInput = {
    iata_code?: SortOrder
    country_code?: SortOrder
    icao_code?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
  }

  export type airportsSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    id?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ReservationRelationFilter = {
    is?: reservationWhereInput | null
    isNot?: reservationWhereInput | null
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type paymentCountOrderByAggregateInput = {
    order_id?: SortOrder
    user_id?: SortOrder
    IMS_commission?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    pay_type?: SortOrder
    exchange_rate?: SortOrder
    first_name?: SortOrder
    korean_name?: SortOrder
    last_name?: SortOrder
    paid_agency?: SortOrder
    paid_supplier_date?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    reservation_id?: SortOrder
    supplier?: SortOrder
    imp_uid?: SortOrder
    merchant_uid?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
    paid_agency_date?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    user_id?: SortOrder
    IMS_commission?: SortOrder
    exchange_rate?: SortOrder
    paid_agency?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    order_id?: SortOrder
    user_id?: SortOrder
    IMS_commission?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    pay_type?: SortOrder
    exchange_rate?: SortOrder
    first_name?: SortOrder
    korean_name?: SortOrder
    last_name?: SortOrder
    paid_agency?: SortOrder
    paid_supplier_date?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    reservation_id?: SortOrder
    supplier?: SortOrder
    imp_uid?: SortOrder
    merchant_uid?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
    paid_agency_date?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    order_id?: SortOrder
    user_id?: SortOrder
    IMS_commission?: SortOrder
    agency_id?: SortOrder
    agency_name?: SortOrder
    pay_type?: SortOrder
    exchange_rate?: SortOrder
    first_name?: SortOrder
    korean_name?: SortOrder
    last_name?: SortOrder
    paid_agency?: SortOrder
    paid_supplier_date?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    currency?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    reservation_id?: SortOrder
    supplier?: SortOrder
    imp_uid?: SortOrder
    merchant_uid?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
    paid_agency_date?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    user_id?: SortOrder
    IMS_commission?: SortOrder
    exchange_rate?: SortOrder
    paid_agency?: SortOrder
    paid_supplier?: SortOrder
    basic_rate?: SortOrder
    net?: SortOrder
    commission?: SortOrder
    service_total_amount?: SortOrder
    service_rate?: SortOrder
    etc_rate?: SortOrder
    total_amount?: SortOrder
    pg_amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type Exchange_rate_historyListRelationFilter = {
    every?: exchange_rate_historyWhereInput
    some?: exchange_rate_historyWhereInput
    none?: exchange_rate_historyWhereInput
  }

  export type exchange_rate_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type exchange_ratesFrom_codeTo_codeCompoundUniqueInput = {
    from_code: string
    to_code: string
  }

  export type exchange_ratesCountOrderByAggregateInput = {
    id?: SortOrder
    from_code?: SortOrder
    to_code?: SortOrder
    rate?: SortOrder
  }

  export type exchange_ratesAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type exchange_ratesMaxOrderByAggregateInput = {
    id?: SortOrder
    from_code?: SortOrder
    to_code?: SortOrder
    rate?: SortOrder
  }

  export type exchange_ratesMinOrderByAggregateInput = {
    id?: SortOrder
    from_code?: SortOrder
    to_code?: SortOrder
    rate?: SortOrder
  }

  export type exchange_ratesSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type Admin_roles_permissionsListRelationFilter = {
    every?: admin_roles_permissionsWhereInput
    some?: admin_roles_permissionsWhereInput
    none?: admin_roles_permissionsWhereInput
  }

  export type admin_roles_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admin_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type admin_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type admin_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type admin_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type admin_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Admin_usersRelationFilter = {
    is?: admin_usersWhereInput | null
    isNot?: admin_usersWhereInput | null
  }

  export type Admin_users_rolesListRelationFilter = {
    every?: admin_users_rolesWhereInput
    some?: admin_users_rolesWhereInput
    none?: admin_users_rolesWhereInput
  }

  export type admin_users_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admin_rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type admin_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type admin_rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type admin_rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type admin_rolesSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    modified_by?: SortOrder
    deleted?: SortOrder
  }

  export type Admin_permissionsRelationFilter = {
    is?: admin_permissionsWhereInput
    isNot?: admin_permissionsWhereInput
  }

  export type Admin_rolesRelationFilter = {
    is?: admin_rolesWhereInput
    isNot?: admin_rolesWhereInput
  }

  export type admin_roles_permissionsPermission_idRole_idCompoundUniqueInput = {
    permission_id: number
    role_id: number
  }

  export type admin_roles_permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_roles_permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_roles_permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_roles_permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_roles_permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type AgenciesRelationFilter = {
    is?: agenciesWhereInput | null
    isNot?: agenciesWhereInput | null
  }

  export type Admin_rolesListRelationFilter = {
    every?: admin_rolesWhereInput
    some?: admin_rolesWhereInput
    none?: admin_rolesWhereInput
  }

  export type Admin_usersListRelationFilter = {
    every?: admin_usersWhereInput
    some?: admin_usersWhereInput
    none?: admin_usersWhereInput
  }

  export type admin_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admin_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admin_usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_mobile?: SortOrder
    address?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    modified_by?: SortOrder
    status?: SortOrder
    agency_id?: SortOrder
  }

  export type admin_usersAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    modified_by?: SortOrder
  }

  export type admin_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_mobile?: SortOrder
    address?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    modified_by?: SortOrder
    status?: SortOrder
    agency_id?: SortOrder
  }

  export type admin_usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_mobile?: SortOrder
    address?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    modified_by?: SortOrder
    status?: SortOrder
    agency_id?: SortOrder
  }

  export type admin_usersSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
    deleted?: SortOrder
    modified_by?: SortOrder
  }

  export type admin_users_rolesUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type admin_users_rolesCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_users_rolesAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_users_rolesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_users_rolesMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type admin_users_rolesSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type filesCountOrderByAggregateInput = {
    id?: SortOrder
    file_key?: SortOrder
    file_url?: SortOrder
  }

  export type filesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type filesMaxOrderByAggregateInput = {
    id?: SortOrder
    file_key?: SortOrder
    file_url?: SortOrder
  }

  export type filesMinOrderByAggregateInput = {
    id?: SortOrder
    file_key?: SortOrder
    file_url?: SortOrder
  }

  export type filesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type settingsCategoryNameCompoundUniqueInput = {
    category: string
    name: string
  }

  export type settingsCountOrderByAggregateInput = {
    category?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    category?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    category?: SortOrder
    name?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersPhonePhone_prefixCompoundUniqueInput = {
    phone: string
    phone_prefix: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    phone?: SortOrder
    login_type?: SortOrder
    external_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_prefix?: SortOrder
    refund_bank?: SortOrder
    refund_account_number?: SortOrder
    refund_account_holder?: SortOrder
    address?: SortOrder
    hertz_membership?: SortOrder
    airline?: SortOrder
    mileage_number?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
    birthdate?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    deleted?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    phone?: SortOrder
    login_type?: SortOrder
    external_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_prefix?: SortOrder
    refund_bank?: SortOrder
    refund_account_number?: SortOrder
    refund_account_holder?: SortOrder
    address?: SortOrder
    hertz_membership?: SortOrder
    airline?: SortOrder
    mileage_number?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
    birthdate?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    hash_pass?: SortOrder
    created_date?: SortOrder
    modified_date?: SortOrder
    deleted?: SortOrder
    hash_rt?: SortOrder
    phone?: SortOrder
    login_type?: SortOrder
    external_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone_prefix?: SortOrder
    refund_bank?: SortOrder
    refund_account_number?: SortOrder
    refund_account_holder?: SortOrder
    address?: SortOrder
    hertz_membership?: SortOrder
    airline?: SortOrder
    mileage_number?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
    birthdate?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    deleted?: SortOrder
    mailing_email?: SortOrder
    mailing_text_msg?: SortOrder
  }

  export type Price_codesRelationFilter = {
    is?: price_codesWhereInput
    isNot?: price_codesWhereInput
  }

  export type ServicesRelationFilter = {
    is?: servicesWhereInput
    isNot?: servicesWhereInput
  }

  export type packagesPrice_idService_idCompoundUniqueInput = {
    price_id: string
    service_id: string
  }

  export type packagesCountOrderByAggregateInput = {
    price_id?: SortOrder
    service_id?: SortOrder
  }

  export type packagesMaxOrderByAggregateInput = {
    price_id?: SortOrder
    service_id?: SortOrder
  }

  export type packagesMinOrderByAggregateInput = {
    price_id?: SortOrder
    service_id?: SortOrder
  }

  export type PackagesListRelationFilter = {
    every?: packagesWhereInput
    some?: packagesWhereInput
    none?: packagesWhereInput
  }

  export type packagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type price_codesPrice_codeCountry_codeCompoundUniqueInput = {
    price_code: string
    country_code: string
  }

  export type price_codesCountOrderByAggregateInput = {
    id?: SortOrder
    price_code?: SortOrder
    country_code?: SortOrder
    name?: SortOrder
    price_type?: SortOrder
    vendor_id?: SortOrder
    ITCode?: SortOrder
    cdpNumber?: SortOrder
    show?: SortOrder
    insurance?: SortOrder
    ko_name?: SortOrder
  }

  export type price_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    price_code?: SortOrder
    country_code?: SortOrder
    name?: SortOrder
    price_type?: SortOrder
    vendor_id?: SortOrder
    ITCode?: SortOrder
    cdpNumber?: SortOrder
    show?: SortOrder
    insurance?: SortOrder
    ko_name?: SortOrder
  }

  export type price_codesMinOrderByAggregateInput = {
    id?: SortOrder
    price_code?: SortOrder
    country_code?: SortOrder
    name?: SortOrder
    price_type?: SortOrder
    vendor_id?: SortOrder
    ITCode?: SortOrder
    cdpNumber?: SortOrder
    show?: SortOrder
    insurance?: SortOrder
    ko_name?: SortOrder
  }

  export type reservationCountOrderByAggregateInput = {
    supplier?: SortOrder
    agent_name?: SortOrder
    agent?: SortOrder
    date_request?: SortOrder
    res_status?: SortOrder
    invoice?: SortOrder
    res_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    pickup_loc?: SortOrder
    return_loc?: SortOrder
    pickup_datetime?: SortOrder
    return_datetime?: SortOrder
    pay_type?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    user_id?: SortOrder
    car_model?: SortOrder
    extra_equipmens?: SortOrder
    insurance_info?: SortOrder
    office_address?: SortOrder
    office_name?: SortOrder
    office_time?: SortOrder
    phone_code?: SortOrder
    phone_number?: SortOrder
    services?: SortOrder
    size_car?: SortOrder
    type_car?: SortOrder
    date_cancel?: SortOrder
    email?: SortOrder
    flight_brand?: SortOrder
    flight_number?: SortOrder
    frequent_flyer?: SortOrder
    hertz_membership?: SortOrder
    office_second_address?: SortOrder
    office_second_name?: SortOrder
    office_second_time?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    tax?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
  }

  export type reservationAvgOrderByAggregateInput = {
    exchange_rate?: SortOrder
    user_id?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
  }

  export type reservationMaxOrderByAggregateInput = {
    supplier?: SortOrder
    agent_name?: SortOrder
    agent?: SortOrder
    date_request?: SortOrder
    res_status?: SortOrder
    invoice?: SortOrder
    res_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    pickup_loc?: SortOrder
    return_loc?: SortOrder
    pickup_datetime?: SortOrder
    return_datetime?: SortOrder
    pay_type?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    user_id?: SortOrder
    car_model?: SortOrder
    extra_equipmens?: SortOrder
    insurance_info?: SortOrder
    office_address?: SortOrder
    office_name?: SortOrder
    office_time?: SortOrder
    phone_code?: SortOrder
    phone_number?: SortOrder
    services?: SortOrder
    size_car?: SortOrder
    type_car?: SortOrder
    date_cancel?: SortOrder
    email?: SortOrder
    flight_brand?: SortOrder
    flight_number?: SortOrder
    frequent_flyer?: SortOrder
    hertz_membership?: SortOrder
    office_second_address?: SortOrder
    office_second_name?: SortOrder
    office_second_time?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    tax?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
  }

  export type reservationMinOrderByAggregateInput = {
    supplier?: SortOrder
    agent_name?: SortOrder
    agent?: SortOrder
    date_request?: SortOrder
    res_status?: SortOrder
    invoice?: SortOrder
    res_id?: SortOrder
    korean_name?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    pickup_loc?: SortOrder
    return_loc?: SortOrder
    pickup_datetime?: SortOrder
    return_datetime?: SortOrder
    pay_type?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    user_id?: SortOrder
    car_model?: SortOrder
    extra_equipmens?: SortOrder
    insurance_info?: SortOrder
    office_address?: SortOrder
    office_name?: SortOrder
    office_time?: SortOrder
    phone_code?: SortOrder
    phone_number?: SortOrder
    services?: SortOrder
    size_car?: SortOrder
    type_car?: SortOrder
    date_cancel?: SortOrder
    email?: SortOrder
    flight_brand?: SortOrder
    flight_number?: SortOrder
    frequent_flyer?: SortOrder
    hertz_membership?: SortOrder
    office_second_address?: SortOrder
    office_second_name?: SortOrder
    office_second_time?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    tax?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
  }

  export type reservationSumOrderByAggregateInput = {
    exchange_rate?: SortOrder
    user_id?: SortOrder
    dropFee?: SortOrder
    rate_amount?: SortOrder
    rate_foreigner_amount?: SortOrder
    total_amount?: SortOrder
    total_foreigner_amount?: SortOrder
  }

  export type servicesCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    ko_description?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type servicesAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type servicesMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    ko_description?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type servicesMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    ko_description?: SortOrder
    details?: SortOrder
    order?: SortOrder
  }

  export type servicesSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type agenciesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    created_date?: SortOrder
  }

  export type agenciesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    created_date?: SortOrder
  }

  export type agenciesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    created_date?: SortOrder
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type commission_settingCountOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    agency?: SortOrder
    payment_type?: SortOrder
    tag?: SortOrder
    calculation_type?: SortOrder
    amount?: SortOrder
  }

  export type commission_settingAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type commission_settingMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    agency?: SortOrder
    payment_type?: SortOrder
    tag?: SortOrder
    calculation_type?: SortOrder
    amount?: SortOrder
  }

  export type commission_settingMinOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    agency?: SortOrder
    payment_type?: SortOrder
    tag?: SortOrder
    calculation_type?: SortOrder
    amount?: SortOrder
  }

  export type commission_settingSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type couponsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    coupon_name?: SortOrder
    brand?: SortOrder
    destination?: SortOrder
    offer_description?: SortOrder
    corporate_discount_number?: SortOrder
    promotion_code?: SortOrder
    min_days?: SortOrder
    car_group?: SortOrder
    pickup_start_time?: SortOrder
    pickup_end_time?: SortOrder
    order_start_time?: SortOrder
    order_end_time?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type couponsAvgOrderByAggregateInput = {
    id?: SortOrder
    min_days?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
  }

  export type couponsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    coupon_name?: SortOrder
    brand?: SortOrder
    destination?: SortOrder
    offer_description?: SortOrder
    corporate_discount_number?: SortOrder
    promotion_code?: SortOrder
    min_days?: SortOrder
    car_group?: SortOrder
    pickup_start_time?: SortOrder
    pickup_end_time?: SortOrder
    order_start_time?: SortOrder
    order_end_time?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type couponsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    coupon_name?: SortOrder
    brand?: SortOrder
    destination?: SortOrder
    offer_description?: SortOrder
    corporate_discount_number?: SortOrder
    promotion_code?: SortOrder
    min_days?: SortOrder
    car_group?: SortOrder
    pickup_start_time?: SortOrder
    pickup_end_time?: SortOrder
    order_start_time?: SortOrder
    order_end_time?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
    status?: SortOrder
    remark?: SortOrder
  }

  export type couponsSumOrderByAggregateInput = {
    id?: SortOrder
    min_days?: SortOrder
    issued_count?: SortOrder
    used_count?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type promotion_codeCountryVendor_idCompoundUniqueInput = {
    country: string
    vendor_id: string
  }

  export type promotion_codeCountOrderByAggregateInput = {
    cdp?: SortOrder
    pc?: SortOrder
    vendor_id?: SortOrder
    country?: SortOrder
    name?: SortOrder
  }

  export type promotion_codeMaxOrderByAggregateInput = {
    cdp?: SortOrder
    pc?: SortOrder
    vendor_id?: SortOrder
    country?: SortOrder
    name?: SortOrder
  }

  export type promotion_codeMinOrderByAggregateInput = {
    cdp?: SortOrder
    pc?: SortOrder
    vendor_id?: SortOrder
    country?: SortOrder
    name?: SortOrder
  }

  export type Subject_faqRelationFilter = {
    is?: subject_faqWhereInput | null
    isNot?: subject_faqWhereInput | null
  }

  export type Keyword_faqListRelationFilter = {
    every?: keyword_faqWhereInput
    some?: keyword_faqWhereInput
    none?: keyword_faqWhereInput
  }

  export type keyword_faqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type faqCountOrderByAggregateInput = {
    id?: SortOrder
    question_kr?: SortOrder
    question_us?: SortOrder
    answer_kr?: SortOrder
    answer_us?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
  }

  export type faqAvgOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
  }

  export type faqMaxOrderByAggregateInput = {
    id?: SortOrder
    question_kr?: SortOrder
    question_us?: SortOrder
    answer_kr?: SortOrder
    answer_us?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
  }

  export type faqMinOrderByAggregateInput = {
    id?: SortOrder
    question_kr?: SortOrder
    question_us?: SortOrder
    answer_kr?: SortOrder
    answer_us?: SortOrder
    status?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
  }

  export type faqSumOrderByAggregateInput = {
    id?: SortOrder
    sort_order?: SortOrder
    subject_id?: SortOrder
  }

  export type error_messagesCountOrderByAggregateInput = {
    error_code?: SortOrder
    english_message?: SortOrder
    korean_message?: SortOrder
  }

  export type error_messagesMaxOrderByAggregateInput = {
    error_code?: SortOrder
    english_message?: SortOrder
    korean_message?: SortOrder
  }

  export type error_messagesMinOrderByAggregateInput = {
    error_code?: SortOrder
    english_message?: SortOrder
    korean_message?: SortOrder
  }

  export type Exchange_ratesRelationFilter = {
    is?: exchange_ratesWhereInput
    isNot?: exchange_ratesWhereInput
  }

  export type exchange_rate_historyExchange_rate_idDateCompoundUniqueInput = {
    exchange_rate_id: number
    date: Date | string
  }

  export type exchange_rate_historyCountOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type exchange_rate_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
  }

  export type exchange_rate_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type exchange_rate_historyMinOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
    date?: SortOrder
  }

  export type exchange_rate_historySumOrderByAggregateInput = {
    id?: SortOrder
    exchange_rate_id?: SortOrder
    rate?: SortOrder
  }

  export type FaqListRelationFilter = {
    every?: faqWhereInput
    some?: faqWhereInput
    none?: faqWhereInput
  }

  export type faqOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subject_faqCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type subject_faqAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type subject_faqMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type subject_faqMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type subject_faqSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FaqRelationFilter = {
    is?: faqWhereInput
    isNot?: faqWhereInput
  }

  export type keyword_faqCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    faq_id?: SortOrder
  }

  export type keyword_faqAvgOrderByAggregateInput = {
    id?: SortOrder
    faq_id?: SortOrder
  }

  export type keyword_faqMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    faq_id?: SortOrder
  }

  export type keyword_faqMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    faq_id?: SortOrder
  }

  export type keyword_faqSumOrderByAggregateInput = {
    id?: SortOrder
    faq_id?: SortOrder
  }

  export type cities_locationsCity_codeLocation_idCompoundUniqueInput = {
    city_code: string
    location_id: string
  }

  export type cities_locationsCountOrderByAggregateInput = {
    city_code?: SortOrder
    location_id?: SortOrder
  }

  export type cities_locationsMaxOrderByAggregateInput = {
    city_code?: SortOrder
    location_id?: SortOrder
  }

  export type cities_locationsMinOrderByAggregateInput = {
    city_code?: SortOrder
    location_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type countriesCreateNestedOneWithoutCitiesInput = {
    create?: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCitiesInput
    connect?: countriesWhereUniqueInput
  }

  export type cities_translationCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<cities_translationCreateWithoutCitiesInput>, Enumerable<cities_translationUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<cities_translationCreateOrConnectWithoutCitiesInput>
    createMany?: cities_translationCreateManyCitiesInputEnvelope
    connect?: Enumerable<cities_translationWhereUniqueInput>
  }

  export type cities_translationUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<Enumerable<cities_translationCreateWithoutCitiesInput>, Enumerable<cities_translationUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<cities_translationCreateOrConnectWithoutCitiesInput>
    createMany?: cities_translationCreateManyCitiesInputEnvelope
    connect?: Enumerable<cities_translationWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type countriesUpdateOneWithoutCitiesNestedInput = {
    create?: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCitiesInput
    upsert?: countriesUpsertWithoutCitiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: countriesWhereUniqueInput
    update?: XOR<countriesUpdateWithoutCitiesInput, countriesUncheckedUpdateWithoutCitiesInput>
  }

  export type cities_translationUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<Enumerable<cities_translationCreateWithoutCitiesInput>, Enumerable<cities_translationUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<cities_translationCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<cities_translationUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: cities_translationCreateManyCitiesInputEnvelope
    set?: Enumerable<cities_translationWhereUniqueInput>
    disconnect?: Enumerable<cities_translationWhereUniqueInput>
    delete?: Enumerable<cities_translationWhereUniqueInput>
    connect?: Enumerable<cities_translationWhereUniqueInput>
    update?: Enumerable<cities_translationUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<cities_translationUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<cities_translationScalarWhereInput>
  }

  export type cities_translationUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<Enumerable<cities_translationCreateWithoutCitiesInput>, Enumerable<cities_translationUncheckedCreateWithoutCitiesInput>>
    connectOrCreate?: Enumerable<cities_translationCreateOrConnectWithoutCitiesInput>
    upsert?: Enumerable<cities_translationUpsertWithWhereUniqueWithoutCitiesInput>
    createMany?: cities_translationCreateManyCitiesInputEnvelope
    set?: Enumerable<cities_translationWhereUniqueInput>
    disconnect?: Enumerable<cities_translationWhereUniqueInput>
    delete?: Enumerable<cities_translationWhereUniqueInput>
    connect?: Enumerable<cities_translationWhereUniqueInput>
    update?: Enumerable<cities_translationUpdateWithWhereUniqueWithoutCitiesInput>
    updateMany?: Enumerable<cities_translationUpdateManyWithWhereWithoutCitiesInput>
    deleteMany?: Enumerable<cities_translationScalarWhereInput>
  }

  export type citiesCreateNestedOneWithoutCities_translationInput = {
    create?: XOR<citiesCreateWithoutCities_translationInput, citiesUncheckedCreateWithoutCities_translationInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCities_translationInput
    connect?: citiesWhereUniqueInput
  }

  export type citiesUpdateOneRequiredWithoutCities_translationNestedInput = {
    create?: XOR<citiesCreateWithoutCities_translationInput, citiesUncheckedCreateWithoutCities_translationInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCities_translationInput
    upsert?: citiesUpsertWithoutCities_translationInput
    connect?: citiesWhereUniqueInput
    update?: XOR<citiesUpdateWithoutCities_translationInput, citiesUncheckedUpdateWithoutCities_translationInput>
  }

  export type translationCreateNestedManyWithoutLocalesInput = {
    create?: XOR<Enumerable<translationCreateWithoutLocalesInput>, Enumerable<translationUncheckedCreateWithoutLocalesInput>>
    connectOrCreate?: Enumerable<translationCreateOrConnectWithoutLocalesInput>
    createMany?: translationCreateManyLocalesInputEnvelope
    connect?: Enumerable<translationWhereUniqueInput>
  }

  export type translationUncheckedCreateNestedManyWithoutLocalesInput = {
    create?: XOR<Enumerable<translationCreateWithoutLocalesInput>, Enumerable<translationUncheckedCreateWithoutLocalesInput>>
    connectOrCreate?: Enumerable<translationCreateOrConnectWithoutLocalesInput>
    createMany?: translationCreateManyLocalesInputEnvelope
    connect?: Enumerable<translationWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type translationUpdateManyWithoutLocalesNestedInput = {
    create?: XOR<Enumerable<translationCreateWithoutLocalesInput>, Enumerable<translationUncheckedCreateWithoutLocalesInput>>
    connectOrCreate?: Enumerable<translationCreateOrConnectWithoutLocalesInput>
    upsert?: Enumerable<translationUpsertWithWhereUniqueWithoutLocalesInput>
    createMany?: translationCreateManyLocalesInputEnvelope
    set?: Enumerable<translationWhereUniqueInput>
    disconnect?: Enumerable<translationWhereUniqueInput>
    delete?: Enumerable<translationWhereUniqueInput>
    connect?: Enumerable<translationWhereUniqueInput>
    update?: Enumerable<translationUpdateWithWhereUniqueWithoutLocalesInput>
    updateMany?: Enumerable<translationUpdateManyWithWhereWithoutLocalesInput>
    deleteMany?: Enumerable<translationScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type translationUncheckedUpdateManyWithoutLocalesNestedInput = {
    create?: XOR<Enumerable<translationCreateWithoutLocalesInput>, Enumerable<translationUncheckedCreateWithoutLocalesInput>>
    connectOrCreate?: Enumerable<translationCreateOrConnectWithoutLocalesInput>
    upsert?: Enumerable<translationUpsertWithWhereUniqueWithoutLocalesInput>
    createMany?: translationCreateManyLocalesInputEnvelope
    set?: Enumerable<translationWhereUniqueInput>
    disconnect?: Enumerable<translationWhereUniqueInput>
    delete?: Enumerable<translationWhereUniqueInput>
    connect?: Enumerable<translationWhereUniqueInput>
    update?: Enumerable<translationUpdateWithWhereUniqueWithoutLocalesInput>
    updateMany?: Enumerable<translationUpdateManyWithWhereWithoutLocalesInput>
    deleteMany?: Enumerable<translationScalarWhereInput>
  }

  export type categoriesCreateNestedOneWithoutLocationInput = {
    create?: XOR<categoriesCreateWithoutLocationInput, categoriesUncheckedCreateWithoutLocationInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutLocationInput
    connect?: categoriesWhereUniqueInput
  }

  export type location_type_1CreateNestedOneWithoutLocationInput = {
    create?: XOR<location_type_1CreateWithoutLocationInput, location_type_1UncheckedCreateWithoutLocationInput>
    connectOrCreate?: location_type_1CreateOrConnectWithoutLocationInput
    connect?: location_type_1WhereUniqueInput
  }

  export type location_type_2CreateNestedOneWithoutLocationInput = {
    create?: XOR<location_type_2CreateWithoutLocationInput, location_type_2UncheckedCreateWithoutLocationInput>
    connectOrCreate?: location_type_2CreateOrConnectWithoutLocationInput
    connect?: location_type_2WhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutLocationInput = {
    create?: XOR<vendorsCreateWithoutLocationInput, vendorsUncheckedCreateWithoutLocationInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutLocationInput
    connect?: vendorsWhereUniqueInput
  }

  export type location_descriptionCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<location_descriptionCreateWithoutLocationInput>, Enumerable<location_descriptionUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<location_descriptionCreateOrConnectWithoutLocationInput>
    createMany?: location_descriptionCreateManyLocationInputEnvelope
    connect?: Enumerable<location_descriptionWhereUniqueInput>
  }

  export type location_descriptionUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<location_descriptionCreateWithoutLocationInput>, Enumerable<location_descriptionUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<location_descriptionCreateOrConnectWithoutLocationInput>
    createMany?: location_descriptionCreateManyLocationInputEnvelope
    connect?: Enumerable<location_descriptionWhereUniqueInput>
  }

  export type categoriesUpdateOneWithoutLocationNestedInput = {
    create?: XOR<categoriesCreateWithoutLocationInput, categoriesUncheckedCreateWithoutLocationInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutLocationInput
    upsert?: categoriesUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<categoriesUpdateWithoutLocationInput, categoriesUncheckedUpdateWithoutLocationInput>
  }

  export type location_type_1UpdateOneWithoutLocationNestedInput = {
    create?: XOR<location_type_1CreateWithoutLocationInput, location_type_1UncheckedCreateWithoutLocationInput>
    connectOrCreate?: location_type_1CreateOrConnectWithoutLocationInput
    upsert?: location_type_1UpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: location_type_1WhereUniqueInput
    update?: XOR<location_type_1UpdateWithoutLocationInput, location_type_1UncheckedUpdateWithoutLocationInput>
  }

  export type location_type_2UpdateOneWithoutLocationNestedInput = {
    create?: XOR<location_type_2CreateWithoutLocationInput, location_type_2UncheckedCreateWithoutLocationInput>
    connectOrCreate?: location_type_2CreateOrConnectWithoutLocationInput
    upsert?: location_type_2UpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: location_type_2WhereUniqueInput
    update?: XOR<location_type_2UpdateWithoutLocationInput, location_type_2UncheckedUpdateWithoutLocationInput>
  }

  export type vendorsUpdateOneRequiredWithoutLocationNestedInput = {
    create?: XOR<vendorsCreateWithoutLocationInput, vendorsUncheckedCreateWithoutLocationInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutLocationInput
    upsert?: vendorsUpsertWithoutLocationInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutLocationInput, vendorsUncheckedUpdateWithoutLocationInput>
  }

  export type location_descriptionUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<location_descriptionCreateWithoutLocationInput>, Enumerable<location_descriptionUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<location_descriptionCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<location_descriptionUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: location_descriptionCreateManyLocationInputEnvelope
    set?: Enumerable<location_descriptionWhereUniqueInput>
    disconnect?: Enumerable<location_descriptionWhereUniqueInput>
    delete?: Enumerable<location_descriptionWhereUniqueInput>
    connect?: Enumerable<location_descriptionWhereUniqueInput>
    update?: Enumerable<location_descriptionUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<location_descriptionUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<location_descriptionScalarWhereInput>
  }

  export type location_descriptionUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<location_descriptionCreateWithoutLocationInput>, Enumerable<location_descriptionUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<location_descriptionCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<location_descriptionUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: location_descriptionCreateManyLocationInputEnvelope
    set?: Enumerable<location_descriptionWhereUniqueInput>
    disconnect?: Enumerable<location_descriptionWhereUniqueInput>
    delete?: Enumerable<location_descriptionWhereUniqueInput>
    connect?: Enumerable<location_descriptionWhereUniqueInput>
    update?: Enumerable<location_descriptionUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<location_descriptionUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<location_descriptionScalarWhereInput>
  }

  export type locationCreateNestedOneWithoutLocation_descriptionInput = {
    create?: XOR<locationCreateWithoutLocation_descriptionInput, locationUncheckedCreateWithoutLocation_descriptionInput>
    connectOrCreate?: locationCreateOrConnectWithoutLocation_descriptionInput
    connect?: locationWhereUniqueInput
  }

  export type locationUpdateOneRequiredWithoutLocation_descriptionNestedInput = {
    create?: XOR<locationCreateWithoutLocation_descriptionInput, locationUncheckedCreateWithoutLocation_descriptionInput>
    connectOrCreate?: locationCreateOrConnectWithoutLocation_descriptionInput
    upsert?: locationUpsertWithoutLocation_descriptionInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutLocation_descriptionInput, locationUncheckedUpdateWithoutLocation_descriptionInput>
  }

  export type localesCreateNestedOneWithoutTranslationInput = {
    create?: XOR<localesCreateWithoutTranslationInput, localesUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: localesCreateOrConnectWithoutTranslationInput
    connect?: localesWhereUniqueInput
  }

  export type localesUpdateOneRequiredWithoutTranslationNestedInput = {
    create?: XOR<localesCreateWithoutTranslationInput, localesUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: localesCreateOrConnectWithoutTranslationInput
    upsert?: localesUpsertWithoutTranslationInput
    connect?: localesWhereUniqueInput
    update?: XOR<localesUpdateWithoutTranslationInput, localesUncheckedUpdateWithoutTranslationInput>
  }

  export type airportsCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<airportsCreateWithoutCountriesInput>, Enumerable<airportsUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<airportsCreateOrConnectWithoutCountriesInput>
    createMany?: airportsCreateManyCountriesInputEnvelope
    connect?: Enumerable<airportsWhereUniqueInput>
  }

  export type citiesCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
  }

  export type countries_translationCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<countries_translationCreateWithoutCountriesInput>, Enumerable<countries_translationUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<countries_translationCreateOrConnectWithoutCountriesInput>
    createMany?: countries_translationCreateManyCountriesInputEnvelope
    connect?: Enumerable<countries_translationWhereUniqueInput>
  }

  export type airportsUncheckedCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<airportsCreateWithoutCountriesInput>, Enumerable<airportsUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<airportsCreateOrConnectWithoutCountriesInput>
    createMany?: airportsCreateManyCountriesInputEnvelope
    connect?: Enumerable<airportsWhereUniqueInput>
  }

  export type citiesUncheckedCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    connect?: Enumerable<citiesWhereUniqueInput>
  }

  export type countries_translationUncheckedCreateNestedManyWithoutCountriesInput = {
    create?: XOR<Enumerable<countries_translationCreateWithoutCountriesInput>, Enumerable<countries_translationUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<countries_translationCreateOrConnectWithoutCountriesInput>
    createMany?: countries_translationCreateManyCountriesInputEnvelope
    connect?: Enumerable<countries_translationWhereUniqueInput>
  }

  export type airportsUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<airportsCreateWithoutCountriesInput>, Enumerable<airportsUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<airportsCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<airportsUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: airportsCreateManyCountriesInputEnvelope
    set?: Enumerable<airportsWhereUniqueInput>
    disconnect?: Enumerable<airportsWhereUniqueInput>
    delete?: Enumerable<airportsWhereUniqueInput>
    connect?: Enumerable<airportsWhereUniqueInput>
    update?: Enumerable<airportsUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<airportsUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<airportsScalarWhereInput>
  }

  export type citiesUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<citiesUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    set?: Enumerable<citiesWhereUniqueInput>
    disconnect?: Enumerable<citiesWhereUniqueInput>
    delete?: Enumerable<citiesWhereUniqueInput>
    connect?: Enumerable<citiesWhereUniqueInput>
    update?: Enumerable<citiesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<citiesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<citiesScalarWhereInput>
  }

  export type countries_translationUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<countries_translationCreateWithoutCountriesInput>, Enumerable<countries_translationUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<countries_translationCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<countries_translationUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: countries_translationCreateManyCountriesInputEnvelope
    set?: Enumerable<countries_translationWhereUniqueInput>
    disconnect?: Enumerable<countries_translationWhereUniqueInput>
    delete?: Enumerable<countries_translationWhereUniqueInput>
    connect?: Enumerable<countries_translationWhereUniqueInput>
    update?: Enumerable<countries_translationUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<countries_translationUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<countries_translationScalarWhereInput>
  }

  export type airportsUncheckedUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<airportsCreateWithoutCountriesInput>, Enumerable<airportsUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<airportsCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<airportsUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: airportsCreateManyCountriesInputEnvelope
    set?: Enumerable<airportsWhereUniqueInput>
    disconnect?: Enumerable<airportsWhereUniqueInput>
    delete?: Enumerable<airportsWhereUniqueInput>
    connect?: Enumerable<airportsWhereUniqueInput>
    update?: Enumerable<airportsUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<airportsUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<airportsScalarWhereInput>
  }

  export type citiesUncheckedUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<citiesCreateWithoutCountriesInput>, Enumerable<citiesUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<citiesCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<citiesUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: citiesCreateManyCountriesInputEnvelope
    set?: Enumerable<citiesWhereUniqueInput>
    disconnect?: Enumerable<citiesWhereUniqueInput>
    delete?: Enumerable<citiesWhereUniqueInput>
    connect?: Enumerable<citiesWhereUniqueInput>
    update?: Enumerable<citiesUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<citiesUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<citiesScalarWhereInput>
  }

  export type countries_translationUncheckedUpdateManyWithoutCountriesNestedInput = {
    create?: XOR<Enumerable<countries_translationCreateWithoutCountriesInput>, Enumerable<countries_translationUncheckedCreateWithoutCountriesInput>>
    connectOrCreate?: Enumerable<countries_translationCreateOrConnectWithoutCountriesInput>
    upsert?: Enumerable<countries_translationUpsertWithWhereUniqueWithoutCountriesInput>
    createMany?: countries_translationCreateManyCountriesInputEnvelope
    set?: Enumerable<countries_translationWhereUniqueInput>
    disconnect?: Enumerable<countries_translationWhereUniqueInput>
    delete?: Enumerable<countries_translationWhereUniqueInput>
    connect?: Enumerable<countries_translationWhereUniqueInput>
    update?: Enumerable<countries_translationUpdateWithWhereUniqueWithoutCountriesInput>
    updateMany?: Enumerable<countries_translationUpdateManyWithWhereWithoutCountriesInput>
    deleteMany?: Enumerable<countries_translationScalarWhereInput>
  }

  export type countriesCreateNestedOneWithoutCountries_translationInput = {
    create?: XOR<countriesCreateWithoutCountries_translationInput, countriesUncheckedCreateWithoutCountries_translationInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCountries_translationInput
    connect?: countriesWhereUniqueInput
  }

  export type countriesUpdateOneRequiredWithoutCountries_translationNestedInput = {
    create?: XOR<countriesCreateWithoutCountries_translationInput, countriesUncheckedCreateWithoutCountries_translationInput>
    connectOrCreate?: countriesCreateOrConnectWithoutCountries_translationInput
    upsert?: countriesUpsertWithoutCountries_translationInput
    connect?: countriesWhereUniqueInput
    update?: XOR<countriesUpdateWithoutCountries_translationInput, countriesUncheckedUpdateWithoutCountries_translationInput>
  }

  export type locationCreateNestedManyWithoutLocation_type_1Input = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_1Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_1Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_1Input>
    createMany?: locationCreateManyLocation_type_1InputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUncheckedCreateNestedManyWithoutLocation_type_1Input = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_1Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_1Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_1Input>
    createMany?: locationCreateManyLocation_type_1InputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUpdateManyWithoutLocation_type_1NestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_1Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_1Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_1Input>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutLocation_type_1Input>
    createMany?: locationCreateManyLocation_type_1InputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutLocation_type_1Input>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutLocation_type_1Input>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type locationUncheckedUpdateManyWithoutLocation_type_1NestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_1Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_1Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_1Input>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutLocation_type_1Input>
    createMany?: locationCreateManyLocation_type_1InputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutLocation_type_1Input>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutLocation_type_1Input>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type locationCreateNestedManyWithoutLocation_type_2Input = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_2Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_2Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_2Input>
    createMany?: locationCreateManyLocation_type_2InputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUncheckedCreateNestedManyWithoutLocation_type_2Input = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_2Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_2Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_2Input>
    createMany?: locationCreateManyLocation_type_2InputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUpdateManyWithoutLocation_type_2NestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_2Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_2Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_2Input>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutLocation_type_2Input>
    createMany?: locationCreateManyLocation_type_2InputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutLocation_type_2Input>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutLocation_type_2Input>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type locationUncheckedUpdateManyWithoutLocation_type_2NestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutLocation_type_2Input>, Enumerable<locationUncheckedCreateWithoutLocation_type_2Input>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutLocation_type_2Input>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutLocation_type_2Input>
    createMany?: locationCreateManyLocation_type_2InputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutLocation_type_2Input>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutLocation_type_2Input>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type commission_settingCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutVendorsInput>, Enumerable<commission_settingUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutVendorsInput>
    createMany?: commission_settingCreateManyVendorsInputEnvelope
    connect?: Enumerable<commission_settingWhereUniqueInput>
  }

  export type locationCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<locationCreateWithoutVendorsInput>, Enumerable<locationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutVendorsInput>
    createMany?: locationCreateManyVendorsInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type reservationCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<reservationCreateWithoutVendorsInput>, Enumerable<reservationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutVendorsInput>
    createMany?: reservationCreateManyVendorsInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type commission_settingUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutVendorsInput>, Enumerable<commission_settingUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutVendorsInput>
    createMany?: commission_settingCreateManyVendorsInputEnvelope
    connect?: Enumerable<commission_settingWhereUniqueInput>
  }

  export type locationUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<locationCreateWithoutVendorsInput>, Enumerable<locationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutVendorsInput>
    createMany?: locationCreateManyVendorsInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type reservationUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<reservationCreateWithoutVendorsInput>, Enumerable<reservationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutVendorsInput>
    createMany?: reservationCreateManyVendorsInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type commission_settingUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutVendorsInput>, Enumerable<commission_settingUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<commission_settingUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: commission_settingCreateManyVendorsInputEnvelope
    set?: Enumerable<commission_settingWhereUniqueInput>
    disconnect?: Enumerable<commission_settingWhereUniqueInput>
    delete?: Enumerable<commission_settingWhereUniqueInput>
    connect?: Enumerable<commission_settingWhereUniqueInput>
    update?: Enumerable<commission_settingUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<commission_settingUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<commission_settingScalarWhereInput>
  }

  export type locationUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutVendorsInput>, Enumerable<locationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: locationCreateManyVendorsInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type reservationUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutVendorsInput>, Enumerable<reservationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: reservationCreateManyVendorsInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type commission_settingUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutVendorsInput>, Enumerable<commission_settingUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<commission_settingUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: commission_settingCreateManyVendorsInputEnvelope
    set?: Enumerable<commission_settingWhereUniqueInput>
    disconnect?: Enumerable<commission_settingWhereUniqueInput>
    delete?: Enumerable<commission_settingWhereUniqueInput>
    connect?: Enumerable<commission_settingWhereUniqueInput>
    update?: Enumerable<commission_settingUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<commission_settingUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<commission_settingScalarWhereInput>
  }

  export type locationUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutVendorsInput>, Enumerable<locationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: locationCreateManyVendorsInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type reservationUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutVendorsInput>, Enumerable<reservationUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: reservationCreateManyVendorsInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type countriesCreateNestedOneWithoutAirportsInput = {
    create?: XOR<countriesCreateWithoutAirportsInput, countriesUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: countriesCreateOrConnectWithoutAirportsInput
    connect?: countriesWhereUniqueInput
  }

  export type countriesUpdateOneWithoutAirportsNestedInput = {
    create?: XOR<countriesCreateWithoutAirportsInput, countriesUncheckedCreateWithoutAirportsInput>
    connectOrCreate?: countriesCreateOrConnectWithoutAirportsInput
    upsert?: countriesUpsertWithoutAirportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: countriesWhereUniqueInput
    update?: XOR<countriesUpdateWithoutAirportsInput, countriesUncheckedUpdateWithoutAirportsInput>
  }

  export type locationCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<locationCreateWithoutCategoriesInput>, Enumerable<locationUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCategoriesInput>
    createMany?: locationCreateManyCategoriesInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<Enumerable<locationCreateWithoutCategoriesInput>, Enumerable<locationUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCategoriesInput>
    createMany?: locationCreateManyCategoriesInputEnvelope
    connect?: Enumerable<locationWhereUniqueInput>
  }

  export type locationUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutCategoriesInput>, Enumerable<locationUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutCategoriesInput>
    createMany?: locationCreateManyCategoriesInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type locationUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<Enumerable<locationCreateWithoutCategoriesInput>, Enumerable<locationUncheckedCreateWithoutCategoriesInput>>
    connectOrCreate?: Enumerable<locationCreateOrConnectWithoutCategoriesInput>
    upsert?: Enumerable<locationUpsertWithWhereUniqueWithoutCategoriesInput>
    createMany?: locationCreateManyCategoriesInputEnvelope
    set?: Enumerable<locationWhereUniqueInput>
    disconnect?: Enumerable<locationWhereUniqueInput>
    delete?: Enumerable<locationWhereUniqueInput>
    connect?: Enumerable<locationWhereUniqueInput>
    update?: Enumerable<locationUpdateWithWhereUniqueWithoutCategoriesInput>
    updateMany?: Enumerable<locationUpdateManyWithWhereWithoutCategoriesInput>
    deleteMany?: Enumerable<locationScalarWhereInput>
  }

  export type reservationCreateNestedOneWithoutPaymentInput = {
    create?: XOR<reservationCreateWithoutPaymentInput, reservationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: reservationCreateOrConnectWithoutPaymentInput
    connect?: reservationWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPaymentInput = {
    create?: XOR<usersCreateWithoutPaymentInput, usersUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentInput
    connect?: usersWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type reservationUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<reservationCreateWithoutPaymentInput, reservationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: reservationCreateOrConnectWithoutPaymentInput
    upsert?: reservationUpsertWithoutPaymentInput
    disconnect?: boolean
    delete?: boolean
    connect?: reservationWhereUniqueInput
    update?: XOR<reservationUpdateWithoutPaymentInput, reservationUncheckedUpdateWithoutPaymentInput>
  }

  export type usersUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<usersCreateWithoutPaymentInput, usersUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentInput
    upsert?: usersUpsertWithoutPaymentInput
    disconnect?: boolean
    delete?: boolean
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutPaymentInput, usersUncheckedUpdateWithoutPaymentInput>
  }

  export type exchange_rate_historyCreateNestedManyWithoutExchange_ratesInput = {
    create?: XOR<Enumerable<exchange_rate_historyCreateWithoutExchange_ratesInput>, Enumerable<exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>>
    connectOrCreate?: Enumerable<exchange_rate_historyCreateOrConnectWithoutExchange_ratesInput>
    createMany?: exchange_rate_historyCreateManyExchange_ratesInputEnvelope
    connect?: Enumerable<exchange_rate_historyWhereUniqueInput>
  }

  export type exchange_rate_historyUncheckedCreateNestedManyWithoutExchange_ratesInput = {
    create?: XOR<Enumerable<exchange_rate_historyCreateWithoutExchange_ratesInput>, Enumerable<exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>>
    connectOrCreate?: Enumerable<exchange_rate_historyCreateOrConnectWithoutExchange_ratesInput>
    createMany?: exchange_rate_historyCreateManyExchange_ratesInputEnvelope
    connect?: Enumerable<exchange_rate_historyWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type exchange_rate_historyUpdateManyWithoutExchange_ratesNestedInput = {
    create?: XOR<Enumerable<exchange_rate_historyCreateWithoutExchange_ratesInput>, Enumerable<exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>>
    connectOrCreate?: Enumerable<exchange_rate_historyCreateOrConnectWithoutExchange_ratesInput>
    upsert?: Enumerable<exchange_rate_historyUpsertWithWhereUniqueWithoutExchange_ratesInput>
    createMany?: exchange_rate_historyCreateManyExchange_ratesInputEnvelope
    set?: Enumerable<exchange_rate_historyWhereUniqueInput>
    disconnect?: Enumerable<exchange_rate_historyWhereUniqueInput>
    delete?: Enumerable<exchange_rate_historyWhereUniqueInput>
    connect?: Enumerable<exchange_rate_historyWhereUniqueInput>
    update?: Enumerable<exchange_rate_historyUpdateWithWhereUniqueWithoutExchange_ratesInput>
    updateMany?: Enumerable<exchange_rate_historyUpdateManyWithWhereWithoutExchange_ratesInput>
    deleteMany?: Enumerable<exchange_rate_historyScalarWhereInput>
  }

  export type exchange_rate_historyUncheckedUpdateManyWithoutExchange_ratesNestedInput = {
    create?: XOR<Enumerable<exchange_rate_historyCreateWithoutExchange_ratesInput>, Enumerable<exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>>
    connectOrCreate?: Enumerable<exchange_rate_historyCreateOrConnectWithoutExchange_ratesInput>
    upsert?: Enumerable<exchange_rate_historyUpsertWithWhereUniqueWithoutExchange_ratesInput>
    createMany?: exchange_rate_historyCreateManyExchange_ratesInputEnvelope
    set?: Enumerable<exchange_rate_historyWhereUniqueInput>
    disconnect?: Enumerable<exchange_rate_historyWhereUniqueInput>
    delete?: Enumerable<exchange_rate_historyWhereUniqueInput>
    connect?: Enumerable<exchange_rate_historyWhereUniqueInput>
    update?: Enumerable<exchange_rate_historyUpdateWithWhereUniqueWithoutExchange_ratesInput>
    updateMany?: Enumerable<exchange_rate_historyUpdateManyWithWhereWithoutExchange_ratesInput>
    deleteMany?: Enumerable<exchange_rate_historyScalarWhereInput>
  }

  export type admin_roles_permissionsCreateNestedManyWithoutAdmin_permissionsInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_permissionsInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_permissionsInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_permissionsInputEnvelope
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
  }

  export type admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_permissionsInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_permissionsInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_permissionsInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_permissionsInputEnvelope
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
  }

  export type admin_roles_permissionsUpdateManyWithoutAdmin_permissionsNestedInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_permissionsInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_permissionsInput>
    upsert?: Enumerable<admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_permissionsInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_permissionsInputEnvelope
    set?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    disconnect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    delete?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    update?: Enumerable<admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_permissionsInput>
    updateMany?: Enumerable<admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_permissionsInput>
    deleteMany?: Enumerable<admin_roles_permissionsScalarWhereInput>
  }

  export type admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_permissionsNestedInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_permissionsInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_permissionsInput>
    upsert?: Enumerable<admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_permissionsInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_permissionsInputEnvelope
    set?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    disconnect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    delete?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    update?: Enumerable<admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_permissionsInput>
    updateMany?: Enumerable<admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_permissionsInput>
    deleteMany?: Enumerable<admin_roles_permissionsScalarWhereInput>
  }

  export type admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    connect?: admin_usersWhereUniqueInput
  }

  export type admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    connect?: admin_usersWhereUniqueInput
  }

  export type admin_roles_permissionsCreateNestedManyWithoutAdmin_rolesInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_rolesInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_rolesInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_rolesInputEnvelope
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
  }

  export type admin_users_rolesCreateNestedManyWithoutAdmin_rolesInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_rolesInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_rolesInput>
    createMany?: admin_users_rolesCreateManyAdmin_rolesInputEnvelope
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
  }

  export type admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_rolesInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_rolesInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_rolesInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_rolesInputEnvelope
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
  }

  export type admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_rolesInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_rolesInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_rolesInput>
    createMany?: admin_users_rolesCreateManyAdmin_rolesInputEnvelope
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
  }

  export type admin_usersUpdateOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersNestedInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    upsert?: admin_usersUpsertWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    disconnect?: boolean
    delete?: boolean
    connect?: admin_usersWhereUniqueInput
    update?: XOR<admin_usersUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_usersUpdateOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersNestedInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    upsert?: admin_usersUpsertWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    disconnect?: boolean
    delete?: boolean
    connect?: admin_usersWhereUniqueInput
    update?: XOR<admin_usersUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_roles_permissionsUpdateManyWithoutAdmin_rolesNestedInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_rolesInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_rolesInput>
    upsert?: Enumerable<admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_rolesInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_rolesInputEnvelope
    set?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    disconnect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    delete?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    update?: Enumerable<admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_rolesInput>
    updateMany?: Enumerable<admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_rolesInput>
    deleteMany?: Enumerable<admin_roles_permissionsScalarWhereInput>
  }

  export type admin_users_rolesUpdateManyWithoutAdmin_rolesNestedInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_rolesInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_rolesInput>
    upsert?: Enumerable<admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_rolesInput>
    createMany?: admin_users_rolesCreateManyAdmin_rolesInputEnvelope
    set?: Enumerable<admin_users_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_users_rolesWhereUniqueInput>
    delete?: Enumerable<admin_users_rolesWhereUniqueInput>
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
    update?: Enumerable<admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_rolesInput>
    updateMany?: Enumerable<admin_users_rolesUpdateManyWithWhereWithoutAdmin_rolesInput>
    deleteMany?: Enumerable<admin_users_rolesScalarWhereInput>
  }

  export type admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_rolesNestedInput = {
    create?: XOR<Enumerable<admin_roles_permissionsCreateWithoutAdmin_rolesInput>, Enumerable<admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_roles_permissionsCreateOrConnectWithoutAdmin_rolesInput>
    upsert?: Enumerable<admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_rolesInput>
    createMany?: admin_roles_permissionsCreateManyAdmin_rolesInputEnvelope
    set?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    disconnect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    delete?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    connect?: Enumerable<admin_roles_permissionsWhereUniqueInput>
    update?: Enumerable<admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_rolesInput>
    updateMany?: Enumerable<admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_rolesInput>
    deleteMany?: Enumerable<admin_roles_permissionsScalarWhereInput>
  }

  export type admin_users_rolesUncheckedUpdateManyWithoutAdmin_rolesNestedInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_rolesInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_rolesInput>
    upsert?: Enumerable<admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_rolesInput>
    createMany?: admin_users_rolesCreateManyAdmin_rolesInputEnvelope
    set?: Enumerable<admin_users_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_users_rolesWhereUniqueInput>
    delete?: Enumerable<admin_users_rolesWhereUniqueInput>
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
    update?: Enumerable<admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_rolesInput>
    updateMany?: Enumerable<admin_users_rolesUpdateManyWithWhereWithoutAdmin_rolesInput>
    deleteMany?: Enumerable<admin_users_rolesScalarWhereInput>
  }

  export type admin_permissionsCreateNestedOneWithoutAdmin_roles_permissionsInput = {
    create?: XOR<admin_permissionsCreateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedCreateWithoutAdmin_roles_permissionsInput>
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutAdmin_roles_permissionsInput
    connect?: admin_permissionsWhereUniqueInput
  }

  export type admin_rolesCreateNestedOneWithoutAdmin_roles_permissionsInput = {
    create?: XOR<admin_rolesCreateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedCreateWithoutAdmin_roles_permissionsInput>
    connectOrCreate?: admin_rolesCreateOrConnectWithoutAdmin_roles_permissionsInput
    connect?: admin_rolesWhereUniqueInput
  }

  export type admin_permissionsUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput = {
    create?: XOR<admin_permissionsCreateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedCreateWithoutAdmin_roles_permissionsInput>
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutAdmin_roles_permissionsInput
    upsert?: admin_permissionsUpsertWithoutAdmin_roles_permissionsInput
    connect?: admin_permissionsWhereUniqueInput
    update?: XOR<admin_permissionsUpdateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedUpdateWithoutAdmin_roles_permissionsInput>
  }

  export type admin_rolesUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput = {
    create?: XOR<admin_rolesCreateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedCreateWithoutAdmin_roles_permissionsInput>
    connectOrCreate?: admin_rolesCreateOrConnectWithoutAdmin_roles_permissionsInput
    upsert?: admin_rolesUpsertWithoutAdmin_roles_permissionsInput
    connect?: admin_rolesWhereUniqueInput
    update?: XOR<admin_rolesUpdateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedUpdateWithoutAdmin_roles_permissionsInput>
  }

  export type agenciesCreateNestedOneWithoutAdmin_usersInput = {
    create?: XOR<agenciesCreateWithoutAdmin_usersInput, agenciesUncheckedCreateWithoutAdmin_usersInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutAdmin_usersInput
    connect?: agenciesWhereUniqueInput
  }

  export type admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    create?: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    connect?: admin_usersWhereUniqueInput
  }

  export type admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    create?: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    connect?: admin_usersWhereUniqueInput
  }

  export type admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInputEnvelope
    connect?: Enumerable<admin_rolesWhereUniqueInput>
  }

  export type admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInputEnvelope
    connect?: Enumerable<admin_rolesWhereUniqueInput>
  }

  export type admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type admin_users_rolesCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_usersInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_usersInput>
    createMany?: admin_users_rolesCreateManyAdmin_usersInputEnvelope
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
  }

  export type admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInputEnvelope
    connect?: Enumerable<admin_rolesWhereUniqueInput>
  }

  export type admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInputEnvelope
    connect?: Enumerable<admin_rolesWhereUniqueInput>
  }

  export type admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_usersInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_usersInput>
    createMany?: admin_users_rolesCreateManyAdmin_usersInputEnvelope
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
  }

  export type agenciesUpdateOneWithoutAdmin_usersNestedInput = {
    create?: XOR<agenciesCreateWithoutAdmin_usersInput, agenciesUncheckedCreateWithoutAdmin_usersInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutAdmin_usersInput
    upsert?: agenciesUpsertWithoutAdmin_usersInput
    disconnect?: boolean
    delete?: boolean
    connect?: agenciesWhereUniqueInput
    update?: XOR<agenciesUpdateWithoutAdmin_usersInput, agenciesUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput = {
    create?: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    upsert?: admin_usersUpsertWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    disconnect?: boolean
    delete?: boolean
    connect?: admin_usersWhereUniqueInput
    update?: XOR<admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput = {
    create?: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    upsert?: admin_usersUpsertWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    disconnect?: boolean
    delete?: boolean
    connect?: admin_usersWhereUniqueInput
    update?: XOR<admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    upsert?: Enumerable<admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInputEnvelope
    set?: Enumerable<admin_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_rolesWhereUniqueInput>
    delete?: Enumerable<admin_rolesWhereUniqueInput>
    connect?: Enumerable<admin_rolesWhereUniqueInput>
    update?: Enumerable<admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    updateMany?: Enumerable<admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    deleteMany?: Enumerable<admin_rolesScalarWhereInput>
  }

  export type admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    upsert?: Enumerable<admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInputEnvelope
    set?: Enumerable<admin_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_rolesWhereUniqueInput>
    delete?: Enumerable<admin_rolesWhereUniqueInput>
    connect?: Enumerable<admin_rolesWhereUniqueInput>
    update?: Enumerable<admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    updateMany?: Enumerable<admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    deleteMany?: Enumerable<admin_rolesScalarWhereInput>
  }

  export type admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_usersInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_usersInput>
    upsert?: Enumerable<admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_usersInput>
    createMany?: admin_users_rolesCreateManyAdmin_usersInputEnvelope
    set?: Enumerable<admin_users_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_users_rolesWhereUniqueInput>
    delete?: Enumerable<admin_users_rolesWhereUniqueInput>
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
    update?: Enumerable<admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_usersInput>
    updateMany?: Enumerable<admin_users_rolesUpdateManyWithWhereWithoutAdmin_usersInput>
    deleteMany?: Enumerable<admin_users_rolesScalarWhereInput>
  }

  export type admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    upsert?: Enumerable<admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInputEnvelope
    set?: Enumerable<admin_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_rolesWhereUniqueInput>
    delete?: Enumerable<admin_rolesWhereUniqueInput>
    connect?: Enumerable<admin_rolesWhereUniqueInput>
    update?: Enumerable<admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    updateMany?: Enumerable<admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    deleteMany?: Enumerable<admin_rolesScalarWhereInput>
  }

  export type admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>, Enumerable<admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>>
    connectOrCreate?: Enumerable<admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    upsert?: Enumerable<admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    createMany?: admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInputEnvelope
    set?: Enumerable<admin_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_rolesWhereUniqueInput>
    delete?: Enumerable<admin_rolesWhereUniqueInput>
    connect?: Enumerable<admin_rolesWhereUniqueInput>
    update?: Enumerable<admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    updateMany?: Enumerable<admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    deleteMany?: Enumerable<admin_rolesScalarWhereInput>
  }

  export type admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>, Enumerable<admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    createMany?: admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput = {
    create?: XOR<Enumerable<admin_users_rolesCreateWithoutAdmin_usersInput>, Enumerable<admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>>
    connectOrCreate?: Enumerable<admin_users_rolesCreateOrConnectWithoutAdmin_usersInput>
    upsert?: Enumerable<admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_usersInput>
    createMany?: admin_users_rolesCreateManyAdmin_usersInputEnvelope
    set?: Enumerable<admin_users_rolesWhereUniqueInput>
    disconnect?: Enumerable<admin_users_rolesWhereUniqueInput>
    delete?: Enumerable<admin_users_rolesWhereUniqueInput>
    connect?: Enumerable<admin_users_rolesWhereUniqueInput>
    update?: Enumerable<admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_usersInput>
    updateMany?: Enumerable<admin_users_rolesUpdateManyWithWhereWithoutAdmin_usersInput>
    deleteMany?: Enumerable<admin_users_rolesScalarWhereInput>
  }

  export type admin_rolesCreateNestedOneWithoutAdmin_users_rolesInput = {
    create?: XOR<admin_rolesCreateWithoutAdmin_users_rolesInput, admin_rolesUncheckedCreateWithoutAdmin_users_rolesInput>
    connectOrCreate?: admin_rolesCreateOrConnectWithoutAdmin_users_rolesInput
    connect?: admin_rolesWhereUniqueInput
  }

  export type admin_usersCreateNestedOneWithoutAdmin_users_rolesInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_users_rolesInput, admin_usersUncheckedCreateWithoutAdmin_users_rolesInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_users_rolesInput
    connect?: admin_usersWhereUniqueInput
  }

  export type admin_rolesUpdateOneRequiredWithoutAdmin_users_rolesNestedInput = {
    create?: XOR<admin_rolesCreateWithoutAdmin_users_rolesInput, admin_rolesUncheckedCreateWithoutAdmin_users_rolesInput>
    connectOrCreate?: admin_rolesCreateOrConnectWithoutAdmin_users_rolesInput
    upsert?: admin_rolesUpsertWithoutAdmin_users_rolesInput
    connect?: admin_rolesWhereUniqueInput
    update?: XOR<admin_rolesUpdateWithoutAdmin_users_rolesInput, admin_rolesUncheckedUpdateWithoutAdmin_users_rolesInput>
  }

  export type admin_usersUpdateOneRequiredWithoutAdmin_users_rolesNestedInput = {
    create?: XOR<admin_usersCreateWithoutAdmin_users_rolesInput, admin_usersUncheckedCreateWithoutAdmin_users_rolesInput>
    connectOrCreate?: admin_usersCreateOrConnectWithoutAdmin_users_rolesInput
    upsert?: admin_usersUpsertWithoutAdmin_users_rolesInput
    connect?: admin_usersWhereUniqueInput
    update?: XOR<admin_usersUpdateWithoutAdmin_users_rolesInput, admin_usersUncheckedUpdateWithoutAdmin_users_rolesInput>
  }

  export type paymentCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUsersInput>, Enumerable<paymentUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUsersInput>
    createMany?: paymentCreateManyUsersInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type reservationCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUsersInput>, Enumerable<reservationUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUsersInput>
    createMany?: reservationCreateManyUsersInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUsersInput>, Enumerable<paymentUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUsersInput>
    createMany?: paymentCreateManyUsersInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type reservationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUsersInput>, Enumerable<reservationUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUsersInput>
    createMany?: reservationCreateManyUsersInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type paymentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUsersInput>, Enumerable<paymentUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: paymentCreateManyUsersInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type reservationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUsersInput>, Enumerable<reservationUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reservationCreateManyUsersInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutUsersInput>, Enumerable<paymentUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: paymentCreateManyUsersInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type reservationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUsersInput>, Enumerable<reservationUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reservationCreateManyUsersInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type price_codesCreateNestedOneWithoutPackagesInput = {
    create?: XOR<price_codesCreateWithoutPackagesInput, price_codesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: price_codesCreateOrConnectWithoutPackagesInput
    connect?: price_codesWhereUniqueInput
  }

  export type servicesCreateNestedOneWithoutPackagesInput = {
    create?: XOR<servicesCreateWithoutPackagesInput, servicesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutPackagesInput
    connect?: servicesWhereUniqueInput
  }

  export type price_codesUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<price_codesCreateWithoutPackagesInput, price_codesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: price_codesCreateOrConnectWithoutPackagesInput
    upsert?: price_codesUpsertWithoutPackagesInput
    connect?: price_codesWhereUniqueInput
    update?: XOR<price_codesUpdateWithoutPackagesInput, price_codesUncheckedUpdateWithoutPackagesInput>
  }

  export type servicesUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<servicesCreateWithoutPackagesInput, servicesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: servicesCreateOrConnectWithoutPackagesInput
    upsert?: servicesUpsertWithoutPackagesInput
    connect?: servicesWhereUniqueInput
    update?: XOR<servicesUpdateWithoutPackagesInput, servicesUncheckedUpdateWithoutPackagesInput>
  }

  export type packagesCreateNestedManyWithoutPrice_codesInput = {
    create?: XOR<Enumerable<packagesCreateWithoutPrice_codesInput>, Enumerable<packagesUncheckedCreateWithoutPrice_codesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutPrice_codesInput>
    createMany?: packagesCreateManyPrice_codesInputEnvelope
    connect?: Enumerable<packagesWhereUniqueInput>
  }

  export type packagesUncheckedCreateNestedManyWithoutPrice_codesInput = {
    create?: XOR<Enumerable<packagesCreateWithoutPrice_codesInput>, Enumerable<packagesUncheckedCreateWithoutPrice_codesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutPrice_codesInput>
    createMany?: packagesCreateManyPrice_codesInputEnvelope
    connect?: Enumerable<packagesWhereUniqueInput>
  }

  export type packagesUpdateManyWithoutPrice_codesNestedInput = {
    create?: XOR<Enumerable<packagesCreateWithoutPrice_codesInput>, Enumerable<packagesUncheckedCreateWithoutPrice_codesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutPrice_codesInput>
    upsert?: Enumerable<packagesUpsertWithWhereUniqueWithoutPrice_codesInput>
    createMany?: packagesCreateManyPrice_codesInputEnvelope
    set?: Enumerable<packagesWhereUniqueInput>
    disconnect?: Enumerable<packagesWhereUniqueInput>
    delete?: Enumerable<packagesWhereUniqueInput>
    connect?: Enumerable<packagesWhereUniqueInput>
    update?: Enumerable<packagesUpdateWithWhereUniqueWithoutPrice_codesInput>
    updateMany?: Enumerable<packagesUpdateManyWithWhereWithoutPrice_codesInput>
    deleteMany?: Enumerable<packagesScalarWhereInput>
  }

  export type packagesUncheckedUpdateManyWithoutPrice_codesNestedInput = {
    create?: XOR<Enumerable<packagesCreateWithoutPrice_codesInput>, Enumerable<packagesUncheckedCreateWithoutPrice_codesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutPrice_codesInput>
    upsert?: Enumerable<packagesUpsertWithWhereUniqueWithoutPrice_codesInput>
    createMany?: packagesCreateManyPrice_codesInputEnvelope
    set?: Enumerable<packagesWhereUniqueInput>
    disconnect?: Enumerable<packagesWhereUniqueInput>
    delete?: Enumerable<packagesWhereUniqueInput>
    connect?: Enumerable<packagesWhereUniqueInput>
    update?: Enumerable<packagesUpdateWithWhereUniqueWithoutPrice_codesInput>
    updateMany?: Enumerable<packagesUpdateManyWithWhereWithoutPrice_codesInput>
    deleteMany?: Enumerable<packagesScalarWhereInput>
  }

  export type agenciesCreateNestedOneWithoutReservationInput = {
    create?: XOR<agenciesCreateWithoutReservationInput, agenciesUncheckedCreateWithoutReservationInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutReservationInput
    connect?: agenciesWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutReservationInput = {
    create?: XOR<vendorsCreateWithoutReservationInput, vendorsUncheckedCreateWithoutReservationInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutReservationInput
    connect?: vendorsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReservationInput = {
    create?: XOR<usersCreateWithoutReservationInput, usersUncheckedCreateWithoutReservationInput>
    connectOrCreate?: usersCreateOrConnectWithoutReservationInput
    connect?: usersWhereUniqueInput
  }

  export type paymentCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<paymentCreateWithoutReservationInput>, Enumerable<paymentUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutReservationInput>
    createMany?: paymentCreateManyReservationInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<Enumerable<paymentCreateWithoutReservationInput>, Enumerable<paymentUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutReservationInput>
    createMany?: paymentCreateManyReservationInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type agenciesUpdateOneWithoutReservationNestedInput = {
    create?: XOR<agenciesCreateWithoutReservationInput, agenciesUncheckedCreateWithoutReservationInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutReservationInput
    upsert?: agenciesUpsertWithoutReservationInput
    disconnect?: boolean
    delete?: boolean
    connect?: agenciesWhereUniqueInput
    update?: XOR<agenciesUpdateWithoutReservationInput, agenciesUncheckedUpdateWithoutReservationInput>
  }

  export type vendorsUpdateOneWithoutReservationNestedInput = {
    create?: XOR<vendorsCreateWithoutReservationInput, vendorsUncheckedCreateWithoutReservationInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutReservationInput
    upsert?: vendorsUpsertWithoutReservationInput
    disconnect?: boolean
    delete?: boolean
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutReservationInput, vendorsUncheckedUpdateWithoutReservationInput>
  }

  export type usersUpdateOneWithoutReservationNestedInput = {
    create?: XOR<usersCreateWithoutReservationInput, usersUncheckedCreateWithoutReservationInput>
    connectOrCreate?: usersCreateOrConnectWithoutReservationInput
    upsert?: usersUpsertWithoutReservationInput
    disconnect?: boolean
    delete?: boolean
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutReservationInput, usersUncheckedUpdateWithoutReservationInput>
  }

  export type paymentUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutReservationInput>, Enumerable<paymentUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: paymentCreateManyReservationInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutReservationInput>, Enumerable<paymentUncheckedCreateWithoutReservationInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutReservationInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutReservationInput>
    createMany?: paymentCreateManyReservationInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutReservationInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutReservationInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type packagesCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<packagesCreateWithoutServicesInput>, Enumerable<packagesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutServicesInput>
    createMany?: packagesCreateManyServicesInputEnvelope
    connect?: Enumerable<packagesWhereUniqueInput>
  }

  export type packagesUncheckedCreateNestedManyWithoutServicesInput = {
    create?: XOR<Enumerable<packagesCreateWithoutServicesInput>, Enumerable<packagesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutServicesInput>
    createMany?: packagesCreateManyServicesInputEnvelope
    connect?: Enumerable<packagesWhereUniqueInput>
  }

  export type packagesUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<packagesCreateWithoutServicesInput>, Enumerable<packagesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<packagesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: packagesCreateManyServicesInputEnvelope
    set?: Enumerable<packagesWhereUniqueInput>
    disconnect?: Enumerable<packagesWhereUniqueInput>
    delete?: Enumerable<packagesWhereUniqueInput>
    connect?: Enumerable<packagesWhereUniqueInput>
    update?: Enumerable<packagesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<packagesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<packagesScalarWhereInput>
  }

  export type packagesUncheckedUpdateManyWithoutServicesNestedInput = {
    create?: XOR<Enumerable<packagesCreateWithoutServicesInput>, Enumerable<packagesUncheckedCreateWithoutServicesInput>>
    connectOrCreate?: Enumerable<packagesCreateOrConnectWithoutServicesInput>
    upsert?: Enumerable<packagesUpsertWithWhereUniqueWithoutServicesInput>
    createMany?: packagesCreateManyServicesInputEnvelope
    set?: Enumerable<packagesWhereUniqueInput>
    disconnect?: Enumerable<packagesWhereUniqueInput>
    delete?: Enumerable<packagesWhereUniqueInput>
    connect?: Enumerable<packagesWhereUniqueInput>
    update?: Enumerable<packagesUpdateWithWhereUniqueWithoutServicesInput>
    updateMany?: Enumerable<packagesUpdateManyWithWhereWithoutServicesInput>
    deleteMany?: Enumerable<packagesScalarWhereInput>
  }

  export type admin_usersCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAgenciesInput>, Enumerable<admin_usersUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAgenciesInput>
    createMany?: admin_usersCreateManyAgenciesInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type commission_settingCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutAgenciesInput>, Enumerable<commission_settingUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutAgenciesInput>
    createMany?: commission_settingCreateManyAgenciesInputEnvelope
    connect?: Enumerable<commission_settingWhereUniqueInput>
  }

  export type reservationCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<reservationCreateWithoutAgenciesInput>, Enumerable<reservationUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutAgenciesInput>
    createMany?: reservationCreateManyAgenciesInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type admin_usersUncheckedCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAgenciesInput>, Enumerable<admin_usersUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAgenciesInput>
    createMany?: admin_usersCreateManyAgenciesInputEnvelope
    connect?: Enumerable<admin_usersWhereUniqueInput>
  }

  export type commission_settingUncheckedCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutAgenciesInput>, Enumerable<commission_settingUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutAgenciesInput>
    createMany?: commission_settingCreateManyAgenciesInputEnvelope
    connect?: Enumerable<commission_settingWhereUniqueInput>
  }

  export type reservationUncheckedCreateNestedManyWithoutAgenciesInput = {
    create?: XOR<Enumerable<reservationCreateWithoutAgenciesInput>, Enumerable<reservationUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutAgenciesInput>
    createMany?: reservationCreateManyAgenciesInputEnvelope
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type admin_usersUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAgenciesInput>, Enumerable<admin_usersUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: admin_usersCreateManyAgenciesInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type commission_settingUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutAgenciesInput>, Enumerable<commission_settingUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<commission_settingUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: commission_settingCreateManyAgenciesInputEnvelope
    set?: Enumerable<commission_settingWhereUniqueInput>
    disconnect?: Enumerable<commission_settingWhereUniqueInput>
    delete?: Enumerable<commission_settingWhereUniqueInput>
    connect?: Enumerable<commission_settingWhereUniqueInput>
    update?: Enumerable<commission_settingUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<commission_settingUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<commission_settingScalarWhereInput>
  }

  export type reservationUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutAgenciesInput>, Enumerable<reservationUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: reservationCreateManyAgenciesInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type admin_usersUncheckedUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<admin_usersCreateWithoutAgenciesInput>, Enumerable<admin_usersUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<admin_usersCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<admin_usersUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: admin_usersCreateManyAgenciesInputEnvelope
    set?: Enumerable<admin_usersWhereUniqueInput>
    disconnect?: Enumerable<admin_usersWhereUniqueInput>
    delete?: Enumerable<admin_usersWhereUniqueInput>
    connect?: Enumerable<admin_usersWhereUniqueInput>
    update?: Enumerable<admin_usersUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<admin_usersUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<admin_usersScalarWhereInput>
  }

  export type commission_settingUncheckedUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<commission_settingCreateWithoutAgenciesInput>, Enumerable<commission_settingUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<commission_settingCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<commission_settingUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: commission_settingCreateManyAgenciesInputEnvelope
    set?: Enumerable<commission_settingWhereUniqueInput>
    disconnect?: Enumerable<commission_settingWhereUniqueInput>
    delete?: Enumerable<commission_settingWhereUniqueInput>
    connect?: Enumerable<commission_settingWhereUniqueInput>
    update?: Enumerable<commission_settingUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<commission_settingUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<commission_settingScalarWhereInput>
  }

  export type reservationUncheckedUpdateManyWithoutAgenciesNestedInput = {
    create?: XOR<Enumerable<reservationCreateWithoutAgenciesInput>, Enumerable<reservationUncheckedCreateWithoutAgenciesInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutAgenciesInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutAgenciesInput>
    createMany?: reservationCreateManyAgenciesInputEnvelope
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutAgenciesInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutAgenciesInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type agenciesCreateNestedOneWithoutCommission_settingInput = {
    create?: XOR<agenciesCreateWithoutCommission_settingInput, agenciesUncheckedCreateWithoutCommission_settingInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutCommission_settingInput
    connect?: agenciesWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutCommission_settingInput = {
    create?: XOR<vendorsCreateWithoutCommission_settingInput, vendorsUncheckedCreateWithoutCommission_settingInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutCommission_settingInput
    connect?: vendorsWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type agenciesUpdateOneRequiredWithoutCommission_settingNestedInput = {
    create?: XOR<agenciesCreateWithoutCommission_settingInput, agenciesUncheckedCreateWithoutCommission_settingInput>
    connectOrCreate?: agenciesCreateOrConnectWithoutCommission_settingInput
    upsert?: agenciesUpsertWithoutCommission_settingInput
    connect?: agenciesWhereUniqueInput
    update?: XOR<agenciesUpdateWithoutCommission_settingInput, agenciesUncheckedUpdateWithoutCommission_settingInput>
  }

  export type vendorsUpdateOneRequiredWithoutCommission_settingNestedInput = {
    create?: XOR<vendorsCreateWithoutCommission_settingInput, vendorsUncheckedCreateWithoutCommission_settingInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutCommission_settingInput
    upsert?: vendorsUpsertWithoutCommission_settingInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutCommission_settingInput, vendorsUncheckedUpdateWithoutCommission_settingInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type subject_faqCreateNestedOneWithoutFaqInput = {
    create?: XOR<subject_faqCreateWithoutFaqInput, subject_faqUncheckedCreateWithoutFaqInput>
    connectOrCreate?: subject_faqCreateOrConnectWithoutFaqInput
    connect?: subject_faqWhereUniqueInput
  }

  export type keyword_faqCreateNestedManyWithoutFaqInput = {
    create?: XOR<Enumerable<keyword_faqCreateWithoutFaqInput>, Enumerable<keyword_faqUncheckedCreateWithoutFaqInput>>
    connectOrCreate?: Enumerable<keyword_faqCreateOrConnectWithoutFaqInput>
    createMany?: keyword_faqCreateManyFaqInputEnvelope
    connect?: Enumerable<keyword_faqWhereUniqueInput>
  }

  export type keyword_faqUncheckedCreateNestedManyWithoutFaqInput = {
    create?: XOR<Enumerable<keyword_faqCreateWithoutFaqInput>, Enumerable<keyword_faqUncheckedCreateWithoutFaqInput>>
    connectOrCreate?: Enumerable<keyword_faqCreateOrConnectWithoutFaqInput>
    createMany?: keyword_faqCreateManyFaqInputEnvelope
    connect?: Enumerable<keyword_faqWhereUniqueInput>
  }

  export type subject_faqUpdateOneWithoutFaqNestedInput = {
    create?: XOR<subject_faqCreateWithoutFaqInput, subject_faqUncheckedCreateWithoutFaqInput>
    connectOrCreate?: subject_faqCreateOrConnectWithoutFaqInput
    upsert?: subject_faqUpsertWithoutFaqInput
    disconnect?: boolean
    delete?: boolean
    connect?: subject_faqWhereUniqueInput
    update?: XOR<subject_faqUpdateWithoutFaqInput, subject_faqUncheckedUpdateWithoutFaqInput>
  }

  export type keyword_faqUpdateManyWithoutFaqNestedInput = {
    create?: XOR<Enumerable<keyword_faqCreateWithoutFaqInput>, Enumerable<keyword_faqUncheckedCreateWithoutFaqInput>>
    connectOrCreate?: Enumerable<keyword_faqCreateOrConnectWithoutFaqInput>
    upsert?: Enumerable<keyword_faqUpsertWithWhereUniqueWithoutFaqInput>
    createMany?: keyword_faqCreateManyFaqInputEnvelope
    set?: Enumerable<keyword_faqWhereUniqueInput>
    disconnect?: Enumerable<keyword_faqWhereUniqueInput>
    delete?: Enumerable<keyword_faqWhereUniqueInput>
    connect?: Enumerable<keyword_faqWhereUniqueInput>
    update?: Enumerable<keyword_faqUpdateWithWhereUniqueWithoutFaqInput>
    updateMany?: Enumerable<keyword_faqUpdateManyWithWhereWithoutFaqInput>
    deleteMany?: Enumerable<keyword_faqScalarWhereInput>
  }

  export type keyword_faqUncheckedUpdateManyWithoutFaqNestedInput = {
    create?: XOR<Enumerable<keyword_faqCreateWithoutFaqInput>, Enumerable<keyword_faqUncheckedCreateWithoutFaqInput>>
    connectOrCreate?: Enumerable<keyword_faqCreateOrConnectWithoutFaqInput>
    upsert?: Enumerable<keyword_faqUpsertWithWhereUniqueWithoutFaqInput>
    createMany?: keyword_faqCreateManyFaqInputEnvelope
    set?: Enumerable<keyword_faqWhereUniqueInput>
    disconnect?: Enumerable<keyword_faqWhereUniqueInput>
    delete?: Enumerable<keyword_faqWhereUniqueInput>
    connect?: Enumerable<keyword_faqWhereUniqueInput>
    update?: Enumerable<keyword_faqUpdateWithWhereUniqueWithoutFaqInput>
    updateMany?: Enumerable<keyword_faqUpdateManyWithWhereWithoutFaqInput>
    deleteMany?: Enumerable<keyword_faqScalarWhereInput>
  }

  export type exchange_ratesCreateNestedOneWithoutExchange_rate_historyInput = {
    create?: XOR<exchange_ratesCreateWithoutExchange_rate_historyInput, exchange_ratesUncheckedCreateWithoutExchange_rate_historyInput>
    connectOrCreate?: exchange_ratesCreateOrConnectWithoutExchange_rate_historyInput
    connect?: exchange_ratesWhereUniqueInput
  }

  export type exchange_ratesUpdateOneRequiredWithoutExchange_rate_historyNestedInput = {
    create?: XOR<exchange_ratesCreateWithoutExchange_rate_historyInput, exchange_ratesUncheckedCreateWithoutExchange_rate_historyInput>
    connectOrCreate?: exchange_ratesCreateOrConnectWithoutExchange_rate_historyInput
    upsert?: exchange_ratesUpsertWithoutExchange_rate_historyInput
    connect?: exchange_ratesWhereUniqueInput
    update?: XOR<exchange_ratesUpdateWithoutExchange_rate_historyInput, exchange_ratesUncheckedUpdateWithoutExchange_rate_historyInput>
  }

  export type faqCreateNestedManyWithoutSubject_faqInput = {
    create?: XOR<Enumerable<faqCreateWithoutSubject_faqInput>, Enumerable<faqUncheckedCreateWithoutSubject_faqInput>>
    connectOrCreate?: Enumerable<faqCreateOrConnectWithoutSubject_faqInput>
    createMany?: faqCreateManySubject_faqInputEnvelope
    connect?: Enumerable<faqWhereUniqueInput>
  }

  export type faqUncheckedCreateNestedManyWithoutSubject_faqInput = {
    create?: XOR<Enumerable<faqCreateWithoutSubject_faqInput>, Enumerable<faqUncheckedCreateWithoutSubject_faqInput>>
    connectOrCreate?: Enumerable<faqCreateOrConnectWithoutSubject_faqInput>
    createMany?: faqCreateManySubject_faqInputEnvelope
    connect?: Enumerable<faqWhereUniqueInput>
  }

  export type faqUpdateManyWithoutSubject_faqNestedInput = {
    create?: XOR<Enumerable<faqCreateWithoutSubject_faqInput>, Enumerable<faqUncheckedCreateWithoutSubject_faqInput>>
    connectOrCreate?: Enumerable<faqCreateOrConnectWithoutSubject_faqInput>
    upsert?: Enumerable<faqUpsertWithWhereUniqueWithoutSubject_faqInput>
    createMany?: faqCreateManySubject_faqInputEnvelope
    set?: Enumerable<faqWhereUniqueInput>
    disconnect?: Enumerable<faqWhereUniqueInput>
    delete?: Enumerable<faqWhereUniqueInput>
    connect?: Enumerable<faqWhereUniqueInput>
    update?: Enumerable<faqUpdateWithWhereUniqueWithoutSubject_faqInput>
    updateMany?: Enumerable<faqUpdateManyWithWhereWithoutSubject_faqInput>
    deleteMany?: Enumerable<faqScalarWhereInput>
  }

  export type faqUncheckedUpdateManyWithoutSubject_faqNestedInput = {
    create?: XOR<Enumerable<faqCreateWithoutSubject_faqInput>, Enumerable<faqUncheckedCreateWithoutSubject_faqInput>>
    connectOrCreate?: Enumerable<faqCreateOrConnectWithoutSubject_faqInput>
    upsert?: Enumerable<faqUpsertWithWhereUniqueWithoutSubject_faqInput>
    createMany?: faqCreateManySubject_faqInputEnvelope
    set?: Enumerable<faqWhereUniqueInput>
    disconnect?: Enumerable<faqWhereUniqueInput>
    delete?: Enumerable<faqWhereUniqueInput>
    connect?: Enumerable<faqWhereUniqueInput>
    update?: Enumerable<faqUpdateWithWhereUniqueWithoutSubject_faqInput>
    updateMany?: Enumerable<faqUpdateManyWithWhereWithoutSubject_faqInput>
    deleteMany?: Enumerable<faqScalarWhereInput>
  }

  export type faqCreateNestedOneWithoutKeyword_faqInput = {
    create?: XOR<faqCreateWithoutKeyword_faqInput, faqUncheckedCreateWithoutKeyword_faqInput>
    connectOrCreate?: faqCreateOrConnectWithoutKeyword_faqInput
    connect?: faqWhereUniqueInput
  }

  export type faqUpdateOneRequiredWithoutKeyword_faqNestedInput = {
    create?: XOR<faqCreateWithoutKeyword_faqInput, faqUncheckedCreateWithoutKeyword_faqInput>
    connectOrCreate?: faqCreateOrConnectWithoutKeyword_faqInput
    upsert?: faqUpsertWithoutKeyword_faqInput
    connect?: faqWhereUniqueInput
    update?: XOR<faqUpdateWithoutKeyword_faqInput, faqUncheckedUpdateWithoutKeyword_faqInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type countriesCreateWithoutCitiesInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateWithoutCitiesInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsUncheckedCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesCreateOrConnectWithoutCitiesInput = {
    where: countriesWhereUniqueInput
    create: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
  }

  export type cities_translationCreateWithoutCitiesInput = {
    locale: string
    city_name: string
  }

  export type cities_translationUncheckedCreateWithoutCitiesInput = {
    locale: string
    city_name: string
  }

  export type cities_translationCreateOrConnectWithoutCitiesInput = {
    where: cities_translationWhereUniqueInput
    create: XOR<cities_translationCreateWithoutCitiesInput, cities_translationUncheckedCreateWithoutCitiesInput>
  }

  export type cities_translationCreateManyCitiesInputEnvelope = {
    data: Enumerable<cities_translationCreateManyCitiesInput>
    skipDuplicates?: boolean
  }

  export type countriesUpsertWithoutCitiesInput = {
    update: XOR<countriesUpdateWithoutCitiesInput, countriesUncheckedUpdateWithoutCitiesInput>
    create: XOR<countriesCreateWithoutCitiesInput, countriesUncheckedCreateWithoutCitiesInput>
  }

  export type countriesUpdateWithoutCitiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUpdateManyWithoutCountriesNestedInput
  }

  export type countriesUncheckedUpdateWithoutCitiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUncheckedUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUncheckedUpdateManyWithoutCountriesNestedInput
  }

  export type cities_translationUpsertWithWhereUniqueWithoutCitiesInput = {
    where: cities_translationWhereUniqueInput
    update: XOR<cities_translationUpdateWithoutCitiesInput, cities_translationUncheckedUpdateWithoutCitiesInput>
    create: XOR<cities_translationCreateWithoutCitiesInput, cities_translationUncheckedCreateWithoutCitiesInput>
  }

  export type cities_translationUpdateWithWhereUniqueWithoutCitiesInput = {
    where: cities_translationWhereUniqueInput
    data: XOR<cities_translationUpdateWithoutCitiesInput, cities_translationUncheckedUpdateWithoutCitiesInput>
  }

  export type cities_translationUpdateManyWithWhereWithoutCitiesInput = {
    where: cities_translationScalarWhereInput
    data: XOR<cities_translationUpdateManyMutationInput, cities_translationUncheckedUpdateManyWithoutCities_translationInput>
  }

  export type cities_translationScalarWhereInput = {
    AND?: Enumerable<cities_translationScalarWhereInput>
    OR?: Enumerable<cities_translationScalarWhereInput>
    NOT?: Enumerable<cities_translationScalarWhereInput>
    city_code?: StringFilter | string
    locale?: StringFilter | string
    city_name?: StringFilter | string
  }

  export type citiesCreateWithoutCities_translationInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    countries?: countriesCreateNestedOneWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutCities_translationInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    country_code?: string | null
  }

  export type citiesCreateOrConnectWithoutCities_translationInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutCities_translationInput, citiesUncheckedCreateWithoutCities_translationInput>
  }

  export type citiesUpsertWithoutCities_translationInput = {
    update: XOR<citiesUpdateWithoutCities_translationInput, citiesUncheckedUpdateWithoutCities_translationInput>
    create: XOR<citiesCreateWithoutCities_translationInput, citiesUncheckedCreateWithoutCities_translationInput>
  }

  export type citiesUpdateWithoutCities_translationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    countries?: countriesUpdateOneWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateWithoutCities_translationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type translationCreateWithoutLocalesInput = {
    message: string
    tag: string
  }

  export type translationUncheckedCreateWithoutLocalesInput = {
    message: string
    tag: string
  }

  export type translationCreateOrConnectWithoutLocalesInput = {
    where: translationWhereUniqueInput
    create: XOR<translationCreateWithoutLocalesInput, translationUncheckedCreateWithoutLocalesInput>
  }

  export type translationCreateManyLocalesInputEnvelope = {
    data: Enumerable<translationCreateManyLocalesInput>
    skipDuplicates?: boolean
  }

  export type translationUpsertWithWhereUniqueWithoutLocalesInput = {
    where: translationWhereUniqueInput
    update: XOR<translationUpdateWithoutLocalesInput, translationUncheckedUpdateWithoutLocalesInput>
    create: XOR<translationCreateWithoutLocalesInput, translationUncheckedCreateWithoutLocalesInput>
  }

  export type translationUpdateWithWhereUniqueWithoutLocalesInput = {
    where: translationWhereUniqueInput
    data: XOR<translationUpdateWithoutLocalesInput, translationUncheckedUpdateWithoutLocalesInput>
  }

  export type translationUpdateManyWithWhereWithoutLocalesInput = {
    where: translationScalarWhereInput
    data: XOR<translationUpdateManyMutationInput, translationUncheckedUpdateManyWithoutTranslationInput>
  }

  export type translationScalarWhereInput = {
    AND?: Enumerable<translationScalarWhereInput>
    OR?: Enumerable<translationScalarWhereInput>
    NOT?: Enumerable<translationScalarWhereInput>
    locale_id?: IntFilter | number
    message?: StringFilter | string
    tag?: StringFilter | string
  }

  export type categoriesCreateWithoutLocationInput = {
    id: string
    name: string
    icon?: string | null
  }

  export type categoriesUncheckedCreateWithoutLocationInput = {
    id: string
    name: string
    icon?: string | null
  }

  export type categoriesCreateOrConnectWithoutLocationInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutLocationInput, categoriesUncheckedCreateWithoutLocationInput>
  }

  export type location_type_1CreateWithoutLocationInput = {
    type: string
    description: string
  }

  export type location_type_1UncheckedCreateWithoutLocationInput = {
    type: string
    description: string
  }

  export type location_type_1CreateOrConnectWithoutLocationInput = {
    where: location_type_1WhereUniqueInput
    create: XOR<location_type_1CreateWithoutLocationInput, location_type_1UncheckedCreateWithoutLocationInput>
  }

  export type location_type_2CreateWithoutLocationInput = {
    type: string
    description: string
  }

  export type location_type_2UncheckedCreateWithoutLocationInput = {
    type: string
    description: string
  }

  export type location_type_2CreateOrConnectWithoutLocationInput = {
    where: location_type_2WhereUniqueInput
    create: XOR<location_type_2CreateWithoutLocationInput, location_type_2UncheckedCreateWithoutLocationInput>
  }

  export type vendorsCreateWithoutLocationInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingCreateNestedManyWithoutVendorsInput
    reservation?: reservationCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutLocationInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutVendorsInput
    reservation?: reservationUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutLocationInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutLocationInput, vendorsUncheckedCreateWithoutLocationInput>
  }

  export type location_descriptionCreateWithoutLocationInput = {
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
  }

  export type location_descriptionUncheckedCreateWithoutLocationInput = {
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
  }

  export type location_descriptionCreateOrConnectWithoutLocationInput = {
    where: location_descriptionWhereUniqueInput
    create: XOR<location_descriptionCreateWithoutLocationInput, location_descriptionUncheckedCreateWithoutLocationInput>
  }

  export type location_descriptionCreateManyLocationInputEnvelope = {
    data: Enumerable<location_descriptionCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type categoriesUpsertWithoutLocationInput = {
    update: XOR<categoriesUpdateWithoutLocationInput, categoriesUncheckedUpdateWithoutLocationInput>
    create: XOR<categoriesCreateWithoutLocationInput, categoriesUncheckedCreateWithoutLocationInput>
  }

  export type categoriesUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriesUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_type_1UpsertWithoutLocationInput = {
    update: XOR<location_type_1UpdateWithoutLocationInput, location_type_1UncheckedUpdateWithoutLocationInput>
    create: XOR<location_type_1CreateWithoutLocationInput, location_type_1UncheckedCreateWithoutLocationInput>
  }

  export type location_type_1UpdateWithoutLocationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_1UncheckedUpdateWithoutLocationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_2UpsertWithoutLocationInput = {
    update: XOR<location_type_2UpdateWithoutLocationInput, location_type_2UncheckedUpdateWithoutLocationInput>
    create: XOR<location_type_2CreateWithoutLocationInput, location_type_2UncheckedCreateWithoutLocationInput>
  }

  export type location_type_2UpdateWithoutLocationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type location_type_2UncheckedUpdateWithoutLocationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type vendorsUpsertWithoutLocationInput = {
    update: XOR<vendorsUpdateWithoutLocationInput, vendorsUncheckedUpdateWithoutLocationInput>
    create: XOR<vendorsCreateWithoutLocationInput, vendorsUncheckedCreateWithoutLocationInput>
  }

  export type vendorsUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUncheckedUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type location_descriptionUpsertWithWhereUniqueWithoutLocationInput = {
    where: location_descriptionWhereUniqueInput
    update: XOR<location_descriptionUpdateWithoutLocationInput, location_descriptionUncheckedUpdateWithoutLocationInput>
    create: XOR<location_descriptionCreateWithoutLocationInput, location_descriptionUncheckedCreateWithoutLocationInput>
  }

  export type location_descriptionUpdateWithWhereUniqueWithoutLocationInput = {
    where: location_descriptionWhereUniqueInput
    data: XOR<location_descriptionUpdateWithoutLocationInput, location_descriptionUncheckedUpdateWithoutLocationInput>
  }

  export type location_descriptionUpdateManyWithWhereWithoutLocationInput = {
    where: location_descriptionScalarWhereInput
    data: XOR<location_descriptionUpdateManyMutationInput, location_descriptionUncheckedUpdateManyWithoutLocation_descriptionInput>
  }

  export type location_descriptionScalarWhereInput = {
    AND?: Enumerable<location_descriptionScalarWhereInput>
    OR?: Enumerable<location_descriptionScalarWhereInput>
    NOT?: Enumerable<location_descriptionScalarWhereInput>
    location_id?: StringFilter | string
    locale?: StringFilter | string
    description?: StringNullableFilter | string | null
    address_1?: StringNullableFilter | string | null
    address_2?: StringNullableFilter | string | null
    address_3?: StringNullableFilter | string | null
  }

  export type locationCreateWithoutLocation_descriptionInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    categories?: categoriesCreateNestedOneWithoutLocationInput
    location_type_1?: location_type_1CreateNestedOneWithoutLocationInput
    location_type_2?: location_type_2CreateNestedOneWithoutLocationInput
    vendors: vendorsCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutLocation_descriptionInput = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
  }

  export type locationCreateOrConnectWithoutLocation_descriptionInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutLocation_descriptionInput, locationUncheckedCreateWithoutLocation_descriptionInput>
  }

  export type locationUpsertWithoutLocation_descriptionInput = {
    update: XOR<locationUpdateWithoutLocation_descriptionInput, locationUncheckedUpdateWithoutLocation_descriptionInput>
    create: XOR<locationCreateWithoutLocation_descriptionInput, locationUncheckedCreateWithoutLocation_descriptionInput>
  }

  export type locationUpdateWithoutLocation_descriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateOneWithoutLocationNestedInput
    location_type_1?: location_type_1UpdateOneWithoutLocationNestedInput
    location_type_2?: location_type_2UpdateOneWithoutLocationNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutLocation_descriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type localesCreateWithoutTranslationInput = {
    name: string
    code: string
    default?: boolean
  }

  export type localesUncheckedCreateWithoutTranslationInput = {
    id?: number
    name: string
    code: string
    default?: boolean
  }

  export type localesCreateOrConnectWithoutTranslationInput = {
    where: localesWhereUniqueInput
    create: XOR<localesCreateWithoutTranslationInput, localesUncheckedCreateWithoutTranslationInput>
  }

  export type localesUpsertWithoutTranslationInput = {
    update: XOR<localesUpdateWithoutTranslationInput, localesUncheckedUpdateWithoutTranslationInput>
    create: XOR<localesCreateWithoutTranslationInput, localesUncheckedCreateWithoutTranslationInput>
  }

  export type localesUpdateWithoutTranslationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type localesUncheckedUpdateWithoutTranslationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type airportsCreateWithoutCountriesInput = {
    iata_code: string
    icao_code: string
    name: string
    latitude: number
    longitude: number
  }

  export type airportsUncheckedCreateWithoutCountriesInput = {
    iata_code: string
    icao_code: string
    name: string
    latitude: number
    longitude: number
    id?: number
  }

  export type airportsCreateOrConnectWithoutCountriesInput = {
    where: airportsWhereUniqueInput
    create: XOR<airportsCreateWithoutCountriesInput, airportsUncheckedCreateWithoutCountriesInput>
  }

  export type airportsCreateManyCountriesInputEnvelope = {
    data: Enumerable<airportsCreateManyCountriesInput>
    skipDuplicates?: boolean
  }

  export type citiesCreateWithoutCountriesInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    cities_translation?: cities_translationCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateWithoutCountriesInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
    cities_translation?: cities_translationUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesCreateOrConnectWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutCountriesInput, citiesUncheckedCreateWithoutCountriesInput>
  }

  export type citiesCreateManyCountriesInputEnvelope = {
    data: Enumerable<citiesCreateManyCountriesInput>
    skipDuplicates?: boolean
  }

  export type countries_translationCreateWithoutCountriesInput = {
    locale: string
    country_name: string
  }

  export type countries_translationUncheckedCreateWithoutCountriesInput = {
    locale: string
    country_name: string
  }

  export type countries_translationCreateOrConnectWithoutCountriesInput = {
    where: countries_translationWhereUniqueInput
    create: XOR<countries_translationCreateWithoutCountriesInput, countries_translationUncheckedCreateWithoutCountriesInput>
  }

  export type countries_translationCreateManyCountriesInputEnvelope = {
    data: Enumerable<countries_translationCreateManyCountriesInput>
    skipDuplicates?: boolean
  }

  export type airportsUpsertWithWhereUniqueWithoutCountriesInput = {
    where: airportsWhereUniqueInput
    update: XOR<airportsUpdateWithoutCountriesInput, airportsUncheckedUpdateWithoutCountriesInput>
    create: XOR<airportsCreateWithoutCountriesInput, airportsUncheckedCreateWithoutCountriesInput>
  }

  export type airportsUpdateWithWhereUniqueWithoutCountriesInput = {
    where: airportsWhereUniqueInput
    data: XOR<airportsUpdateWithoutCountriesInput, airportsUncheckedUpdateWithoutCountriesInput>
  }

  export type airportsUpdateManyWithWhereWithoutCountriesInput = {
    where: airportsScalarWhereInput
    data: XOR<airportsUpdateManyMutationInput, airportsUncheckedUpdateManyWithoutAirportsInput>
  }

  export type airportsScalarWhereInput = {
    AND?: Enumerable<airportsScalarWhereInput>
    OR?: Enumerable<airportsScalarWhereInput>
    NOT?: Enumerable<airportsScalarWhereInput>
    iata_code?: StringFilter | string
    country_code?: StringNullableFilter | string | null
    icao_code?: StringFilter | string
    name?: StringFilter | string
    latitude?: IntFilter | number
    longitude?: IntFilter | number
    id?: IntFilter | number
  }

  export type citiesUpsertWithWhereUniqueWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    update: XOR<citiesUpdateWithoutCountriesInput, citiesUncheckedUpdateWithoutCountriesInput>
    create: XOR<citiesCreateWithoutCountriesInput, citiesUncheckedCreateWithoutCountriesInput>
  }

  export type citiesUpdateWithWhereUniqueWithoutCountriesInput = {
    where: citiesWhereUniqueInput
    data: XOR<citiesUpdateWithoutCountriesInput, citiesUncheckedUpdateWithoutCountriesInput>
  }

  export type citiesUpdateManyWithWhereWithoutCountriesInput = {
    where: citiesScalarWhereInput
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyWithoutCitiesInput>
  }

  export type citiesScalarWhereInput = {
    AND?: Enumerable<citiesScalarWhereInput>
    OR?: Enumerable<citiesScalarWhereInput>
    NOT?: Enumerable<citiesScalarWhereInput>
    code?: StringFilter | string
    name?: StringFilter | string
    un_locode?: StringNullableFilter | string | null
    latitude?: IntNullableFilter | number | null
    longitude?: IntNullableFilter | number | null
    alt?: IntNullableFilter | number | null
    timezone?: StringNullableFilter | string | null
    country_code?: StringNullableFilter | string | null
  }

  export type countries_translationUpsertWithWhereUniqueWithoutCountriesInput = {
    where: countries_translationWhereUniqueInput
    update: XOR<countries_translationUpdateWithoutCountriesInput, countries_translationUncheckedUpdateWithoutCountriesInput>
    create: XOR<countries_translationCreateWithoutCountriesInput, countries_translationUncheckedCreateWithoutCountriesInput>
  }

  export type countries_translationUpdateWithWhereUniqueWithoutCountriesInput = {
    where: countries_translationWhereUniqueInput
    data: XOR<countries_translationUpdateWithoutCountriesInput, countries_translationUncheckedUpdateWithoutCountriesInput>
  }

  export type countries_translationUpdateManyWithWhereWithoutCountriesInput = {
    where: countries_translationScalarWhereInput
    data: XOR<countries_translationUpdateManyMutationInput, countries_translationUncheckedUpdateManyWithoutCountries_translationInput>
  }

  export type countries_translationScalarWhereInput = {
    AND?: Enumerable<countries_translationScalarWhereInput>
    OR?: Enumerable<countries_translationScalarWhereInput>
    NOT?: Enumerable<countries_translationScalarWhereInput>
    country_code?: StringFilter | string
    locale?: StringFilter | string
    country_name?: StringFilter | string
  }

  export type countriesCreateWithoutCountries_translationInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsCreateNestedManyWithoutCountriesInput
    cities?: citiesCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateWithoutCountries_translationInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    airports?: airportsUncheckedCreateNestedManyWithoutCountriesInput
    cities?: citiesUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesCreateOrConnectWithoutCountries_translationInput = {
    where: countriesWhereUniqueInput
    create: XOR<countriesCreateWithoutCountries_translationInput, countriesUncheckedCreateWithoutCountries_translationInput>
  }

  export type countriesUpsertWithoutCountries_translationInput = {
    update: XOR<countriesUpdateWithoutCountries_translationInput, countriesUncheckedUpdateWithoutCountries_translationInput>
    create: XOR<countriesCreateWithoutCountries_translationInput, countriesUncheckedCreateWithoutCountries_translationInput>
  }

  export type countriesUpdateWithoutCountries_translationInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUpdateManyWithoutCountriesNestedInput
    cities?: citiesUpdateManyWithoutCountriesNestedInput
  }

  export type countriesUncheckedUpdateWithoutCountries_translationInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    airports?: airportsUncheckedUpdateManyWithoutCountriesNestedInput
    cities?: citiesUncheckedUpdateManyWithoutCountriesNestedInput
  }

  export type locationCreateWithoutLocation_type_1Input = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    categories?: categoriesCreateNestedOneWithoutLocationInput
    location_type_2?: location_type_2CreateNestedOneWithoutLocationInput
    vendors: vendorsCreateNestedOneWithoutLocationInput
    location_description?: location_descriptionCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutLocation_type_1Input = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
    location_description?: location_descriptionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutLocation_type_1Input = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutLocation_type_1Input, locationUncheckedCreateWithoutLocation_type_1Input>
  }

  export type locationCreateManyLocation_type_1InputEnvelope = {
    data: Enumerable<locationCreateManyLocation_type_1Input>
    skipDuplicates?: boolean
  }

  export type locationUpsertWithWhereUniqueWithoutLocation_type_1Input = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutLocation_type_1Input, locationUncheckedUpdateWithoutLocation_type_1Input>
    create: XOR<locationCreateWithoutLocation_type_1Input, locationUncheckedCreateWithoutLocation_type_1Input>
  }

  export type locationUpdateWithWhereUniqueWithoutLocation_type_1Input = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutLocation_type_1Input, locationUncheckedUpdateWithoutLocation_type_1Input>
  }

  export type locationUpdateManyWithWhereWithoutLocation_type_1Input = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationInput>
  }

  export type locationScalarWhereInput = {
    AND?: Enumerable<locationScalarWhereInput>
    OR?: Enumerable<locationScalarWhereInput>
    NOT?: Enumerable<locationScalarWhereInput>
    id?: StringFilter | string
    city_code?: StringNullableFilter | string | null
    vendor_id?: StringFilter | string
    oag_code?: StringNullableFilter | string | null
    country_code?: StringNullableFilter | string | null
    state?: StringNullableFilter | string | null
    zip_code?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    alt_phone?: StringNullableFilter | string | null
    fax?: StringNullableFilter | string | null
    telex?: StringNullableFilter | string | null
    web_url?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    latitude?: StringNullableFilter | string | null
    longitude?: StringNullableFilter | string | null
    open_1_mon?: StringNullableFilter | string | null
    close_1_mon?: StringNullableFilter | string | null
    open_2_mon?: StringNullableFilter | string | null
    close_2_mon?: StringNullableFilter | string | null
    open_3_mon?: StringNullableFilter | string | null
    close_3_mon?: StringNullableFilter | string | null
    open_1_tue?: StringNullableFilter | string | null
    close_1_tue?: StringNullableFilter | string | null
    open_2_tue?: StringNullableFilter | string | null
    close_2_tue?: StringNullableFilter | string | null
    open_3_tue?: StringNullableFilter | string | null
    close_3_tue?: StringNullableFilter | string | null
    open_1_wed?: StringNullableFilter | string | null
    close_1_wed?: StringNullableFilter | string | null
    open_2_wed?: StringNullableFilter | string | null
    close_2_wed?: StringNullableFilter | string | null
    open_3_wed?: StringNullableFilter | string | null
    close_3_wed?: StringNullableFilter | string | null
    open_1_thu?: StringNullableFilter | string | null
    close_1_thu?: StringNullableFilter | string | null
    open_2_thu?: StringNullableFilter | string | null
    close_2_thu?: StringNullableFilter | string | null
    open_3_thu?: StringNullableFilter | string | null
    close_3_thu?: StringNullableFilter | string | null
    open_1_fri?: StringNullableFilter | string | null
    close_1_fri?: StringNullableFilter | string | null
    open_2_fri?: StringNullableFilter | string | null
    close_2_fri?: StringNullableFilter | string | null
    open_3_fri?: StringNullableFilter | string | null
    close_3_fri?: StringNullableFilter | string | null
    open_1_sat?: StringNullableFilter | string | null
    close_1_sat?: StringNullableFilter | string | null
    open_2_sat?: StringNullableFilter | string | null
    close_2_sat?: StringNullableFilter | string | null
    open_3_sat?: StringNullableFilter | string | null
    close_3_sat?: StringNullableFilter | string | null
    open_1_sun?: StringNullableFilter | string | null
    close_1_sun?: StringNullableFilter | string | null
    open_2_sun?: StringNullableFilter | string | null
    close_2_sun?: StringNullableFilter | string | null
    open_3_sun?: StringNullableFilter | string | null
    close_3_sun?: StringNullableFilter | string | null
    loc_type_1?: StringNullableFilter | string | null
    loc_type_2?: StringNullableFilter | string | null
    city_name?: StringNullableFilter | string | null
    category_id?: StringNullableFilter | string | null
  }

  export type locationCreateWithoutLocation_type_2Input = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    categories?: categoriesCreateNestedOneWithoutLocationInput
    location_type_1?: location_type_1CreateNestedOneWithoutLocationInput
    vendors: vendorsCreateNestedOneWithoutLocationInput
    location_description?: location_descriptionCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutLocation_type_2Input = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    city_name?: string | null
    category_id?: string | null
    location_description?: location_descriptionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutLocation_type_2Input = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutLocation_type_2Input, locationUncheckedCreateWithoutLocation_type_2Input>
  }

  export type locationCreateManyLocation_type_2InputEnvelope = {
    data: Enumerable<locationCreateManyLocation_type_2Input>
    skipDuplicates?: boolean
  }

  export type locationUpsertWithWhereUniqueWithoutLocation_type_2Input = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutLocation_type_2Input, locationUncheckedUpdateWithoutLocation_type_2Input>
    create: XOR<locationCreateWithoutLocation_type_2Input, locationUncheckedCreateWithoutLocation_type_2Input>
  }

  export type locationUpdateWithWhereUniqueWithoutLocation_type_2Input = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutLocation_type_2Input, locationUncheckedUpdateWithoutLocation_type_2Input>
  }

  export type locationUpdateManyWithWhereWithoutLocation_type_2Input = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationInput>
  }

  export type commission_settingCreateWithoutVendorsInput = {
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
    agencies: agenciesCreateNestedOneWithoutCommission_settingInput
  }

  export type commission_settingUncheckedCreateWithoutVendorsInput = {
    id?: number
    agency: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type commission_settingCreateOrConnectWithoutVendorsInput = {
    where: commission_settingWhereUniqueInput
    create: XOR<commission_settingCreateWithoutVendorsInput, commission_settingUncheckedCreateWithoutVendorsInput>
  }

  export type commission_settingCreateManyVendorsInputEnvelope = {
    data: Enumerable<commission_settingCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type locationCreateWithoutVendorsInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    categories?: categoriesCreateNestedOneWithoutLocationInput
    location_type_1?: location_type_1CreateNestedOneWithoutLocationInput
    location_type_2?: location_type_2CreateNestedOneWithoutLocationInput
    location_description?: location_descriptionCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutVendorsInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
    location_description?: location_descriptionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutVendorsInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutVendorsInput, locationUncheckedCreateWithoutVendorsInput>
  }

  export type locationCreateManyVendorsInputEnvelope = {
    data: Enumerable<locationCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutVendorsInput = {
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesCreateNestedOneWithoutReservationInput
    users?: usersCreateNestedOneWithoutReservationInput
    payment?: paymentCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutVendorsInput = {
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutVendorsInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutVendorsInput, reservationUncheckedCreateWithoutVendorsInput>
  }

  export type reservationCreateManyVendorsInputEnvelope = {
    data: Enumerable<reservationCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type commission_settingUpsertWithWhereUniqueWithoutVendorsInput = {
    where: commission_settingWhereUniqueInput
    update: XOR<commission_settingUpdateWithoutVendorsInput, commission_settingUncheckedUpdateWithoutVendorsInput>
    create: XOR<commission_settingCreateWithoutVendorsInput, commission_settingUncheckedCreateWithoutVendorsInput>
  }

  export type commission_settingUpdateWithWhereUniqueWithoutVendorsInput = {
    where: commission_settingWhereUniqueInput
    data: XOR<commission_settingUpdateWithoutVendorsInput, commission_settingUncheckedUpdateWithoutVendorsInput>
  }

  export type commission_settingUpdateManyWithWhereWithoutVendorsInput = {
    where: commission_settingScalarWhereInput
    data: XOR<commission_settingUpdateManyMutationInput, commission_settingUncheckedUpdateManyWithoutCommission_settingInput>
  }

  export type commission_settingScalarWhereInput = {
    AND?: Enumerable<commission_settingScalarWhereInput>
    OR?: Enumerable<commission_settingScalarWhereInput>
    NOT?: Enumerable<commission_settingScalarWhereInput>
    id?: IntFilter | number
    vendor?: StringFilter | string
    agency?: StringFilter | string
    payment_type?: StringFilter | string
    tag?: StringFilter | string
    calculation_type?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type locationUpsertWithWhereUniqueWithoutVendorsInput = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutVendorsInput, locationUncheckedUpdateWithoutVendorsInput>
    create: XOR<locationCreateWithoutVendorsInput, locationUncheckedCreateWithoutVendorsInput>
  }

  export type locationUpdateWithWhereUniqueWithoutVendorsInput = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutVendorsInput, locationUncheckedUpdateWithoutVendorsInput>
  }

  export type locationUpdateManyWithWhereWithoutVendorsInput = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationInput>
  }

  export type reservationUpsertWithWhereUniqueWithoutVendorsInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutVendorsInput, reservationUncheckedUpdateWithoutVendorsInput>
    create: XOR<reservationCreateWithoutVendorsInput, reservationUncheckedCreateWithoutVendorsInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutVendorsInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutVendorsInput, reservationUncheckedUpdateWithoutVendorsInput>
  }

  export type reservationUpdateManyWithWhereWithoutVendorsInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type reservationScalarWhereInput = {
    AND?: Enumerable<reservationScalarWhereInput>
    OR?: Enumerable<reservationScalarWhereInput>
    NOT?: Enumerable<reservationScalarWhereInput>
    supplier?: StringNullableFilter | string | null
    agent_name?: StringNullableFilter | string | null
    agent?: StringNullableFilter | string | null
    date_request?: DateTimeNullableFilter | Date | string | null
    res_status?: StringNullableFilter | string | null
    invoice?: StringNullableFilter | string | null
    res_id?: StringFilter | string
    korean_name?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    pickup_loc?: StringNullableFilter | string | null
    return_loc?: StringNullableFilter | string | null
    pickup_datetime?: StringNullableFilter | string | null
    return_datetime?: StringNullableFilter | string | null
    pay_type?: StringNullableFilter | string | null
    currency?: StringNullableFilter | string | null
    exchange_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    user_id?: IntNullableFilter | number | null
    car_model?: StringNullableFilter | string | null
    extra_equipmens?: StringNullableFilter | string | null
    insurance_info?: StringNullableFilter | string | null
    office_address?: StringNullableFilter | string | null
    office_name?: StringNullableFilter | string | null
    office_time?: StringNullableFilter | string | null
    phone_code?: StringNullableFilter | string | null
    phone_number?: StringNullableFilter | string | null
    services?: StringNullableFilter | string | null
    size_car?: StringNullableFilter | string | null
    type_car?: StringNullableFilter | string | null
    date_cancel?: DateTimeNullableFilter | Date | string | null
    email?: StringNullableFilter | string | null
    flight_brand?: StringNullableFilter | string | null
    flight_number?: StringNullableFilter | string | null
    frequent_flyer?: StringNullableFilter | string | null
    hertz_membership?: StringNullableFilter | string | null
    office_second_address?: StringNullableFilter | string | null
    office_second_name?: StringNullableFilter | string | null
    office_second_time?: StringNullableFilter | string | null
    dropFee?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rate_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    tax?: StringNullableFilter | string | null
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type countriesCreateWithoutAirportsInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    cities?: citiesCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationCreateNestedManyWithoutCountriesInput
  }

  export type countriesUncheckedCreateWithoutAirportsInput = {
    code: string
    code_3: string
    name: string
    continent?: string | null
    currency?: string | null
    cities?: citiesUncheckedCreateNestedManyWithoutCountriesInput
    countries_translation?: countries_translationUncheckedCreateNestedManyWithoutCountriesInput
  }

  export type countriesCreateOrConnectWithoutAirportsInput = {
    where: countriesWhereUniqueInput
    create: XOR<countriesCreateWithoutAirportsInput, countriesUncheckedCreateWithoutAirportsInput>
  }

  export type countriesUpsertWithoutAirportsInput = {
    update: XOR<countriesUpdateWithoutAirportsInput, countriesUncheckedUpdateWithoutAirportsInput>
    create: XOR<countriesCreateWithoutAirportsInput, countriesUncheckedCreateWithoutAirportsInput>
  }

  export type countriesUpdateWithoutAirportsInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: citiesUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUpdateManyWithoutCountriesNestedInput
  }

  export type countriesUncheckedUpdateWithoutAirportsInput = {
    code?: StringFieldUpdateOperationsInput | string
    code_3?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    continent?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    cities?: citiesUncheckedUpdateManyWithoutCountriesNestedInput
    countries_translation?: countries_translationUncheckedUpdateManyWithoutCountriesNestedInput
  }

  export type locationCreateWithoutCategoriesInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    city_name?: string | null
    location_type_1?: location_type_1CreateNestedOneWithoutLocationInput
    location_type_2?: location_type_2CreateNestedOneWithoutLocationInput
    vendors: vendorsCreateNestedOneWithoutLocationInput
    location_description?: location_descriptionCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutCategoriesInput = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    location_description?: location_descriptionUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutCategoriesInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutCategoriesInput, locationUncheckedCreateWithoutCategoriesInput>
  }

  export type locationCreateManyCategoriesInputEnvelope = {
    data: Enumerable<locationCreateManyCategoriesInput>
    skipDuplicates?: boolean
  }

  export type locationUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutCategoriesInput, locationUncheckedUpdateWithoutCategoriesInput>
    create: XOR<locationCreateWithoutCategoriesInput, locationUncheckedCreateWithoutCategoriesInput>
  }

  export type locationUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutCategoriesInput, locationUncheckedUpdateWithoutCategoriesInput>
  }

  export type locationUpdateManyWithWhereWithoutCategoriesInput = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationInput>
  }

  export type reservationCreateWithoutPaymentInput = {
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesCreateNestedOneWithoutReservationInput
    vendors?: vendorsCreateNestedOneWithoutReservationInput
    users?: usersCreateNestedOneWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutPaymentInput = {
    supplier?: string | null
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type reservationCreateOrConnectWithoutPaymentInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutPaymentInput, reservationUncheckedCreateWithoutPaymentInput>
  }

  export type usersCreateWithoutPaymentInput = {
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    reservation?: reservationCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentInput = {
    id?: number
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    reservation?: reservationUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentInput, usersUncheckedCreateWithoutPaymentInput>
  }

  export type reservationUpsertWithoutPaymentInput = {
    update: XOR<reservationUpdateWithoutPaymentInput, reservationUncheckedUpdateWithoutPaymentInput>
    create: XOR<reservationCreateWithoutPaymentInput, reservationUncheckedCreateWithoutPaymentInput>
  }

  export type reservationUpdateWithoutPaymentInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesUpdateOneWithoutReservationNestedInput
    vendors?: vendorsUpdateOneWithoutReservationNestedInput
    users?: usersUpdateOneWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutPaymentInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type usersUpsertWithoutPaymentInput = {
    update: XOR<usersUpdateWithoutPaymentInput, usersUncheckedUpdateWithoutPaymentInput>
    create: XOR<usersCreateWithoutPaymentInput, usersUncheckedCreateWithoutPaymentInput>
  }

  export type usersUpdateWithoutPaymentInput = {
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    reservation?: reservationUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    reservation?: reservationUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type exchange_rate_historyCreateWithoutExchange_ratesInput = {
    rate: number
    date: Date | string
  }

  export type exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput = {
    id?: number
    rate: number
    date: Date | string
  }

  export type exchange_rate_historyCreateOrConnectWithoutExchange_ratesInput = {
    where: exchange_rate_historyWhereUniqueInput
    create: XOR<exchange_rate_historyCreateWithoutExchange_ratesInput, exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>
  }

  export type exchange_rate_historyCreateManyExchange_ratesInputEnvelope = {
    data: Enumerable<exchange_rate_historyCreateManyExchange_ratesInput>
    skipDuplicates?: boolean
  }

  export type exchange_rate_historyUpsertWithWhereUniqueWithoutExchange_ratesInput = {
    where: exchange_rate_historyWhereUniqueInput
    update: XOR<exchange_rate_historyUpdateWithoutExchange_ratesInput, exchange_rate_historyUncheckedUpdateWithoutExchange_ratesInput>
    create: XOR<exchange_rate_historyCreateWithoutExchange_ratesInput, exchange_rate_historyUncheckedCreateWithoutExchange_ratesInput>
  }

  export type exchange_rate_historyUpdateWithWhereUniqueWithoutExchange_ratesInput = {
    where: exchange_rate_historyWhereUniqueInput
    data: XOR<exchange_rate_historyUpdateWithoutExchange_ratesInput, exchange_rate_historyUncheckedUpdateWithoutExchange_ratesInput>
  }

  export type exchange_rate_historyUpdateManyWithWhereWithoutExchange_ratesInput = {
    where: exchange_rate_historyScalarWhereInput
    data: XOR<exchange_rate_historyUpdateManyMutationInput, exchange_rate_historyUncheckedUpdateManyWithoutExchange_rate_historyInput>
  }

  export type exchange_rate_historyScalarWhereInput = {
    AND?: Enumerable<exchange_rate_historyScalarWhereInput>
    OR?: Enumerable<exchange_rate_historyScalarWhereInput>
    NOT?: Enumerable<exchange_rate_historyScalarWhereInput>
    id?: IntFilter | number
    exchange_rate_id?: IntFilter | number
    rate?: FloatFilter | number
    date?: DateTimeFilter | Date | string
  }

  export type admin_roles_permissionsCreateWithoutAdmin_permissionsInput = {
    admin_roles: admin_rolesCreateNestedOneWithoutAdmin_roles_permissionsInput
  }

  export type admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput = {
    role_id: number
  }

  export type admin_roles_permissionsCreateOrConnectWithoutAdmin_permissionsInput = {
    where: admin_roles_permissionsWhereUniqueInput
    create: XOR<admin_roles_permissionsCreateWithoutAdmin_permissionsInput, admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>
  }

  export type admin_roles_permissionsCreateManyAdmin_permissionsInputEnvelope = {
    data: Enumerable<admin_roles_permissionsCreateManyAdmin_permissionsInput>
    skipDuplicates?: boolean
  }

  export type admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_permissionsInput = {
    where: admin_roles_permissionsWhereUniqueInput
    update: XOR<admin_roles_permissionsUpdateWithoutAdmin_permissionsInput, admin_roles_permissionsUncheckedUpdateWithoutAdmin_permissionsInput>
    create: XOR<admin_roles_permissionsCreateWithoutAdmin_permissionsInput, admin_roles_permissionsUncheckedCreateWithoutAdmin_permissionsInput>
  }

  export type admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_permissionsInput = {
    where: admin_roles_permissionsWhereUniqueInput
    data: XOR<admin_roles_permissionsUpdateWithoutAdmin_permissionsInput, admin_roles_permissionsUncheckedUpdateWithoutAdmin_permissionsInput>
  }

  export type admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_permissionsInput = {
    where: admin_roles_permissionsScalarWhereInput
    data: XOR<admin_roles_permissionsUpdateManyMutationInput, admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_roles_permissionsInput>
  }

  export type admin_roles_permissionsScalarWhereInput = {
    AND?: Enumerable<admin_roles_permissionsScalarWhereInput>
    OR?: Enumerable<admin_roles_permissionsScalarWhereInput>
    NOT?: Enumerable<admin_roles_permissionsScalarWhereInput>
    permission_id?: IntFilter | number
    role_id?: IntFilter | number
  }

  export type admin_usersCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_usersCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_roles_permissionsCreateWithoutAdmin_rolesInput = {
    admin_permissions: admin_permissionsCreateNestedOneWithoutAdmin_roles_permissionsInput
  }

  export type admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput = {
    permission_id: number
  }

  export type admin_roles_permissionsCreateOrConnectWithoutAdmin_rolesInput = {
    where: admin_roles_permissionsWhereUniqueInput
    create: XOR<admin_roles_permissionsCreateWithoutAdmin_rolesInput, admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type admin_roles_permissionsCreateManyAdmin_rolesInputEnvelope = {
    data: Enumerable<admin_roles_permissionsCreateManyAdmin_rolesInput>
    skipDuplicates?: boolean
  }

  export type admin_users_rolesCreateWithoutAdmin_rolesInput = {
    admin_users: admin_usersCreateNestedOneWithoutAdmin_users_rolesInput
  }

  export type admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput = {
    user_id: number
  }

  export type admin_users_rolesCreateOrConnectWithoutAdmin_rolesInput = {
    where: admin_users_rolesWhereUniqueInput
    create: XOR<admin_users_rolesCreateWithoutAdmin_rolesInput, admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type admin_users_rolesCreateManyAdmin_rolesInputEnvelope = {
    data: Enumerable<admin_users_rolesCreateManyAdmin_rolesInput>
    skipDuplicates?: boolean
  }

  export type admin_usersUpsertWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    update: XOR<admin_usersUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
    create: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_usersUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUpsertWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    update: XOR<admin_usersUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
    create: XOR<admin_usersCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput, admin_usersUncheckedCreateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_usersUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_roles_permissionsUpsertWithWhereUniqueWithoutAdmin_rolesInput = {
    where: admin_roles_permissionsWhereUniqueInput
    update: XOR<admin_roles_permissionsUpdateWithoutAdmin_rolesInput, admin_roles_permissionsUncheckedUpdateWithoutAdmin_rolesInput>
    create: XOR<admin_roles_permissionsCreateWithoutAdmin_rolesInput, admin_roles_permissionsUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type admin_roles_permissionsUpdateWithWhereUniqueWithoutAdmin_rolesInput = {
    where: admin_roles_permissionsWhereUniqueInput
    data: XOR<admin_roles_permissionsUpdateWithoutAdmin_rolesInput, admin_roles_permissionsUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type admin_roles_permissionsUpdateManyWithWhereWithoutAdmin_rolesInput = {
    where: admin_roles_permissionsScalarWhereInput
    data: XOR<admin_roles_permissionsUpdateManyMutationInput, admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_roles_permissionsInput>
  }

  export type admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_rolesInput = {
    where: admin_users_rolesWhereUniqueInput
    update: XOR<admin_users_rolesUpdateWithoutAdmin_rolesInput, admin_users_rolesUncheckedUpdateWithoutAdmin_rolesInput>
    create: XOR<admin_users_rolesCreateWithoutAdmin_rolesInput, admin_users_rolesUncheckedCreateWithoutAdmin_rolesInput>
  }

  export type admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_rolesInput = {
    where: admin_users_rolesWhereUniqueInput
    data: XOR<admin_users_rolesUpdateWithoutAdmin_rolesInput, admin_users_rolesUncheckedUpdateWithoutAdmin_rolesInput>
  }

  export type admin_users_rolesUpdateManyWithWhereWithoutAdmin_rolesInput = {
    where: admin_users_rolesScalarWhereInput
    data: XOR<admin_users_rolesUpdateManyMutationInput, admin_users_rolesUncheckedUpdateManyWithoutAdmin_users_rolesInput>
  }

  export type admin_users_rolesScalarWhereInput = {
    AND?: Enumerable<admin_users_rolesScalarWhereInput>
    OR?: Enumerable<admin_users_rolesScalarWhereInput>
    NOT?: Enumerable<admin_users_rolesScalarWhereInput>
    user_id?: IntFilter | number
    role_id?: IntFilter | number
  }

  export type admin_permissionsCreateWithoutAdmin_roles_permissionsInput = {
    action: string
    description?: string | null
  }

  export type admin_permissionsUncheckedCreateWithoutAdmin_roles_permissionsInput = {
    id?: number
    action: string
    description?: string | null
  }

  export type admin_permissionsCreateOrConnectWithoutAdmin_roles_permissionsInput = {
    where: admin_permissionsWhereUniqueInput
    create: XOR<admin_permissionsCreateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedCreateWithoutAdmin_roles_permissionsInput>
  }

  export type admin_rolesCreateWithoutAdmin_roles_permissionsInput = {
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUncheckedCreateWithoutAdmin_roles_permissionsInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    modified_by?: number | null
    deleted?: number | null
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesCreateOrConnectWithoutAdmin_roles_permissionsInput = {
    where: admin_rolesWhereUniqueInput
    create: XOR<admin_rolesCreateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedCreateWithoutAdmin_roles_permissionsInput>
  }

  export type admin_permissionsUpsertWithoutAdmin_roles_permissionsInput = {
    update: XOR<admin_permissionsUpdateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedUpdateWithoutAdmin_roles_permissionsInput>
    create: XOR<admin_permissionsCreateWithoutAdmin_roles_permissionsInput, admin_permissionsUncheckedCreateWithoutAdmin_roles_permissionsInput>
  }

  export type admin_permissionsUpdateWithoutAdmin_roles_permissionsInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsUncheckedUpdateWithoutAdmin_roles_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_rolesUpsertWithoutAdmin_roles_permissionsInput = {
    update: XOR<admin_rolesUpdateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedUpdateWithoutAdmin_roles_permissionsInput>
    create: XOR<admin_rolesCreateWithoutAdmin_roles_permissionsInput, admin_rolesUncheckedCreateWithoutAdmin_roles_permissionsInput>
  }

  export type admin_rolesUpdateWithoutAdmin_roles_permissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersNestedInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateWithoutAdmin_roles_permissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type agenciesCreateWithoutAdmin_usersInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    commission_setting?: commission_settingCreateNestedManyWithoutAgenciesInput
    reservation?: reservationCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesUncheckedCreateWithoutAdmin_usersInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutAgenciesInput
    reservation?: reservationUncheckedCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesCreateOrConnectWithoutAdmin_usersInput = {
    where: agenciesWhereUniqueInput
    create: XOR<agenciesCreateWithoutAdmin_usersInput, agenciesUncheckedCreateWithoutAdmin_usersInput>
  }

  export type admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    admin_roles_permissions?: admin_roles_permissionsCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    modified_by?: number | null
    deleted?: number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    create: XOR<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput, admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInputEnvelope = {
    data: Enumerable<admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInput>
    skipDuplicates?: boolean
  }

  export type admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    admin_roles_permissions?: admin_roles_permissionsCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_rolesInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesCreateOrConnectWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    create: XOR<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput, admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInputEnvelope = {
    data: Enumerable<admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInput>
    skipDuplicates?: boolean
  }

  export type admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInputEnvelope = {
    data: Enumerable<admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInput>
    skipDuplicates?: boolean
  }

  export type admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInputEnvelope = {
    data: Enumerable<admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInput>
    skipDuplicates?: boolean
  }

  export type admin_users_rolesCreateWithoutAdmin_usersInput = {
    admin_roles: admin_rolesCreateNestedOneWithoutAdmin_users_rolesInput
  }

  export type admin_users_rolesUncheckedCreateWithoutAdmin_usersInput = {
    role_id: number
  }

  export type admin_users_rolesCreateOrConnectWithoutAdmin_usersInput = {
    where: admin_users_rolesWhereUniqueInput
    create: XOR<admin_users_rolesCreateWithoutAdmin_usersInput, admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>
  }

  export type admin_users_rolesCreateManyAdmin_usersInputEnvelope = {
    data: Enumerable<admin_users_rolesCreateManyAdmin_usersInput>
    skipDuplicates?: boolean
  }

  export type agenciesUpsertWithoutAdmin_usersInput = {
    update: XOR<agenciesUpdateWithoutAdmin_usersInput, agenciesUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<agenciesCreateWithoutAdmin_usersInput, agenciesUncheckedCreateWithoutAdmin_usersInput>
  }

  export type agenciesUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commission_setting?: commission_settingUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUpdateManyWithoutAgenciesNestedInput
  }

  export type agenciesUncheckedUpdateWithoutAdmin_usersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commission_setting?: commission_settingUncheckedUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutAgenciesNestedInput
  }

  export type admin_usersUpsertWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    update: XOR<admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
    create: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUpsertWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    update: XOR<admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
    create: XOR<admin_usersCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_usersUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    update: XOR<admin_rolesUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput, admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
    create: XOR<admin_rolesCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput, admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    data: XOR<admin_rolesUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput, admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    where: admin_rolesScalarWhereInput
    data: XOR<admin_rolesUpdateManyMutationInput, admin_rolesUncheckedUpdateManyWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput>
  }

  export type admin_rolesScalarWhereInput = {
    AND?: Enumerable<admin_rolesScalarWhereInput>
    OR?: Enumerable<admin_rolesScalarWhereInput>
    NOT?: Enumerable<admin_rolesScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    modified_date?: DateTimeNullableFilter | Date | string | null
    created_by?: IntNullableFilter | number | null
    modified_by?: IntNullableFilter | number | null
    deleted?: IntNullableFilter | number | null
  }

  export type admin_rolesUpsertWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    update: XOR<admin_rolesUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput, admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
    create: XOR<admin_rolesCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput, admin_rolesUncheckedCreateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_rolesUpdateWithWhereUniqueWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    where: admin_rolesWhereUniqueInput
    data: XOR<admin_rolesUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput, admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_rolesUpdateManyWithWhereWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    where: admin_rolesScalarWhereInput
    data: XOR<admin_rolesUpdateManyMutationInput, admin_rolesUncheckedUpdateManyWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput>
  }

  export type admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    where: admin_usersWhereUniqueInput
    update: XOR<admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
    create: XOR<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    where: admin_usersWhereUniqueInput
    data: XOR<admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput, admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    where: admin_usersScalarWhereInput
    data: XOR<admin_usersUpdateManyMutationInput, admin_usersUncheckedUpdateManyWithoutOther_admin_users_admin_usersToadmin_users_created_byInput>
  }

  export type admin_usersScalarWhereInput = {
    AND?: Enumerable<admin_usersScalarWhereInput>
    OR?: Enumerable<admin_usersScalarWhereInput>
    NOT?: Enumerable<admin_usersScalarWhereInput>
    id?: IntFilter | number
    username?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    hash_pass?: StringNullableFilter | string | null
    first_name?: StringNullableFilter | string | null
    last_name?: StringFilter | string
    phone_mobile?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    created_date?: DateTimeNullableFilter | Date | string | null
    modified_date?: DateTimeNullableFilter | Date | string | null
    created_by?: IntNullableFilter | number | null
    deleted?: IntNullableFilter | number | null
    hash_rt?: StringNullableFilter | string | null
    modified_by?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    agency_id?: StringNullableFilter | string | null
  }

  export type admin_usersUpsertWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    where: admin_usersWhereUniqueInput
    update: XOR<admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
    create: XOR<admin_usersCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedCreateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_usersUpdateWithWhereUniqueWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    where: admin_usersWhereUniqueInput
    data: XOR<admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput, admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_usersUpdateManyWithWhereWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    where: admin_usersScalarWhereInput
    data: XOR<admin_usersUpdateManyMutationInput, admin_usersUncheckedUpdateManyWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput>
  }

  export type admin_users_rolesUpsertWithWhereUniqueWithoutAdmin_usersInput = {
    where: admin_users_rolesWhereUniqueInput
    update: XOR<admin_users_rolesUpdateWithoutAdmin_usersInput, admin_users_rolesUncheckedUpdateWithoutAdmin_usersInput>
    create: XOR<admin_users_rolesCreateWithoutAdmin_usersInput, admin_users_rolesUncheckedCreateWithoutAdmin_usersInput>
  }

  export type admin_users_rolesUpdateWithWhereUniqueWithoutAdmin_usersInput = {
    where: admin_users_rolesWhereUniqueInput
    data: XOR<admin_users_rolesUpdateWithoutAdmin_usersInput, admin_users_rolesUncheckedUpdateWithoutAdmin_usersInput>
  }

  export type admin_users_rolesUpdateManyWithWhereWithoutAdmin_usersInput = {
    where: admin_users_rolesScalarWhereInput
    data: XOR<admin_users_rolesUpdateManyMutationInput, admin_users_rolesUncheckedUpdateManyWithoutAdmin_users_rolesInput>
  }

  export type admin_rolesCreateWithoutAdmin_users_rolesInput = {
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersCreateNestedOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput
    admin_roles_permissions?: admin_roles_permissionsCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesUncheckedCreateWithoutAdmin_users_rolesInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    modified_by?: number | null
    deleted?: number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedCreateNestedManyWithoutAdmin_rolesInput
  }

  export type admin_rolesCreateOrConnectWithoutAdmin_users_rolesInput = {
    where: admin_rolesWhereUniqueInput
    create: XOR<admin_rolesCreateWithoutAdmin_users_rolesInput, admin_rolesUncheckedCreateWithoutAdmin_users_rolesInput>
  }

  export type admin_usersCreateWithoutAdmin_users_rolesInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agencies?: agenciesCreateNestedOneWithoutAdmin_usersInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
  }

  export type admin_usersUncheckedCreateWithoutAdmin_users_rolesInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
  }

  export type admin_usersCreateOrConnectWithoutAdmin_users_rolesInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAdmin_users_rolesInput, admin_usersUncheckedCreateWithoutAdmin_users_rolesInput>
  }

  export type admin_rolesUpsertWithoutAdmin_users_rolesInput = {
    update: XOR<admin_rolesUpdateWithoutAdmin_users_rolesInput, admin_rolesUncheckedUpdateWithoutAdmin_users_rolesInput>
    create: XOR<admin_rolesCreateWithoutAdmin_users_rolesInput, admin_rolesUncheckedCreateWithoutAdmin_users_rolesInput>
  }

  export type admin_rolesUpdateWithoutAdmin_users_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersNestedInput
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersNestedInput
    admin_roles_permissions?: admin_roles_permissionsUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateWithoutAdmin_users_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_usersUpsertWithoutAdmin_users_rolesInput = {
    update: XOR<admin_usersUpdateWithoutAdmin_users_rolesInput, admin_usersUncheckedUpdateWithoutAdmin_users_rolesInput>
    create: XOR<admin_usersCreateWithoutAdmin_users_rolesInput, admin_usersUncheckedCreateWithoutAdmin_users_rolesInput>
  }

  export type admin_usersUpdateWithoutAdmin_users_rolesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAdmin_users_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
  }

  export type paymentCreateWithoutUsersInput = {
    order_id: string
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
    reservation?: reservationCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutUsersInput = {
    order_id: string
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    reservation_id?: string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type paymentCreateOrConnectWithoutUsersInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput>
  }

  export type paymentCreateManyUsersInputEnvelope = {
    data: Enumerable<paymentCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutUsersInput = {
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesCreateNestedOneWithoutReservationInput
    vendors?: vendorsCreateNestedOneWithoutReservationInput
    payment?: paymentCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutUsersInput = {
    supplier?: string | null
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutUsersInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutUsersInput, reservationUncheckedCreateWithoutUsersInput>
  }

  export type reservationCreateManyUsersInputEnvelope = {
    data: Enumerable<reservationCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type paymentUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutUsersInput, paymentUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutUsersInput, paymentUncheckedUpdateWithoutUsersInput>
  }

  export type paymentUpdateManyWithWhereWithoutUsersInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type paymentScalarWhereInput = {
    AND?: Enumerable<paymentScalarWhereInput>
    OR?: Enumerable<paymentScalarWhereInput>
    NOT?: Enumerable<paymentScalarWhereInput>
    order_id?: StringFilter | string
    user_id?: IntNullableFilter | number | null
    IMS_commission?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    agency_id?: StringNullableFilter | string | null
    agency_name?: StringNullableFilter | string | null
    pay_type?: StringNullableFilter | string | null
    exchange_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    first_name?: StringNullableFilter | string | null
    korean_name?: StringNullableFilter | string | null
    last_name?: StringNullableFilter | string | null
    paid_agency?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: DateTimeNullableFilter | Date | string | null
    paid_supplier?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    basic_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    net?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    commission?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter | string | null
    service_total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    service_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    reservation_id?: StringNullableFilter | string | null
    supplier?: StringNullableFilter | string | null
    imp_uid?: StringNullableFilter | string | null
    merchant_uid?: StringNullableFilter | string | null
    etc_rate?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    pg_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: DateTimeNullableFilter | Date | string | null
  }

  export type reservationUpsertWithWhereUniqueWithoutUsersInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutUsersInput, reservationUncheckedUpdateWithoutUsersInput>
    create: XOR<reservationCreateWithoutUsersInput, reservationUncheckedCreateWithoutUsersInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutUsersInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutUsersInput, reservationUncheckedUpdateWithoutUsersInput>
  }

  export type reservationUpdateManyWithWhereWithoutUsersInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type price_codesCreateWithoutPackagesInput = {
    id: string
    price_code: string
    country_code: string
    name?: string | null
    price_type?: string | null
    vendor_id?: string | null
    ITCode?: string | null
    cdpNumber?: string | null
    show?: boolean | null
    insurance?: boolean | null
    ko_name?: string | null
  }

  export type price_codesUncheckedCreateWithoutPackagesInput = {
    id: string
    price_code: string
    country_code: string
    name?: string | null
    price_type?: string | null
    vendor_id?: string | null
    ITCode?: string | null
    cdpNumber?: string | null
    show?: boolean | null
    insurance?: boolean | null
    ko_name?: string | null
  }

  export type price_codesCreateOrConnectWithoutPackagesInput = {
    where: price_codesWhereUniqueInput
    create: XOR<price_codesCreateWithoutPackagesInput, price_codesUncheckedCreateWithoutPackagesInput>
  }

  export type servicesCreateWithoutPackagesInput = {
    id: string
    description?: string | null
    ko_description?: string | null
    details?: string | null
    order?: number | null
  }

  export type servicesUncheckedCreateWithoutPackagesInput = {
    id: string
    description?: string | null
    ko_description?: string | null
    details?: string | null
    order?: number | null
  }

  export type servicesCreateOrConnectWithoutPackagesInput = {
    where: servicesWhereUniqueInput
    create: XOR<servicesCreateWithoutPackagesInput, servicesUncheckedCreateWithoutPackagesInput>
  }

  export type price_codesUpsertWithoutPackagesInput = {
    update: XOR<price_codesUpdateWithoutPackagesInput, price_codesUncheckedUpdateWithoutPackagesInput>
    create: XOR<price_codesCreateWithoutPackagesInput, price_codesUncheckedCreateWithoutPackagesInput>
  }

  export type price_codesUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type price_codesUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: NullableStringFieldUpdateOperationsInput | string | null
    ITCode?: NullableStringFieldUpdateOperationsInput | string | null
    cdpNumber?: NullableStringFieldUpdateOperationsInput | string | null
    show?: NullableBoolFieldUpdateOperationsInput | boolean | null
    insurance?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ko_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicesUpsertWithoutPackagesInput = {
    update: XOR<servicesUpdateWithoutPackagesInput, servicesUncheckedUpdateWithoutPackagesInput>
    create: XOR<servicesCreateWithoutPackagesInput, servicesUncheckedCreateWithoutPackagesInput>
  }

  export type servicesUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicesUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ko_description?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type packagesCreateWithoutPrice_codesInput = {
    services: servicesCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutPrice_codesInput = {
    service_id: string
  }

  export type packagesCreateOrConnectWithoutPrice_codesInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutPrice_codesInput, packagesUncheckedCreateWithoutPrice_codesInput>
  }

  export type packagesCreateManyPrice_codesInputEnvelope = {
    data: Enumerable<packagesCreateManyPrice_codesInput>
    skipDuplicates?: boolean
  }

  export type packagesUpsertWithWhereUniqueWithoutPrice_codesInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutPrice_codesInput, packagesUncheckedUpdateWithoutPrice_codesInput>
    create: XOR<packagesCreateWithoutPrice_codesInput, packagesUncheckedCreateWithoutPrice_codesInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutPrice_codesInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutPrice_codesInput, packagesUncheckedUpdateWithoutPrice_codesInput>
  }

  export type packagesUpdateManyWithWhereWithoutPrice_codesInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutPackagesInput>
  }

  export type packagesScalarWhereInput = {
    AND?: Enumerable<packagesScalarWhereInput>
    OR?: Enumerable<packagesScalarWhereInput>
    NOT?: Enumerable<packagesScalarWhereInput>
    price_id?: StringFilter | string
    service_id?: StringFilter | string
  }

  export type agenciesCreateWithoutReservationInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersCreateNestedManyWithoutAgenciesInput
    commission_setting?: commission_settingCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesUncheckedCreateWithoutReservationInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersUncheckedCreateNestedManyWithoutAgenciesInput
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesCreateOrConnectWithoutReservationInput = {
    where: agenciesWhereUniqueInput
    create: XOR<agenciesCreateWithoutReservationInput, agenciesUncheckedCreateWithoutReservationInput>
  }

  export type vendorsCreateWithoutReservationInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingCreateNestedManyWithoutVendorsInput
    location?: locationCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutReservationInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    commission_setting?: commission_settingUncheckedCreateNestedManyWithoutVendorsInput
    location?: locationUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutReservationInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutReservationInput, vendorsUncheckedCreateWithoutReservationInput>
  }

  export type usersCreateWithoutReservationInput = {
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    payment?: paymentCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReservationInput = {
    id?: number
    email: string
    hash_pass?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    phone?: string | null
    login_type?: string | null
    external_id?: string | null
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    phone_prefix?: string | null
    refund_bank?: string | null
    refund_account_number?: string | null
    refund_account_holder?: string | null
    address?: string | null
    hertz_membership?: string | null
    airline?: string | null
    mileage_number?: string | null
    mailing_email?: number | null
    mailing_text_msg?: number | null
    birthdate?: string | null
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReservationInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReservationInput, usersUncheckedCreateWithoutReservationInput>
  }

  export type paymentCreateWithoutReservationInput = {
    order_id: string
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
    users?: usersCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutReservationInput = {
    order_id: string
    user_id?: number | null
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type paymentCreateOrConnectWithoutReservationInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutReservationInput, paymentUncheckedCreateWithoutReservationInput>
  }

  export type paymentCreateManyReservationInputEnvelope = {
    data: Enumerable<paymentCreateManyReservationInput>
    skipDuplicates?: boolean
  }

  export type agenciesUpsertWithoutReservationInput = {
    update: XOR<agenciesUpdateWithoutReservationInput, agenciesUncheckedUpdateWithoutReservationInput>
    create: XOR<agenciesCreateWithoutReservationInput, agenciesUncheckedCreateWithoutReservationInput>
  }

  export type agenciesUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUpdateManyWithoutAgenciesNestedInput
    commission_setting?: commission_settingUpdateManyWithoutAgenciesNestedInput
  }

  export type agenciesUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUncheckedUpdateManyWithoutAgenciesNestedInput
    commission_setting?: commission_settingUncheckedUpdateManyWithoutAgenciesNestedInput
  }

  export type vendorsUpsertWithoutReservationInput = {
    update: XOR<vendorsUpdateWithoutReservationInput, vendorsUncheckedUpdateWithoutReservationInput>
    create: XOR<vendorsCreateWithoutReservationInput, vendorsUncheckedCreateWithoutReservationInput>
  }

  export type vendorsUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUpdateManyWithoutVendorsNestedInput
    location?: locationUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    commission_setting?: commission_settingUncheckedUpdateManyWithoutVendorsNestedInput
    location?: locationUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type usersUpsertWithoutReservationInput = {
    update: XOR<usersUpdateWithoutReservationInput, usersUncheckedUpdateWithoutReservationInput>
    create: XOR<usersCreateWithoutReservationInput, usersUncheckedCreateWithoutReservationInput>
  }

  export type usersUpdateWithoutReservationInput = {
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    login_type?: NullableStringFieldUpdateOperationsInput | string | null
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_prefix?: NullableStringFieldUpdateOperationsInput | string | null
    refund_bank?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_number?: NullableStringFieldUpdateOperationsInput | string | null
    refund_account_holder?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    airline?: NullableStringFieldUpdateOperationsInput | string | null
    mileage_number?: NullableStringFieldUpdateOperationsInput | string | null
    mailing_email?: NullableIntFieldUpdateOperationsInput | number | null
    mailing_text_msg?: NullableIntFieldUpdateOperationsInput | number | null
    birthdate?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type paymentUpsertWithWhereUniqueWithoutReservationInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutReservationInput, paymentUncheckedUpdateWithoutReservationInput>
    create: XOR<paymentCreateWithoutReservationInput, paymentUncheckedCreateWithoutReservationInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutReservationInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutReservationInput, paymentUncheckedUpdateWithoutReservationInput>
  }

  export type paymentUpdateManyWithWhereWithoutReservationInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type packagesCreateWithoutServicesInput = {
    price_codes: price_codesCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutServicesInput = {
    price_id: string
  }

  export type packagesCreateOrConnectWithoutServicesInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutServicesInput, packagesUncheckedCreateWithoutServicesInput>
  }

  export type packagesCreateManyServicesInputEnvelope = {
    data: Enumerable<packagesCreateManyServicesInput>
    skipDuplicates?: boolean
  }

  export type packagesUpsertWithWhereUniqueWithoutServicesInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutServicesInput, packagesUncheckedUpdateWithoutServicesInput>
    create: XOR<packagesCreateWithoutServicesInput, packagesUncheckedCreateWithoutServicesInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutServicesInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutServicesInput, packagesUncheckedUpdateWithoutServicesInput>
  }

  export type packagesUpdateManyWithWhereWithoutServicesInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutPackagesInput>
  }

  export type admin_usersCreateWithoutAgenciesInput = {
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_created_byInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersUncheckedCreateWithoutAgenciesInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_created_byToadmin_usersInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedCreateNestedManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_created_byInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedCreateNestedManyWithoutAdmin_users_admin_usersToadmin_users_modified_byInput
    admin_users_roles?: admin_users_rolesUncheckedCreateNestedManyWithoutAdmin_usersInput
  }

  export type admin_usersCreateOrConnectWithoutAgenciesInput = {
    where: admin_usersWhereUniqueInput
    create: XOR<admin_usersCreateWithoutAgenciesInput, admin_usersUncheckedCreateWithoutAgenciesInput>
  }

  export type admin_usersCreateManyAgenciesInputEnvelope = {
    data: Enumerable<admin_usersCreateManyAgenciesInput>
    skipDuplicates?: boolean
  }

  export type commission_settingCreateWithoutAgenciesInput = {
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
    vendors: vendorsCreateNestedOneWithoutCommission_settingInput
  }

  export type commission_settingUncheckedCreateWithoutAgenciesInput = {
    id?: number
    vendor: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type commission_settingCreateOrConnectWithoutAgenciesInput = {
    where: commission_settingWhereUniqueInput
    create: XOR<commission_settingCreateWithoutAgenciesInput, commission_settingUncheckedCreateWithoutAgenciesInput>
  }

  export type commission_settingCreateManyAgenciesInputEnvelope = {
    data: Enumerable<commission_settingCreateManyAgenciesInput>
    skipDuplicates?: boolean
  }

  export type reservationCreateWithoutAgenciesInput = {
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    vendors?: vendorsCreateNestedOneWithoutReservationInput
    users?: usersCreateNestedOneWithoutReservationInput
    payment?: paymentCreateNestedManyWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutAgenciesInput = {
    supplier?: string | null
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedCreateNestedManyWithoutReservationInput
  }

  export type reservationCreateOrConnectWithoutAgenciesInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutAgenciesInput, reservationUncheckedCreateWithoutAgenciesInput>
  }

  export type reservationCreateManyAgenciesInputEnvelope = {
    data: Enumerable<reservationCreateManyAgenciesInput>
    skipDuplicates?: boolean
  }

  export type admin_usersUpsertWithWhereUniqueWithoutAgenciesInput = {
    where: admin_usersWhereUniqueInput
    update: XOR<admin_usersUpdateWithoutAgenciesInput, admin_usersUncheckedUpdateWithoutAgenciesInput>
    create: XOR<admin_usersCreateWithoutAgenciesInput, admin_usersUncheckedCreateWithoutAgenciesInput>
  }

  export type admin_usersUpdateWithWhereUniqueWithoutAgenciesInput = {
    where: admin_usersWhereUniqueInput
    data: XOR<admin_usersUpdateWithoutAgenciesInput, admin_usersUncheckedUpdateWithoutAgenciesInput>
  }

  export type admin_usersUpdateManyWithWhereWithoutAgenciesInput = {
    where: admin_usersScalarWhereInput
    data: XOR<admin_usersUpdateManyMutationInput, admin_usersUncheckedUpdateManyWithoutAdmin_usersInput>
  }

  export type commission_settingUpsertWithWhereUniqueWithoutAgenciesInput = {
    where: commission_settingWhereUniqueInput
    update: XOR<commission_settingUpdateWithoutAgenciesInput, commission_settingUncheckedUpdateWithoutAgenciesInput>
    create: XOR<commission_settingCreateWithoutAgenciesInput, commission_settingUncheckedCreateWithoutAgenciesInput>
  }

  export type commission_settingUpdateWithWhereUniqueWithoutAgenciesInput = {
    where: commission_settingWhereUniqueInput
    data: XOR<commission_settingUpdateWithoutAgenciesInput, commission_settingUncheckedUpdateWithoutAgenciesInput>
  }

  export type commission_settingUpdateManyWithWhereWithoutAgenciesInput = {
    where: commission_settingScalarWhereInput
    data: XOR<commission_settingUpdateManyMutationInput, commission_settingUncheckedUpdateManyWithoutCommission_settingInput>
  }

  export type reservationUpsertWithWhereUniqueWithoutAgenciesInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutAgenciesInput, reservationUncheckedUpdateWithoutAgenciesInput>
    create: XOR<reservationCreateWithoutAgenciesInput, reservationUncheckedCreateWithoutAgenciesInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutAgenciesInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutAgenciesInput, reservationUncheckedUpdateWithoutAgenciesInput>
  }

  export type reservationUpdateManyWithWhereWithoutAgenciesInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type agenciesCreateWithoutCommission_settingInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersCreateNestedManyWithoutAgenciesInput
    reservation?: reservationCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesUncheckedCreateWithoutCommission_settingInput = {
    id: string
    name: string
    logo?: string | null
    created_date?: Date | string | null
    admin_users?: admin_usersUncheckedCreateNestedManyWithoutAgenciesInput
    reservation?: reservationUncheckedCreateNestedManyWithoutAgenciesInput
  }

  export type agenciesCreateOrConnectWithoutCommission_settingInput = {
    where: agenciesWhereUniqueInput
    create: XOR<agenciesCreateWithoutCommission_settingInput, agenciesUncheckedCreateWithoutCommission_settingInput>
  }

  export type vendorsCreateWithoutCommission_settingInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    location?: locationCreateNestedManyWithoutVendorsInput
    reservation?: reservationCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutCommission_settingInput = {
    id: string
    name: string
    logo?: string | null
    isActive?: boolean | null
    location?: locationUncheckedCreateNestedManyWithoutVendorsInput
    reservation?: reservationUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutCommission_settingInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutCommission_settingInput, vendorsUncheckedCreateWithoutCommission_settingInput>
  }

  export type agenciesUpsertWithoutCommission_settingInput = {
    update: XOR<agenciesUpdateWithoutCommission_settingInput, agenciesUncheckedUpdateWithoutCommission_settingInput>
    create: XOR<agenciesCreateWithoutCommission_settingInput, agenciesUncheckedCreateWithoutCommission_settingInput>
  }

  export type agenciesUpdateWithoutCommission_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUpdateManyWithoutAgenciesNestedInput
  }

  export type agenciesUncheckedUpdateWithoutCommission_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    admin_users?: admin_usersUncheckedUpdateManyWithoutAgenciesNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutAgenciesNestedInput
  }

  export type vendorsUpsertWithoutCommission_settingInput = {
    update: XOR<vendorsUpdateWithoutCommission_settingInput, vendorsUncheckedUpdateWithoutCommission_settingInput>
    create: XOR<vendorsCreateWithoutCommission_settingInput, vendorsUncheckedCreateWithoutCommission_settingInput>
  }

  export type vendorsUpdateWithoutCommission_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: locationUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutCommission_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    location?: locationUncheckedUpdateManyWithoutVendorsNestedInput
    reservation?: reservationUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type subject_faqCreateWithoutFaqInput = {
    name: string
  }

  export type subject_faqUncheckedCreateWithoutFaqInput = {
    id?: number
    name: string
  }

  export type subject_faqCreateOrConnectWithoutFaqInput = {
    where: subject_faqWhereUniqueInput
    create: XOR<subject_faqCreateWithoutFaqInput, subject_faqUncheckedCreateWithoutFaqInput>
  }

  export type keyword_faqCreateWithoutFaqInput = {
    name: string
  }

  export type keyword_faqUncheckedCreateWithoutFaqInput = {
    id?: number
    name: string
  }

  export type keyword_faqCreateOrConnectWithoutFaqInput = {
    where: keyword_faqWhereUniqueInput
    create: XOR<keyword_faqCreateWithoutFaqInput, keyword_faqUncheckedCreateWithoutFaqInput>
  }

  export type keyword_faqCreateManyFaqInputEnvelope = {
    data: Enumerable<keyword_faqCreateManyFaqInput>
    skipDuplicates?: boolean
  }

  export type subject_faqUpsertWithoutFaqInput = {
    update: XOR<subject_faqUpdateWithoutFaqInput, subject_faqUncheckedUpdateWithoutFaqInput>
    create: XOR<subject_faqCreateWithoutFaqInput, subject_faqUncheckedCreateWithoutFaqInput>
  }

  export type subject_faqUpdateWithoutFaqInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type subject_faqUncheckedUpdateWithoutFaqInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type keyword_faqUpsertWithWhereUniqueWithoutFaqInput = {
    where: keyword_faqWhereUniqueInput
    update: XOR<keyword_faqUpdateWithoutFaqInput, keyword_faqUncheckedUpdateWithoutFaqInput>
    create: XOR<keyword_faqCreateWithoutFaqInput, keyword_faqUncheckedCreateWithoutFaqInput>
  }

  export type keyword_faqUpdateWithWhereUniqueWithoutFaqInput = {
    where: keyword_faqWhereUniqueInput
    data: XOR<keyword_faqUpdateWithoutFaqInput, keyword_faqUncheckedUpdateWithoutFaqInput>
  }

  export type keyword_faqUpdateManyWithWhereWithoutFaqInput = {
    where: keyword_faqScalarWhereInput
    data: XOR<keyword_faqUpdateManyMutationInput, keyword_faqUncheckedUpdateManyWithoutKeyword_faqInput>
  }

  export type keyword_faqScalarWhereInput = {
    AND?: Enumerable<keyword_faqScalarWhereInput>
    OR?: Enumerable<keyword_faqScalarWhereInput>
    NOT?: Enumerable<keyword_faqScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    faq_id?: IntFilter | number
  }

  export type exchange_ratesCreateWithoutExchange_rate_historyInput = {
    from_code: string
    to_code: string
    rate: number
  }

  export type exchange_ratesUncheckedCreateWithoutExchange_rate_historyInput = {
    id?: number
    from_code: string
    to_code: string
    rate: number
  }

  export type exchange_ratesCreateOrConnectWithoutExchange_rate_historyInput = {
    where: exchange_ratesWhereUniqueInput
    create: XOR<exchange_ratesCreateWithoutExchange_rate_historyInput, exchange_ratesUncheckedCreateWithoutExchange_rate_historyInput>
  }

  export type exchange_ratesUpsertWithoutExchange_rate_historyInput = {
    update: XOR<exchange_ratesUpdateWithoutExchange_rate_historyInput, exchange_ratesUncheckedUpdateWithoutExchange_rate_historyInput>
    create: XOR<exchange_ratesCreateWithoutExchange_rate_historyInput, exchange_ratesUncheckedCreateWithoutExchange_rate_historyInput>
  }

  export type exchange_ratesUpdateWithoutExchange_rate_historyInput = {
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type exchange_ratesUncheckedUpdateWithoutExchange_rate_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    from_code?: StringFieldUpdateOperationsInput | string
    to_code?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type faqCreateWithoutSubject_faqInput = {
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    keyword_faq?: keyword_faqCreateNestedManyWithoutFaqInput
  }

  export type faqUncheckedCreateWithoutSubject_faqInput = {
    id?: number
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    keyword_faq?: keyword_faqUncheckedCreateNestedManyWithoutFaqInput
  }

  export type faqCreateOrConnectWithoutSubject_faqInput = {
    where: faqWhereUniqueInput
    create: XOR<faqCreateWithoutSubject_faqInput, faqUncheckedCreateWithoutSubject_faqInput>
  }

  export type faqCreateManySubject_faqInputEnvelope = {
    data: Enumerable<faqCreateManySubject_faqInput>
    skipDuplicates?: boolean
  }

  export type faqUpsertWithWhereUniqueWithoutSubject_faqInput = {
    where: faqWhereUniqueInput
    update: XOR<faqUpdateWithoutSubject_faqInput, faqUncheckedUpdateWithoutSubject_faqInput>
    create: XOR<faqCreateWithoutSubject_faqInput, faqUncheckedCreateWithoutSubject_faqInput>
  }

  export type faqUpdateWithWhereUniqueWithoutSubject_faqInput = {
    where: faqWhereUniqueInput
    data: XOR<faqUpdateWithoutSubject_faqInput, faqUncheckedUpdateWithoutSubject_faqInput>
  }

  export type faqUpdateManyWithWhereWithoutSubject_faqInput = {
    where: faqScalarWhereInput
    data: XOR<faqUpdateManyMutationInput, faqUncheckedUpdateManyWithoutFaqInput>
  }

  export type faqScalarWhereInput = {
    AND?: Enumerable<faqScalarWhereInput>
    OR?: Enumerable<faqScalarWhereInput>
    NOT?: Enumerable<faqScalarWhereInput>
    id?: IntFilter | number
    question_kr?: StringFilter | string
    question_us?: StringNullableFilter | string | null
    answer_kr?: StringFilter | string
    answer_us?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    sort_order?: IntFilter | number
    subject_id?: IntNullableFilter | number | null
  }

  export type faqCreateWithoutKeyword_faqInput = {
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    subject_faq?: subject_faqCreateNestedOneWithoutFaqInput
  }

  export type faqUncheckedCreateWithoutKeyword_faqInput = {
    id?: number
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
    subject_id?: number | null
  }

  export type faqCreateOrConnectWithoutKeyword_faqInput = {
    where: faqWhereUniqueInput
    create: XOR<faqCreateWithoutKeyword_faqInput, faqUncheckedCreateWithoutKeyword_faqInput>
  }

  export type faqUpsertWithoutKeyword_faqInput = {
    update: XOR<faqUpdateWithoutKeyword_faqInput, faqUncheckedUpdateWithoutKeyword_faqInput>
    create: XOR<faqCreateWithoutKeyword_faqInput, faqUncheckedCreateWithoutKeyword_faqInput>
  }

  export type faqUpdateWithoutKeyword_faqInput = {
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    subject_faq?: subject_faqUpdateOneWithoutFaqNestedInput
  }

  export type faqUncheckedUpdateWithoutKeyword_faqInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    subject_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cities_translationCreateManyCitiesInput = {
    locale: string
    city_name: string
  }

  export type cities_translationUpdateWithoutCitiesInput = {
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_translationUncheckedUpdateWithoutCitiesInput = {
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type cities_translationUncheckedUpdateManyWithoutCities_translationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    city_name?: StringFieldUpdateOperationsInput | string
  }

  export type translationCreateManyLocalesInput = {
    message: string
    tag: string
  }

  export type translationUpdateWithoutLocalesInput = {
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateWithoutLocalesInput = {
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type translationUncheckedUpdateManyWithoutTranslationInput = {
    message?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type location_descriptionCreateManyLocationInput = {
    locale: string
    description?: string | null
    address_1?: string | null
    address_2?: string | null
    address_3?: string | null
  }

  export type location_descriptionUpdateWithoutLocationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_descriptionUncheckedUpdateWithoutLocationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type location_descriptionUncheckedUpdateManyWithoutLocation_descriptionInput = {
    locale?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_1?: NullableStringFieldUpdateOperationsInput | string | null
    address_2?: NullableStringFieldUpdateOperationsInput | string | null
    address_3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type airportsCreateManyCountriesInput = {
    iata_code: string
    icao_code: string
    name: string
    latitude: number
    longitude: number
    id?: number
  }

  export type citiesCreateManyCountriesInput = {
    code: string
    name: string
    un_locode?: string | null
    latitude?: number | null
    longitude?: number | null
    alt?: number | null
    timezone?: string | null
  }

  export type countries_translationCreateManyCountriesInput = {
    locale: string
    country_name: string
  }

  export type airportsUpdateWithoutCountriesInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
  }

  export type airportsUncheckedUpdateWithoutCountriesInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type airportsUncheckedUpdateManyWithoutAirportsInput = {
    iata_code?: StringFieldUpdateOperationsInput | string
    icao_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    latitude?: IntFieldUpdateOperationsInput | number
    longitude?: IntFieldUpdateOperationsInput | number
    id?: IntFieldUpdateOperationsInput | number
  }

  export type citiesUpdateWithoutCountriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    cities_translation?: cities_translationUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateWithoutCountriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    cities_translation?: cities_translationUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateManyWithoutCitiesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    un_locode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableIntFieldUpdateOperationsInput | number | null
    longitude?: NullableIntFieldUpdateOperationsInput | number | null
    alt?: NullableIntFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type countries_translationUpdateWithoutCountriesInput = {
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type countries_translationUncheckedUpdateWithoutCountriesInput = {
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type countries_translationUncheckedUpdateManyWithoutCountries_translationInput = {
    locale?: StringFieldUpdateOperationsInput | string
    country_name?: StringFieldUpdateOperationsInput | string
  }

  export type locationCreateManyLocation_type_1Input = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
  }

  export type locationUpdateWithoutLocation_type_1Input = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateOneWithoutLocationNestedInput
    location_type_2?: location_type_2UpdateOneWithoutLocationNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutLocationNestedInput
    location_description?: location_descriptionUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutLocation_type_1Input = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_description?: location_descriptionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationCreateManyLocation_type_2Input = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    city_name?: string | null
    category_id?: string | null
  }

  export type locationUpdateWithoutLocation_type_2Input = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateOneWithoutLocationNestedInput
    location_type_1?: location_type_1UpdateOneWithoutLocationNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutLocationNestedInput
    location_description?: location_descriptionUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutLocation_type_2Input = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_description?: location_descriptionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type commission_settingCreateManyVendorsInput = {
    id?: number
    agency: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type locationCreateManyVendorsInput = {
    id: string
    city_code?: string | null
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
    category_id?: string | null
  }

  export type reservationCreateManyVendorsInput = {
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type commission_settingUpdateWithoutVendorsInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    agencies?: agenciesUpdateOneRequiredWithoutCommission_settingNestedInput
  }

  export type commission_settingUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    agency?: StringFieldUpdateOperationsInput | string
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type commission_settingUncheckedUpdateManyWithoutCommission_settingInput = {
    id?: IntFieldUpdateOperationsInput | number
    agency?: StringFieldUpdateOperationsInput | string
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type locationUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: categoriesUpdateOneWithoutLocationNestedInput
    location_type_1?: location_type_1UpdateOneWithoutLocationNestedInput
    location_type_2?: location_type_2UpdateOneWithoutLocationNestedInput
    location_description?: location_descriptionUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    location_description?: location_descriptionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type reservationUpdateWithoutVendorsInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesUpdateOneWithoutReservationNestedInput
    users?: usersUpdateOneWithoutReservationNestedInput
    payment?: paymentUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutVendorsInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateManyWithoutReservationInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type locationCreateManyCategoriesInput = {
    id: string
    city_code?: string | null
    vendor_id: string
    oag_code?: string | null
    country_code?: string | null
    state?: string | null
    zip_code?: string | null
    phone?: string | null
    alt_phone?: string | null
    fax?: string | null
    telex?: string | null
    web_url?: string | null
    email?: string | null
    latitude?: string | null
    longitude?: string | null
    open_1_mon?: string | null
    close_1_mon?: string | null
    open_2_mon?: string | null
    close_2_mon?: string | null
    open_3_mon?: string | null
    close_3_mon?: string | null
    open_1_tue?: string | null
    close_1_tue?: string | null
    open_2_tue?: string | null
    close_2_tue?: string | null
    open_3_tue?: string | null
    close_3_tue?: string | null
    open_1_wed?: string | null
    close_1_wed?: string | null
    open_2_wed?: string | null
    close_2_wed?: string | null
    open_3_wed?: string | null
    close_3_wed?: string | null
    open_1_thu?: string | null
    close_1_thu?: string | null
    open_2_thu?: string | null
    close_2_thu?: string | null
    open_3_thu?: string | null
    close_3_thu?: string | null
    open_1_fri?: string | null
    close_1_fri?: string | null
    open_2_fri?: string | null
    close_2_fri?: string | null
    open_3_fri?: string | null
    close_3_fri?: string | null
    open_1_sat?: string | null
    close_1_sat?: string | null
    open_2_sat?: string | null
    close_2_sat?: string | null
    open_3_sat?: string | null
    close_3_sat?: string | null
    open_1_sun?: string | null
    close_1_sun?: string | null
    open_2_sun?: string | null
    close_2_sun?: string | null
    open_3_sun?: string | null
    close_3_sun?: string | null
    loc_type_1?: string | null
    loc_type_2?: string | null
    city_name?: string | null
  }

  export type locationUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_type_1?: location_type_1UpdateOneWithoutLocationNestedInput
    location_type_2?: location_type_2UpdateOneWithoutLocationNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutLocationNestedInput
    location_description?: location_descriptionUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_code?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    oag_code?: NullableStringFieldUpdateOperationsInput | string | null
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    alt_phone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    telex?: NullableStringFieldUpdateOperationsInput | string | null
    web_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_mon?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_tue?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_wed?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_thu?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_fri?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sat?: NullableStringFieldUpdateOperationsInput | string | null
    open_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_1_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_2_sun?: NullableStringFieldUpdateOperationsInput | string | null
    open_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    close_3_sun?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_1?: NullableStringFieldUpdateOperationsInput | string | null
    loc_type_2?: NullableStringFieldUpdateOperationsInput | string | null
    city_name?: NullableStringFieldUpdateOperationsInput | string | null
    location_description?: location_descriptionUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type exchange_rate_historyCreateManyExchange_ratesInput = {
    id?: number
    rate: number
    date: Date | string
  }

  export type exchange_rate_historyUpdateWithoutExchange_ratesInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_rate_historyUncheckedUpdateWithoutExchange_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_rate_historyUncheckedUpdateManyWithoutExchange_rate_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type admin_roles_permissionsCreateManyAdmin_permissionsInput = {
    role_id: number
  }

  export type admin_roles_permissionsUpdateWithoutAdmin_permissionsInput = {
    admin_roles?: admin_rolesUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput
  }

  export type admin_roles_permissionsUncheckedUpdateWithoutAdmin_permissionsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_roles_permissionsInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_roles_permissionsCreateManyAdmin_rolesInput = {
    permission_id: number
  }

  export type admin_users_rolesCreateManyAdmin_rolesInput = {
    user_id: number
  }

  export type admin_roles_permissionsUpdateWithoutAdmin_rolesInput = {
    admin_permissions?: admin_permissionsUpdateOneRequiredWithoutAdmin_roles_permissionsNestedInput
  }

  export type admin_roles_permissionsUncheckedUpdateWithoutAdmin_rolesInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_users_rolesUpdateWithoutAdmin_rolesInput = {
    admin_users?: admin_usersUpdateOneRequiredWithoutAdmin_users_rolesNestedInput
  }

  export type admin_users_rolesUncheckedUpdateWithoutAdmin_rolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_users_rolesUncheckedUpdateManyWithoutAdmin_users_rolesInput = {
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type admin_rolesCreateManyAdmin_users_admin_roles_created_byToadmin_usersInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    modified_by?: number | null
    deleted?: number | null
  }

  export type admin_rolesCreateManyAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    id?: number
    name: string
    description?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
  }

  export type admin_usersCreateManyAdmin_users_admin_usersToadmin_users_created_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
    agency_id?: string | null
  }

  export type admin_usersCreateManyAdmin_users_admin_usersToadmin_users_modified_byInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    status?: string | null
    agency_id?: string | null
  }

  export type admin_users_rolesCreateManyAdmin_usersInput = {
    role_id: number
  }

  export type admin_rolesUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_admin_roles_modified_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_modified_byToadmin_usersNestedInput
    admin_roles_permissions?: admin_roles_permissionsUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_created_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateManyWithoutAdmin_roles_admin_roles_created_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type admin_rolesUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_users_admin_roles_created_byToadmin_users?: admin_usersUpdateOneWithoutAdmin_roles_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_permissions?: admin_roles_permissionsUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateWithoutAdmin_users_admin_roles_modified_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    admin_roles_permissions?: admin_roles_permissionsUncheckedUpdateManyWithoutAdmin_rolesNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_rolesNestedInput
  }

  export type admin_rolesUncheckedUpdateManyWithoutAdmin_roles_admin_roles_modified_byToadmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_created_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateManyWithoutOther_admin_users_admin_usersToadmin_users_created_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_usersUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agencies?: agenciesUpdateOneWithoutAdmin_usersNestedInput
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAdmin_users_admin_usersToadmin_users_modified_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateManyWithoutOther_admin_users_admin_usersToadmin_users_modified_byInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_users_rolesUpdateWithoutAdmin_usersInput = {
    admin_roles?: admin_rolesUpdateOneRequiredWithoutAdmin_users_rolesNestedInput
  }

  export type admin_users_rolesUncheckedUpdateWithoutAdmin_usersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type paymentCreateManyUsersInput = {
    order_id: string
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    reservation_id?: string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type reservationCreateManyUsersInput = {
    supplier?: string | null
    agent_name?: string | null
    agent?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type paymentUpdateWithoutUsersInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reservation?: reservationUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutUsersInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentUncheckedUpdateManyWithoutPaymentInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reservation_id?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reservationUpdateWithoutUsersInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agencies?: agenciesUpdateOneWithoutReservationNestedInput
    vendors?: vendorsUpdateOneWithoutReservationNestedInput
    payment?: paymentUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutUsersInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type packagesCreateManyPrice_codesInput = {
    service_id: string
  }

  export type packagesUpdateWithoutPrice_codesInput = {
    services?: servicesUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutPrice_codesInput = {
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type packagesUncheckedUpdateManyWithoutPackagesInput = {
    service_id?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateManyReservationInput = {
    order_id: string
    user_id?: number | null
    IMS_commission?: Decimal | DecimalJsLike | number | string | null
    agency_id?: string | null
    agency_name?: string | null
    pay_type?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    first_name?: string | null
    korean_name?: string | null
    last_name?: string | null
    paid_agency?: Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: Date | string | null
    paid_supplier?: Decimal | DecimalJsLike | number | string | null
    basic_rate?: Decimal | DecimalJsLike | number | string | null
    net?: Decimal | DecimalJsLike | number | string | null
    commission?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    service_total_amount?: Decimal | DecimalJsLike | number | string | null
    service_rate?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    imp_uid?: string | null
    merchant_uid?: string | null
    etc_rate?: Decimal | DecimalJsLike | number | string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    pg_amount?: Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: Date | string | null
  }

  export type paymentUpdateWithoutReservationInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutReservationInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    IMS_commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    agency_id?: NullableStringFieldUpdateOperationsInput | string | null
    agency_name?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    paid_agency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_supplier_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paid_supplier?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    basic_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    net?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    commission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    service_total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    imp_uid?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_uid?: NullableStringFieldUpdateOperationsInput | string | null
    etc_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pg_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paid_agency_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type packagesCreateManyServicesInput = {
    price_id: string
  }

  export type packagesUpdateWithoutServicesInput = {
    price_codes?: price_codesUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutServicesInput = {
    price_id?: StringFieldUpdateOperationsInput | string
  }

  export type admin_usersCreateManyAgenciesInput = {
    id?: number
    username?: string | null
    email?: string | null
    hash_pass?: string | null
    first_name?: string | null
    last_name: string
    phone_mobile?: string | null
    address?: string | null
    created_date?: Date | string | null
    modified_date?: Date | string | null
    created_by?: number | null
    deleted?: number | null
    hash_rt?: string | null
    modified_by?: number | null
    status?: string | null
  }

  export type commission_settingCreateManyAgenciesInput = {
    id?: number
    vendor: string
    payment_type?: string
    tag?: string
    calculation_type?: string
    amount?: Decimal | DecimalJsLike | number | string
  }

  export type reservationCreateManyAgenciesInput = {
    supplier?: string | null
    agent_name?: string | null
    date_request?: Date | string | null
    res_status?: string | null
    invoice?: string | null
    res_id: string
    korean_name?: string | null
    first_name?: string | null
    last_name?: string | null
    pickup_loc?: string | null
    return_loc?: string | null
    pickup_datetime?: string | null
    return_datetime?: string | null
    pay_type?: string | null
    currency?: string | null
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    user_id?: number | null
    car_model?: string | null
    extra_equipmens?: string | null
    insurance_info?: string | null
    office_address?: string | null
    office_name?: string | null
    office_time?: string | null
    phone_code?: string | null
    phone_number?: string | null
    services?: string | null
    size_car?: string | null
    type_car?: string | null
    date_cancel?: Date | string | null
    email?: string | null
    flight_brand?: string | null
    flight_number?: string | null
    frequent_flyer?: string | null
    hertz_membership?: string | null
    office_second_address?: string | null
    office_second_name?: string | null
    office_second_time?: string | null
    dropFee?: Decimal | DecimalJsLike | number | string | null
    rate_amount?: Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
    tax?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type admin_usersUpdateWithoutAgenciesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_created_byNestedInput
    admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateOneWithoutOther_admin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateWithoutAgenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    admin_roles_admin_roles_created_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_created_byToadmin_usersNestedInput
    admin_roles_admin_roles_modified_byToadmin_users?: admin_rolesUncheckedUpdateManyWithoutAdmin_users_admin_roles_modified_byToadmin_usersNestedInput
    other_admin_users_admin_usersToadmin_users_created_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_created_byNestedInput
    other_admin_users_admin_usersToadmin_users_modified_by?: admin_usersUncheckedUpdateManyWithoutAdmin_users_admin_usersToadmin_users_modified_byNestedInput
    admin_users_roles?: admin_users_rolesUncheckedUpdateManyWithoutAdmin_usersNestedInput
  }

  export type admin_usersUncheckedUpdateManyWithoutAdmin_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    hash_pass?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: StringFieldUpdateOperationsInput | string
    phone_mobile?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: NullableIntFieldUpdateOperationsInput | number | null
    hash_rt?: NullableStringFieldUpdateOperationsInput | string | null
    modified_by?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commission_settingUpdateWithoutAgenciesInput = {
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vendors?: vendorsUpdateOneRequiredWithoutCommission_settingNestedInput
  }

  export type commission_settingUncheckedUpdateWithoutAgenciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendor?: StringFieldUpdateOperationsInput | string
    payment_type?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    calculation_type?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type reservationUpdateWithoutAgenciesInput = {
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vendors?: vendorsUpdateOneWithoutReservationNestedInput
    users?: usersUpdateOneWithoutReservationNestedInput
    payment?: paymentUpdateManyWithoutReservationNestedInput
  }

  export type reservationUncheckedUpdateWithoutAgenciesInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    agent_name?: NullableStringFieldUpdateOperationsInput | string | null
    date_request?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    res_status?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: NullableStringFieldUpdateOperationsInput | string | null
    res_id?: StringFieldUpdateOperationsInput | string
    korean_name?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_loc?: NullableStringFieldUpdateOperationsInput | string | null
    return_loc?: NullableStringFieldUpdateOperationsInput | string | null
    pickup_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    return_datetime?: NullableStringFieldUpdateOperationsInput | string | null
    pay_type?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    car_model?: NullableStringFieldUpdateOperationsInput | string | null
    extra_equipmens?: NullableStringFieldUpdateOperationsInput | string | null
    insurance_info?: NullableStringFieldUpdateOperationsInput | string | null
    office_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_time?: NullableStringFieldUpdateOperationsInput | string | null
    phone_code?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    services?: NullableStringFieldUpdateOperationsInput | string | null
    size_car?: NullableStringFieldUpdateOperationsInput | string | null
    type_car?: NullableStringFieldUpdateOperationsInput | string | null
    date_cancel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    flight_brand?: NullableStringFieldUpdateOperationsInput | string | null
    flight_number?: NullableStringFieldUpdateOperationsInput | string | null
    frequent_flyer?: NullableStringFieldUpdateOperationsInput | string | null
    hertz_membership?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_address?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_name?: NullableStringFieldUpdateOperationsInput | string | null
    office_second_time?: NullableStringFieldUpdateOperationsInput | string | null
    dropFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tax?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_foreigner_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payment?: paymentUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type keyword_faqCreateManyFaqInput = {
    id?: number
    name: string
  }

  export type keyword_faqUpdateWithoutFaqInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type keyword_faqUncheckedUpdateWithoutFaqInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type keyword_faqUncheckedUpdateManyWithoutKeyword_faqInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type faqCreateManySubject_faqInput = {
    id?: number
    question_kr: string
    question_us?: string | null
    answer_kr: string
    answer_us?: string | null
    status?: string | null
    sort_order: number
  }

  export type faqUpdateWithoutSubject_faqInput = {
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    keyword_faq?: keyword_faqUpdateManyWithoutFaqNestedInput
  }

  export type faqUncheckedUpdateWithoutSubject_faqInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
    keyword_faq?: keyword_faqUncheckedUpdateManyWithoutFaqNestedInput
  }

  export type faqUncheckedUpdateManyWithoutFaqInput = {
    id?: IntFieldUpdateOperationsInput | number
    question_kr?: StringFieldUpdateOperationsInput | string
    question_us?: NullableStringFieldUpdateOperationsInput | string | null
    answer_kr?: StringFieldUpdateOperationsInput | string
    answer_us?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sort_order?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}